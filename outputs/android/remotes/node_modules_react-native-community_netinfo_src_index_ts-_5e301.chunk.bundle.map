{"version":3,"file":"node_modules_react-native-community_netinfo_src_index_ts-_5e301.chunk.bundle","mappings":"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","sources":["webpack:///./node_modules/@react-native-community/netinfo/src/index.ts","webpack:///./node_modules/@react-native-community/netinfo/src/internal/defaultConfiguration.ts","webpack:///./node_modules/@react-native-community/netinfo/src/internal/internetReachability.ts","webpack:///./node_modules/@react-native-community/netinfo/src/internal/nativeInterface.ts","webpack:///./node_modules/@react-native-community/netinfo/src/internal/nativeModule.ts","webpack:///./node_modules/@react-native-community/netinfo/src/internal/privateTypes.ts","webpack:///./node_modules/@react-native-community/netinfo/src/internal/state.ts","webpack:///./node_modules/@react-native-community/netinfo/src/internal/types.ts"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {useState, useEffect, useCallback} from 'react';\nimport {Platform} from 'react-native';\nimport DEFAULT_CONFIGURATION from './internal/defaultConfiguration';\nimport NativeInterface from './internal/nativeInterface';\nimport State from './internal/state';\nimport * as Types from './internal/types';\n\n// Stores the currently used configuration\nlet _configuration = DEFAULT_CONFIGURATION;\n\n// Stores the singleton reference to the state manager\nlet _state: State | null = null;\nconst createState = (): State => {\n  return new State(_configuration);\n};\n\n/**\n * Configures the library with the given configuration. Note that calling this will stop all\n * previously added listeners from being called again. It is best to call this right when your\n * application is started to avoid issues. The configuration sets up a global singleton instance.\n *\n * @param configuration The new configuration to set.\n */\nexport function configure(\n  configuration: Partial<Types.NetInfoConfiguration>,\n): void {\n  _configuration = {\n    ...DEFAULT_CONFIGURATION,\n    ...configuration,\n  };\n\n  if (_state) {\n    _state.tearDown();\n    _state = createState();\n  }\n\n  if (Platform.OS === 'ios') {\n    NativeInterface.configure(configuration);\n  }\n}\n\n/**\n * Returns a `Promise` that resolves to a `NetInfoState` object.\n * This function operates on the global singleton instance configured using `configure()`\n *\n * @param [requestedInterface] interface from which to obtain the information\n *\n * @returns A Promise which contains the current connection state.\n */\nexport function fetch(\n  requestedInterface?: string,\n): Promise<Types.NetInfoState> {\n  if (!_state) {\n    _state = createState();\n  }\n  return _state.latest(requestedInterface);\n}\n\n/**\n * Force-refreshes the internal state of the global singleton managed by this library.\n *\n * @returns A Promise which contains the updated connection state.\n */\nexport function refresh(): Promise<Types.NetInfoState> {\n  if (!_state) {\n    _state = createState();\n  }\n  return _state._fetchCurrentState();\n}\n\n/**\n * Subscribe to the global singleton's connection information. The callback is called with a parameter of type\n * [`NetInfoState`](README.md#netinfostate) whenever the connection state changes. Your listener\n * will be called with the latest information soon after you subscribe and then with any\n * subsequent changes afterwards. You should not assume that the listener is called in the same\n * way across devices or platforms.\n *\n * @param listener The listener which is called when the network state changes.\n *\n * @returns A function which can be called to unsubscribe.\n */\nexport function addEventListener(\n  listener: Types.NetInfoChangeHandler,\n): Types.NetInfoSubscription {\n  if (!_state) {\n    _state = createState();\n  }\n\n  _state.add(listener);\n  return (): void => {\n    _state && _state.remove(listener);\n  };\n}\n\n/**\n * A React Hook into this library's singleton which updates when the connection state changes.\n *\n * @param {Partial<Types.NetInfoConfiguration>} configuration - Configure the isolated network checker managed by this hook\n *\n * @returns The connection state.\n */\nexport function useNetInfo(\n  configuration?: Partial<Types.NetInfoConfiguration>,\n): Types.NetInfoState {\n  if (configuration) {\n    configure(configuration);\n  }\n\n  const [netInfo, setNetInfo] = useState<Types.NetInfoState>({\n    type: Types.NetInfoStateType.unknown,\n    isConnected: null,\n    isInternetReachable: null,\n    details: null,\n  });\n\n  useEffect((): (() => void) => {\n    return addEventListener(setNetInfo);\n  }, []);\n\n  return netInfo;\n}\n\n/**\n * A React Hook which manages an isolated instance of the network info manager.\n * This is not a hook into a singleton shared state. NetInfo.configure, NetInfo.addEventListener,\n * NetInfo.fetch, NetInfo.refresh are performed on a global singleton and have no affect on this hook.\n * @param {boolean} isPaused - Pause the internal network checks.\n * @param {Partial<Types.NetInfoConfiguration>} configuration - Configure the isolated network checker managed by this hook\n *\n * @returns the netInfo state and a refresh function\n */\nexport function useNetInfoInstance(\n  isPaused = false,\n  configuration?: Partial<Types.NetInfoConfiguration>,\n) {\n  const [networkInfoManager, setNetworkInfoManager] = useState<State>();\n  const [netInfo, setNetInfo] = useState<Types.NetInfoState>({\n    type: Types.NetInfoStateType.unknown,\n    isConnected: null,\n    isInternetReachable: null,\n    details: null,\n  });\n\n  useEffect(() => {\n    if (isPaused) {\n      return;\n    }\n    const config = {\n      ...DEFAULT_CONFIGURATION,\n      ...configuration,\n    };\n    const state = new State(config);\n    setNetworkInfoManager(state);\n    state.add(setNetInfo);\n    return state.tearDown;\n  }, [isPaused, configuration]);\n\n  const refresh = useCallback(() => {\n    networkInfoManager && networkInfoManager._fetchCurrentState();\n  }, [networkInfoManager]);\n\n  return {\n    netInfo,\n    refresh,\n  };\n}\n\nexport * from './internal/types';\n\nexport default {\n  configure,\n  fetch,\n  refresh,\n  addEventListener,\n  useNetInfo,\n  useNetInfoInstance,\n};\n","import * as Types from './types';\n\nconst DEFAULT_CONFIGURATION: Types.NetInfoConfiguration = {\n  reachabilityUrl: 'https://clients3.google.com/generate_204',\n  reachabilityMethod: 'HEAD',\n  reachabilityHeaders: {},\n  reachabilityTest: (response: Response): Promise<boolean> =>\n    Promise.resolve(response.status === 204),\n  reachabilityShortTimeout: 5 * 1000, // 5s\n  reachabilityLongTimeout: 60 * 1000, // 60s\n  reachabilityRequestTimeout: 15 * 1000, // 15s\n  reachabilityShouldRun: (): boolean => true,\n  shouldFetchWiFiSSID: false,\n  useNativeReachability: true\n};\n\nexport default DEFAULT_CONFIGURATION;","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport * as PrivateTypes from './privateTypes';\nimport * as Types from './types';\n\ninterface InternetReachabilityCheckHandler {\n  promise: Promise<void>;\n  cancel: () => void;\n}\n\nexport default class InternetReachability {\n  private _configuration: Types.NetInfoConfiguration;\n  private _listener: PrivateTypes.NetInfoInternetReachabilityChangeListener;\n  private _isInternetReachable: boolean | null | undefined = undefined;\n  private _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null = null;\n  private _currentTimeoutHandle: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    configuration: Types.NetInfoConfiguration,\n    listener: PrivateTypes.NetInfoInternetReachabilityChangeListener,\n  ) {\n    this._configuration = configuration;\n    this._listener = listener;\n  }\n\n  private _setIsInternetReachable = (\n    isInternetReachable: boolean | null,\n  ): void => {\n    if (this._isInternetReachable === isInternetReachable) {\n      return;\n    }\n\n    this._isInternetReachable = isInternetReachable;\n    this._listener(this._isInternetReachable);\n  };\n\n  private _setExpectsConnection = (expectsConnection: boolean | null): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n\n    if (expectsConnection && this._configuration.reachabilityShouldRun()) {\n      // If we expect a connection, start the process for finding if we have one\n      // Set the state to \"null\" if it was previously false\n      if (!this._isInternetReachable) {\n        this._setIsInternetReachable(null);\n      }\n      // Start a network request to check for internet\n      this._currentInternetReachabilityCheckHandler = this._checkInternetReachability();\n    } else {\n      // If we don't expect a connection or don't run reachability check, just change the state to \"false\"\n      this._setIsInternetReachable(false);\n    }\n  };\n\n  private _checkInternetReachability = (): InternetReachabilityCheckHandler => {\n    const controller = new AbortController();\n\n    const responsePromise = fetch(this._configuration.reachabilityUrl, {\n      headers: this._configuration.reachabilityHeaders,\n      method: this._configuration.reachabilityMethod,\n      cache: 'no-cache',\n      signal: controller.signal,\n    });\n\n    // Create promise that will reject after the request timeout has been reached\n    let timeoutHandle: ReturnType<typeof setTimeout>;\n    const timeoutPromise = new Promise<Response>((_, reject): void => {\n      timeoutHandle = setTimeout(\n        (): void => reject('timedout'),\n        this._configuration.reachabilityRequestTimeout,\n      );\n    });\n\n    // Create promise that makes it possible to cancel a pending request through a reject\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    let cancel: () => void = (): void => {};\n    const cancelPromise = new Promise<Response>((_, reject): void => {\n      cancel = (): void => reject('canceled');\n    });\n\n    const promise = Promise.race([\n      responsePromise,\n      timeoutPromise,\n      cancelPromise,\n    ])\n      .then(\n        (response): Promise<boolean> => {\n          return this._configuration.reachabilityTest(response);\n        },\n      )\n      .then(\n        (result): void => {\n          this._setIsInternetReachable(result);\n          const nextTimeoutInterval = this._isInternetReachable\n            ? this._configuration.reachabilityLongTimeout\n            : this._configuration.reachabilityShortTimeout;\n          this._currentTimeoutHandle = setTimeout(\n            this._checkInternetReachability,\n            nextTimeoutInterval,\n          );\n        },\n      )\n      .catch(\n        (error: Error | 'timedout' | 'canceled'): void => {\n          if ('canceled' === error) {\n            controller.abort();\n          } else {\n            if ('timedout' === error) {\n              controller.abort();\n            }\n            \n            this._setIsInternetReachable(false);\n            this._currentTimeoutHandle = setTimeout(\n              this._checkInternetReachability,\n              this._configuration.reachabilityShortTimeout,\n            );\n          }\n        },\n      )\n      // Clear request timeout and propagate any errors\n      .then(\n        (): void => {\n          clearTimeout(timeoutHandle);\n        },\n        (error: Error): void => {\n          clearTimeout(timeoutHandle);\n          throw error;\n        },\n      );\n\n    return {\n      promise,\n      cancel,\n    };\n  };\n\n  public update = (state: PrivateTypes.NetInfoNativeModuleState): void => {\n    if (\n      typeof state.isInternetReachable === 'boolean' &&\n      this._configuration.useNativeReachability\n    ) {\n      this._setIsInternetReachable(state.isInternetReachable);\n    } else {\n      this._setExpectsConnection(state.isConnected);\n    }\n  };\n\n  public currentState = (): boolean | null | undefined => {\n    return this._isInternetReachable;\n  };\n\n  public tearDown = (): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n  };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {NativeEventEmitter} from 'react-native';\nimport RNCNetInfo from './nativeModule';\n\n// Produce an error if we don't have the native module\nif (!RNCNetInfo) {\n  throw new Error(`@react-native-community/netinfo: NativeModule.RNCNetInfo is null. To fix this issue try these steps:\n\n• Run \\`react-native link @react-native-community/netinfo\\` in the project root.\n• Rebuild and re-run the app.\n• If you are using CocoaPods on iOS, run \\`pod install\\` in the \\`ios\\` directory and then rebuild and re-run the app. You may also need to re-open Xcode to get the new pods.\n• Check that the library was linked correctly when you used the link command by running through the manual installation instructions in the README.\n* If you are getting this error while unit testing you need to mock the native module. Follow the guide in the README.\n\nIf none of these fix the issue, please open an issue on the Github repository: https://github.com/react-native-community/react-native-netinfo`);\n}\n\n/**\n * We export the native interface in this way to give easy shared access to it between the\n * JavaScript code and the tests\n */\nlet nativeEventEmitter: NativeEventEmitter | null = null;\nexport default {\n  ...RNCNetInfo,\n  get eventEmitter(): NativeEventEmitter {\n    if (!nativeEventEmitter) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      /// @ts-ignore\n      nativeEventEmitter = new NativeEventEmitter(RNCNetInfo);\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    /// @ts-ignore\n    return nativeEventEmitter;\n  },\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {NativeModules} from 'react-native';\nimport {NetInfoNativeModule} from './privateTypes';\n\nconst RNCNetInfo: NetInfoNativeModule = NativeModules.RNCNetInfo;\n\nexport default RNCNetInfo;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {NetInfoConfiguration, NetInfoState} from './types';\n\nexport const DEVICE_CONNECTIVITY_EVENT = 'netInfo.networkStatusDidChange';\n\n// Certain properties are optional when sent by the native module and are handled by the JS code\nexport type NetInfoNativeModuleState = Pick<\n  NetInfoState,\n  Exclude<keyof NetInfoState, 'isInternetReachable'>\n> & {isInternetReachable?: boolean};\n\nexport interface Events {\n  [DEVICE_CONNECTIVITY_EVENT]: NetInfoNativeModuleState;\n}\n\nexport interface NetInfoNativeModule {\n  configure: (config: Partial<NetInfoConfiguration>) => void;\n  getCurrentState: (\n    requestedInterface?: string,\n  ) => Promise<NetInfoNativeModuleState>;\n  addListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[K]) => void,\n  ): void;\n  removeListeners<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[K]) => void,\n  ): void;\n}\n\nexport type NetInfoInternetReachabilityChangeListener = (\n  isInternetReachable: boolean | null | undefined,\n) => void;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {NativeEventSubscription} from 'react-native';\nimport NativeInterface from './nativeInterface';\nimport InternetReachability from './internetReachability';\nimport * as Types from './types';\nimport * as PrivateTypes from './privateTypes';\n\nexport default class State {\n  private _nativeEventSubscription: NativeEventSubscription | null = null;\n  private _subscriptions = new Set<Types.NetInfoChangeHandler>();\n  private _latestState: Types.NetInfoState | null = null;\n  private _internetReachability: InternetReachability;\n\n  constructor(configuration: Types.NetInfoConfiguration) {\n    // Add the listener to the internet connectivity events\n    this._internetReachability = new InternetReachability(\n      configuration,\n      this._handleInternetReachabilityUpdate,\n    );\n\n    // Add the subscription to the native events\n    this._nativeEventSubscription = NativeInterface.eventEmitter.addListener(\n      PrivateTypes.DEVICE_CONNECTIVITY_EVENT,\n      this._handleNativeStateUpdate,\n    );\n\n    // Fetch the current state from the native module\n    this._fetchCurrentState();\n  }\n\n  private _handleNativeStateUpdate = (\n    state: PrivateTypes.NetInfoNativeModuleState,\n  ): void => {\n    // Update the internet reachability module\n    this._internetReachability.update(state);\n\n    // Convert the state from native to JS shape\n    const convertedState = this._convertState(state);\n\n    // Update the listeners\n    this._latestState = convertedState;\n    this._subscriptions.forEach((handler): void => handler(convertedState));\n  };\n\n  private _handleInternetReachabilityUpdate = (\n    isInternetReachable: boolean | null | undefined,\n  ): void => {\n    if (!this._latestState) {\n      return;\n    }\n\n    const nextState = {\n      ...this._latestState,\n      isInternetReachable,\n    } as Types.NetInfoState;\n    this._latestState = nextState;\n    this._subscriptions.forEach((handler): void => handler(nextState));\n  };\n\n  public _fetchCurrentState = async (\n    requestedInterface?: string,\n  ): Promise<Types.NetInfoState> => {\n    const state = await NativeInterface.getCurrentState(requestedInterface);\n\n    // Update the internet reachability module\n    this._internetReachability.update(state);\n    // Convert and store the new state\n    const convertedState = this._convertState(state);\n    if (!requestedInterface) {\n      this._latestState = convertedState;\n      this._subscriptions.forEach((handler): void => handler(convertedState));\n    }\n\n    return convertedState;\n  };\n\n  private _convertState = (\n    input: PrivateTypes.NetInfoNativeModuleState,\n  ): Types.NetInfoState => {\n    if (typeof input.isInternetReachable === 'boolean') {\n      return input as Types.NetInfoState;\n    } else {\n      return {\n        ...input,\n        isInternetReachable: this._internetReachability.currentState(),\n      } as Types.NetInfoState;\n    }\n  };\n\n  public latest = (\n    requestedInterface?: string,\n  ): Promise<Types.NetInfoState> => {\n    if (requestedInterface) {\n      return this._fetchCurrentState(requestedInterface);\n    } else if (this._latestState) {\n      return Promise.resolve(this._latestState);\n    } else {\n      return this._fetchCurrentState();\n    }\n  };\n\n  public add = (handler: Types.NetInfoChangeHandler): void => {\n    // Add the subscription handler to our set\n    this._subscriptions.add(handler);\n\n    // Send it the latest data we have\n    if (this._latestState) {\n      handler(this._latestState);\n    } else {\n      this.latest().then(handler);\n    }\n  };\n\n  public remove = (handler: Types.NetInfoChangeHandler): void => {\n    this._subscriptions.delete(handler);\n  };\n\n  public tearDown = (): void => {\n    if (this._internetReachability) {\n      this._internetReachability.tearDown();\n    }\n\n    if (this._nativeEventSubscription) {\n      this._nativeEventSubscription.remove();\n    }\n\n    this._subscriptions.clear();\n  };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nexport enum NetInfoStateType {\n  unknown = 'unknown',\n  none = 'none',\n  cellular = 'cellular',\n  wifi = 'wifi',\n  bluetooth = 'bluetooth',\n  ethernet = 'ethernet',\n  wimax = 'wimax',\n  vpn = 'vpn',\n  other = 'other',\n}\n\nexport type NetInfoMethodType = 'HEAD' | 'GET';\n\nexport enum NetInfoCellularGeneration {\n  '2g' = '2g',\n  '3g' = '3g',\n  '4g' = '4g',\n  '5g' = '5g',\n}\n\nexport interface NetInfoConnectedDetails {\n  isConnectionExpensive: boolean;\n}\n\ninterface NetInfoConnectedState<\n  T extends NetInfoStateType,\n  D extends Record<string, unknown> = Record<string, unknown>\n> {\n  type: T;\n  isConnected: true;\n  isInternetReachable: boolean | null;\n  details: D & NetInfoConnectedDetails;\n  isWifiEnabled?: boolean;\n}\n\ninterface NetInfoDisconnectedState<T extends NetInfoStateType> {\n  type: T;\n  isConnected: false;\n  isInternetReachable: false;\n  details: null;\n  isWifiEnabled?: boolean;\n}\n\nexport interface NetInfoUnknownState {\n  type: NetInfoStateType.unknown;\n  isConnected: boolean | null;\n  isInternetReachable: null;\n  details: null;\n  isWifiEnabled?: boolean;\n}\n\nexport type NetInfoNoConnectionState = NetInfoDisconnectedState<\n  NetInfoStateType.none\n>;\nexport type NetInfoDisconnectedStates =\n  | NetInfoUnknownState\n  | NetInfoNoConnectionState;\n\nexport type NetInfoCellularState = NetInfoConnectedState<\n  NetInfoStateType.cellular,\n  {\n    cellularGeneration: NetInfoCellularGeneration | null;\n    carrier: string | null;\n  }\n>;\nexport type NetInfoWifiState = NetInfoConnectedState<\n  NetInfoStateType.wifi,\n  {\n    ssid: string | null;\n    bssid: string | null;\n    strength: number | null;\n    ipAddress: string | null;\n    subnet: string | null;\n    frequency: number | null;\n    linkSpeed: number | null;\n    rxLinkSpeed: number | null;\n    txLinkSpeed: number | null;\n  }\n>;\nexport type NetInfoBluetoothState = NetInfoConnectedState<\n  NetInfoStateType.bluetooth\n>;\nexport type NetInfoEthernetState = NetInfoConnectedState<\n  NetInfoStateType.ethernet,\n  {\n    ipAddress: string | null;\n    subnet: string | null;\n  }\n>;\nexport type NetInfoWimaxState = NetInfoConnectedState<NetInfoStateType.wimax>;\nexport type NetInfoVpnState = NetInfoConnectedState<NetInfoStateType.vpn>;\nexport type NetInfoOtherState = NetInfoConnectedState<NetInfoStateType.other>;\nexport type NetInfoConnectedStates =\n  | NetInfoCellularState\n  | NetInfoWifiState\n  | NetInfoBluetoothState\n  | NetInfoEthernetState\n  | NetInfoWimaxState\n  | NetInfoVpnState\n  | NetInfoOtherState;\n\nexport type NetInfoState = NetInfoDisconnectedStates | NetInfoConnectedStates;\n\nexport type NetInfoChangeHandler = (state: NetInfoState) => void;\nexport type NetInfoSubscription = () => void;\n\nexport interface NetInfoConfiguration {\n  reachabilityUrl: string;\n  reachabilityMethod?: NetInfoMethodType;\n  reachabilityHeaders?: Record<string, string>;\n  reachabilityTest: (response: Response) => Promise<boolean>;\n  reachabilityLongTimeout: number;\n  reachabilityShortTimeout: number;\n  reachabilityRequestTimeout: number;\n  reachabilityShouldRun: () => boolean;\n  shouldFetchWiFiSSID: boolean;\n  useNativeReachability: boolean;\n}\n"],"names":["_react","require","_reactNative","_defaultConfiguration","_interopRequireDefault","_nativeInterface","_state2","Types","e","r","__esModule","default","t","_getRequireWildcardCache","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","prototype","hasOwnProperty","call","i","set","_interopRequireWildcard","WeakMap","keys","forEach","key","_exportNames","exports","enumerable","_configuration","DEFAULT_CONFIGURATION","_state","createState","State","configure","configuration","assign","tearDown","Platform","OS","NativeInterface","fetch","requestedInterface","latest","refresh","_fetchCurrentState","addEventListener","listener","add","remove","useNetInfo","_useState","useState","type","NetInfoStateType","unknown","isConnected","isInternetReachable","details","_useState2","_slicedToArray2","netInfo","setNetInfo","useEffect","useNetInfoInstance","isPaused","arguments","length","undefined","_useState3","_useState4","networkInfoManager","setNetworkInfoManager","_useState5","_useState6","config","state","useCallback","reachabilityUrl","reachabilityMethod","reachabilityHeaders","reachabilityTest","response","Promise","resolve","status","reachabilityShortTimeout","reachabilityLongTimeout","reachabilityRequestTimeout","reachabilityShouldRun","shouldFetchWiFiSSID","useNativeReachability","_createClass2","InternetReachability","_this","_classCallCheck2","_isInternetReachable","_currentInternetReachabilityCheckHandler","_currentTimeoutHandle","_setIsInternetReachable","_listener","_setExpectsConnection","expectsConnection","cancel","clearTimeout","_checkInternetReachability","timeoutHandle","controller","AbortController","responsePromise","headers","method","cache","signal","timeoutPromise","_","reject","setTimeout","cancelPromise","promise","race","then","result","nextTimeoutInterval","catch","error","abort","update","currentState","this","_nativeModule","RNCNetInfo","Error","nativeEventEmitter","eventEmitter","NativeEventEmitter","NativeModules","_internetReachability","PrivateTypes","_ref","_nativeEventSubscription","_subscriptions","Set","_latestState","_handleNativeStateUpdate","convertedState","_convertState","handler","_handleInternetReachabilityUpdate","nextState","_asyncToGenerator2","getCurrentState","_x","apply","input","delete","clear","addListener","DEVICE_CONNECTIVITY_EVENT","NetInfoCellularGeneration"],"sourceRoot":""}