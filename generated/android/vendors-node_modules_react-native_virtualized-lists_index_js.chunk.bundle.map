{"version":3,"file":"vendors-node_modules_react-native_virtualized-lists_index_js.chunk.bundle","mappings":"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","sources":["webpack:///./node_modules/@react-native/virtualized-lists/Interaction/Batchinator.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/ChildListCollection.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/StateSafePureComponent.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/ViewabilityHelper.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/VirtualizedListCellRenderer.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/VirtualizedListProps.js","webpack:///./node_modules/@react-native/virtualized-lists/Lists/VirtualizedSectionList.js","webpack:///./node_modules/@react-native/virtualized-lists/Utilities/clamp.js","webpack:///./node_modules/@react-native/virtualized-lists/Utilities/infoLog.js","webpack:///./node_modules/@react-native/virtualized-lists/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nconst {InteractionManager} = require('react-native');\n\n/**\n * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the\n * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,\n * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri\n * interactions are done running.\n *\n * Make sure to cleanup with dispose().  Example:\n *\n *   class Widget extends React.Component {\n *     _batchedSave: new Batchinator(() => this._saveState, 1000);\n *     _saveSate() {\n *       // save this.state to disk\n *     }\n *     componentDidUpdate() {\n *       this._batchedSave.schedule();\n *     }\n *     componentWillUnmount() {\n *       this._batchedSave.dispose();\n *     }\n *     ...\n *   }\n */\nclass Batchinator {\n  _callback: () => void;\n  _delay: number;\n  _taskHandle: ?{cancel: () => void, ...};\n  constructor(callback: () => void, delayMS: number) {\n    this._delay = delayMS;\n    this._callback = callback;\n  }\n  /*\n   * Cleanup any pending tasks.\n   *\n   * By default, if there is a pending task the callback is run immediately. Set the option abort to\n   * true to not call the callback if it was pending.\n   */\n  dispose(options: {abort: boolean, ...} = {abort: false}) {\n    if (this._taskHandle) {\n      this._taskHandle.cancel();\n      if (!options.abort) {\n        this._callback();\n      }\n      this._taskHandle = null;\n    }\n  }\n  schedule() {\n    if (this._taskHandle) {\n      return;\n    }\n    const timeoutHandle = setTimeout(() => {\n      this._taskHandle = InteractionManager.runAfterInteractions(() => {\n        // Note that we clear the handle before invoking the callback so that if the callback calls\n        // schedule again, it will actually schedule another task.\n        this._taskHandle = null;\n        this._callback();\n      });\n    }, this._delay);\n    this._taskHandle = {cancel: () => clearTimeout(timeoutHandle)};\n  }\n}\n\nmodule.exports = Batchinator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport type CellRegion = {\n  first: number,\n  last: number,\n  isSpacer: boolean,\n};\n\nexport class CellRenderMask {\n  _numCells: number;\n  _regions: Array<CellRegion>;\n\n  constructor(numCells: number) {\n    invariant(\n      numCells >= 0,\n      'CellRenderMask must contain a non-negative number os cells',\n    );\n\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [\n        {\n          first: 0,\n          last: numCells - 1,\n          isSpacer: true,\n        },\n      ];\n    }\n  }\n\n  enumerateRegions(): $ReadOnlyArray<CellRegion> {\n    return this._regions;\n  }\n\n  addCells(cells: {first: number, last: number}): void {\n    invariant(\n      cells.first >= 0 &&\n        cells.first < this._numCells &&\n        cells.last >= -1 &&\n        cells.last < this._numCells &&\n        cells.last >= cells.first - 1,\n      'CellRenderMask.addCells called with invalid cell range',\n    );\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    const newLeadRegion: Array<CellRegion> = [];\n    const newTailRegion: Array<CellRegion> = [];\n    const newMainRegion: CellRegion = {\n      ...cells,\n      isSpacer: false,\n    };\n\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n\n    const replacementRegions: Array<CellRegion> = [\n      ...newLeadRegion,\n      newMainRegion,\n      ...newTailRegion,\n    ];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(\n      firstIntersectIdx,\n      numRegionsToDelete,\n      ...replacementRegions,\n    );\n  }\n\n  numCells(): number {\n    return this._numCells;\n  }\n\n  equals(other: CellRenderMask): boolean {\n    return (\n      this._numCells === other._numCells &&\n      this._regions.length === other._regions.length &&\n      this._regions.every(\n        (region, i) =>\n          region.first === other._regions[i].first &&\n          region.last === other._regions[i].last &&\n          region.isSpacer === other._regions[i].isSpacer,\n      )\n    );\n  }\n\n  _findRegion(cellIdx: number): [CellRegion, number] {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport default class ChildListCollection<TList> {\n  _cellKeyToChildren: Map<string, Set<TList>> = new Map();\n  _childrenToCellKey: Map<TList, string> = new Map();\n\n  add(list: TList, cellKey: string): void {\n    invariant(\n      !this._childrenToCellKey.has(list),\n      'Trying to add already present child list',\n    );\n\n    const cellLists = this._cellKeyToChildren.get(cellKey) ?? new Set();\n    cellLists.add(list);\n    this._cellKeyToChildren.set(cellKey, cellLists);\n\n    this._childrenToCellKey.set(list, cellKey);\n  }\n\n  remove(list: TList): void {\n    const cellKey = this._childrenToCellKey.get(list);\n    invariant(cellKey != null, 'Trying to remove non-present child list');\n    this._childrenToCellKey.delete(list);\n\n    const cellLists = this._cellKeyToChildren.get(cellKey);\n    invariant(cellLists, '_cellKeyToChildren should contain cellKey');\n    cellLists.delete(list);\n\n    if (cellLists.size === 0) {\n      this._cellKeyToChildren.delete(cellKey);\n    }\n  }\n\n  forEach(fn: TList => void): void {\n    for (const listSet of this._cellKeyToChildren.values()) {\n      for (const list of listSet) {\n        fn(list);\n      }\n    }\n  }\n\n  forEachInCell(cellKey: string, fn: TList => void): void {\n    const listSet = this._cellKeyToChildren.get(cellKey) ?? [];\n    for (const list of listSet) {\n      fn(list);\n    }\n  }\n\n  anyInCell(cellKey: string, fn: TList => boolean): boolean {\n    const listSet = this._cellKeyToChildren.get(cellKey) ?? [];\n    for (const list of listSet) {\n      if (fn(list)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  size(): number {\n    return this._childrenToCellKey.size;\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {CellMetricProps} from './ListMetricsAggregator';\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\nexport type FillRateInfo = Info;\n\nclass Info {\n  any_blank_count: number = 0;\n  any_blank_ms: number = 0;\n  any_blank_speed_sum: number = 0;\n  mostly_blank_count: number = 0;\n  mostly_blank_ms: number = 0;\n  pixels_blank: number = 0;\n  pixels_sampled: number = 0;\n  pixels_scrolled: number = 0;\n  total_time_spent: number = 0;\n  sample_count: number = 0;\n}\n\nconst DEBUG = false;\n\nlet _listeners: Array<(Info) => void> = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  _anyBlankStartTime: ?number = null;\n  _enabled = false;\n  _listMetrics: ListMetricsAggregator;\n  _info: Info = new Info();\n  _mostlyBlankStartTime: ?number = null;\n  _samplesStartTime: ?number = null;\n\n  static addListener(callback: FillRateInfo => void): {\n    remove: () => void,\n    ...\n  } {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      },\n    };\n  }\n\n  static setSampleRate(sampleRate: number) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount: number) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(listMetrics: ListMetricsAggregator) {\n    this._listMetrics = listMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG &&\n        console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    const total_time_spent = global.performance.now() - start;\n    const info: any = {\n      ...this._info,\n      total_time_spent,\n    };\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank:\n          this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min:\n          this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min:\n          this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent,\n      };\n      for (const key in derived) {\n        // $FlowFixMe[prop-missing]\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {derived, info});\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n\n  computeBlankness(\n    props: {\n      ...CellMetricProps,\n      initialNumToRender?: ?number,\n      ...\n    },\n    cellsAroundViewport: {\n      first: number,\n      last: number,\n      ...\n    },\n    scrollMetrics: {\n      dOffset: number,\n      offset: number,\n      velocity: number,\n      visibleLength: number,\n      ...\n    },\n  ): number {\n    if (\n      !this._enabled ||\n      props.getItemCount(props.data) === 0 ||\n      cellsAroundViewport.last < cellsAroundViewport.first ||\n      this._samplesStartTime == null\n    ) {\n      return 0;\n    }\n    const {dOffset, offset, velocity, visibleLength} = scrollMetrics;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    const now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n\n    let blankTop = 0;\n    let first = cellsAroundViewport.first;\n    let firstFrame = this._listMetrics.getCellMetrics(first, props);\n    while (\n      first <= cellsAroundViewport.last &&\n      (!firstFrame || !firstFrame.isMounted)\n    ) {\n      firstFrame = this._listMetrics.getCellMetrics(first, props);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(\n        visibleLength,\n        Math.max(0, firstFrame.offset - offset),\n      );\n    }\n    let blankBottom = 0;\n    let last = cellsAroundViewport.last;\n    let lastFrame = this._listMetrics.getCellMetrics(last, props);\n    while (\n      last >= cellsAroundViewport.first &&\n      (!lastFrame || !lastFrame.isMounted)\n    ) {\n      lastFrame = this._listMetrics.getCellMetrics(last, props);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(\n        visibleLength,\n        Math.max(0, offset + visibleLength - bottomEdge),\n      );\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n\n  enabled(): boolean {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\n\nmodule.exports = FillRateHelper;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {Layout} from 'react-native/Libraries/Types/CoreEventTypes';\nimport type {Props as VirtualizedListProps} from './VirtualizedListProps';\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\n\nimport invariant from 'invariant';\n\nexport type CellMetrics = {\n  /**\n   * Index of the item in the list\n   */\n  index: number,\n  /**\n   * Length of the cell along the scrolling axis\n   */\n  length: number,\n  /**\n   * Distance between this cell and the start of the list along the scrolling\n   * axis\n   */\n  offset: number,\n  /**\n   * Whether the cell is last known to be mounted\n   */\n  isMounted: boolean,\n};\n\n// TODO: `inverted` can be incorporated here if it is moved to an order\n// based implementation instead of transform.\nexport type ListOrientation = {\n  horizontal: boolean,\n  rtl: boolean,\n};\n\n/**\n * Subset of VirtualizedList props needed to calculate cell metrics\n */\nexport type CellMetricProps = {\n  data: VirtualizedListProps['data'],\n  getItemCount: VirtualizedListProps['getItemCount'],\n  getItem: VirtualizedListProps['getItem'],\n  getItemLayout?: VirtualizedListProps['getItemLayout'],\n  keyExtractor?: VirtualizedListProps['keyExtractor'],\n  ...\n};\n\n/**\n * Provides an interface to query information about the metrics of a list and its cells.\n */\nexport default class ListMetricsAggregator {\n  _averageCellLength = 0;\n  _cellMetrics: Map<string, CellMetrics> = new Map();\n  _contentLength: ?number;\n  _highestMeasuredCellIndex = 0;\n  _measuredCellsLength = 0;\n  _measuredCellsCount = 0;\n  _orientation: ListOrientation = {\n    horizontal: false,\n    rtl: false,\n  };\n\n  /**\n   * Notify the ListMetricsAggregator that a cell has been laid out.\n   *\n   * @returns whether the cell layout has changed since last notification\n   */\n  notifyCellLayout({\n    cellIndex,\n    cellKey,\n    orientation,\n    layout,\n  }: {\n    cellIndex: number,\n    cellKey: string,\n    orientation: ListOrientation,\n    layout: Layout,\n  }): boolean {\n    this._invalidateIfOrientationChanged(orientation);\n\n    const next: CellMetrics = {\n      index: cellIndex,\n      length: this._selectLength(layout),\n      isMounted: true,\n      offset: this.flowRelativeOffset(layout),\n    };\n    const curr = this._cellMetrics.get(cellKey);\n\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n      if (curr) {\n        const dLength = next.length - curr.length;\n        this._measuredCellsLength += dLength;\n      } else {\n        this._measuredCellsLength += next.length;\n        this._measuredCellsCount += 1;\n      }\n\n      this._averageCellLength =\n        this._measuredCellsLength / this._measuredCellsCount;\n      this._cellMetrics.set(cellKey, next);\n      this._highestMeasuredCellIndex = Math.max(\n        this._highestMeasuredCellIndex,\n        cellIndex,\n      );\n      return true;\n    } else {\n      curr.isMounted = true;\n      return false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that a cell has been unmounted.\n   */\n  notifyCellUnmounted(cellKey: string): void {\n    const curr = this._cellMetrics.get(cellKey);\n    if (curr) {\n      curr.isMounted = false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that the lists content container has been laid out.\n   */\n  notifyListContentLayout({\n    orientation,\n    layout,\n  }: {\n    orientation: ListOrientation,\n    layout: $ReadOnly<{width: number, height: number}>,\n  }): void {\n    this._invalidateIfOrientationChanged(orientation);\n    this._contentLength = this._selectLength(layout);\n  }\n\n  /**\n   * Return the average length of the cells which have been measured\n   */\n  getAverageCellLength(): number {\n    return this._averageCellLength;\n  }\n\n  /**\n   * Return the highest measured cell index (or 0 if nothing has been measured\n   * yet)\n   */\n  getHighestMeasuredCellIndex(): number {\n    return this._highestMeasuredCellIndex;\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out,\n   * otherwise an estimate based on the average length of previously measured\n   * cells\n   */\n  getCellMetricsApprox(index: number, props: CellMetricProps): CellMetrics {\n    const frame = this.getCellMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      const {data, getItemCount} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index,\n        index,\n        isMounted: false,\n      };\n    }\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out\n   */\n  getCellMetrics(index: number, props: CellMetricProps): ?CellMetrics {\n    const {data, getItem, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get metrics for out of range cell index ' + index,\n    );\n    const keyExtractor = props.keyExtractor ?? defaultKeyExtractor;\n    const frame = this._cellMetrics.get(\n      keyExtractor(getItem(data, index), index),\n    );\n    if (frame && frame.index === index) {\n      return frame;\n    }\n\n    if (getItemLayout) {\n      const {length, offset} = getItemLayout(data, index);\n      // TODO: `isMounted` is used for both \"is exact layout\" and \"has been\n      // unmounted\". Should be refactored.\n      return {index, length, offset, isMounted: true};\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  getCellOffsetApprox(index: number, props: CellMetricProps): number {\n    if (Number.isInteger(index)) {\n      return this.getCellMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  }\n\n  /**\n   * Returns the length of all ScrollView content along the scrolling axis.\n   */\n  getContentLength(): number {\n    return this._contentLength ?? 0;\n  }\n\n  /**\n   * Whether a content length has been observed\n   */\n  hasContentLength(): boolean {\n    return this._contentLength != null;\n  }\n\n  /**\n   * Finds the flow-relative offset (e.g. starting from the left in LTR, but\n   * right in RTL) from a layout box.\n   */\n  flowRelativeOffset(layout: Layout, referenceContentLength?: ?number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      const contentLength = referenceContentLength ?? this._contentLength;\n      invariant(\n        contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return (\n        contentLength -\n        (this._selectOffset(layout) + this._selectLength(layout))\n      );\n    } else {\n      return this._selectOffset(layout);\n    }\n  }\n\n  /**\n   * Converts a flow-relative offset to a cartesian offset\n   */\n  cartesianOffset(flowRelativeOffset: number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      invariant(\n        this._contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return this._contentLength - flowRelativeOffset;\n    } else {\n      return flowRelativeOffset;\n    }\n  }\n\n  _invalidateIfOrientationChanged(orientation: ListOrientation): void {\n    if (orientation.rtl !== this._orientation.rtl) {\n      this._cellMetrics.clear();\n    }\n\n    if (orientation.horizontal !== this._orientation.horizontal) {\n      this._averageCellLength = 0;\n      this._highestMeasuredCellIndex = 0;\n      this._measuredCellsLength = 0;\n      this._measuredCellsCount = 0;\n    }\n\n    this._orientation = orientation;\n  }\n\n  _selectLength({\n    width,\n    height,\n  }: $ReadOnly<{width: number, height: number, ...}>): number {\n    return this._orientation.horizontal ? width : height;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation.horizontal ? x : y;\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\nimport * as React from 'react';\n\n/**\n * `setState` is called asynchronously, and should not rely on the value of\n * `this.props` or `this.state`:\n * https://react.dev/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous\n *\n * SafePureComponent adds runtime enforcement, to catch cases where these\n * variables are read in a state updater function, instead of the ones passed\n * in.\n */\nexport default class StateSafePureComponent<\n  Props,\n  State: interface {},\n> extends React.PureComponent<Props, State> {\n  _inAsyncStateUpdate = false;\n\n  constructor(props: Props) {\n    super(props);\n    this._installSetStateHooks();\n  }\n\n  setState(\n    partialState: ?(Partial<State> | ((State, Props) => ?Partial<State>)),\n    callback?: () => mixed,\n  ): void {\n    if (typeof partialState === 'function') {\n      super.setState((state, props) => {\n        this._inAsyncStateUpdate = true;\n        let ret;\n        try {\n          ret = partialState(state, props);\n        } catch (err) {\n          throw err;\n        } finally {\n          this._inAsyncStateUpdate = false;\n        }\n        return ret;\n      }, callback);\n    } else {\n      super.setState(partialState, callback);\n    }\n  }\n\n  _installSetStateHooks() {\n    const that = this;\n    let {props, state} = this;\n\n    Object.defineProperty(this, 'props', {\n      get() {\n        invariant(\n          !that._inAsyncStateUpdate,\n          '\"this.props\" should not be accessed during state updates',\n        );\n        return props;\n      },\n      set(newProps: Props) {\n        props = newProps;\n      },\n    });\n    Object.defineProperty(this, 'state', {\n      get() {\n        invariant(\n          !that._inAsyncStateUpdate,\n          '\"this.state\" should not be acceessed during state updates',\n        );\n        return state;\n      },\n      set(newState: State) {\n        state = newState;\n      },\n    });\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {CellMetricProps} from './ListMetricsAggregator';\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\nconst invariant = require('invariant');\n\nexport type ViewToken = {\n  item: any,\n  key: string,\n  index: ?number,\n  isViewable: boolean,\n  section?: any,\n  ...\n};\n\nexport type ViewabilityConfigCallbackPair = {\n  viewabilityConfig: ViewabilityConfig,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\nexport type ViewabilityConfig = {|\n  /**\n   * Minimum amount of time (in milliseconds) that an item must be physically viewable before the\n   * viewability callback will be fired. A high number means that scrolling through content without\n   * stopping will not mark the content as viewable.\n   */\n  minimumViewTime?: number,\n\n  /**\n   * Percent of viewport that must be covered for a partially occluded item to count as\n   * \"viewable\", 0-100. Fully visible items are always considered viewable. A value of 0 means\n   * that a single pixel in the viewport makes the item viewable, and a value of 100 means that\n   * an item must be either entirely visible or cover the entire viewport to count as viewable.\n   */\n  viewAreaCoveragePercentThreshold?: number,\n\n  /**\n   * Similar to `viewAreaPercentThreshold`, but considers the percent of the item that is visible,\n   * rather than the fraction of the viewable area it covers.\n   */\n  itemVisiblePercentThreshold?: number,\n\n  /**\n   * Nothing is considered viewable until the user scrolls or `recordInteraction` is called after\n   * render.\n   */\n  waitForInteraction?: boolean,\n|};\n\n/**\n * A Utility class for calculating viewable items based on current metrics like scroll position and\n * layout.\n *\n * An item is said to be in a \"viewable\" state when any of the following\n * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`\n * is true):\n *\n * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item\n *   visible in the view area >= `itemVisiblePercentThreshold`.\n * - Entirely visible on screen\n */\nclass ViewabilityHelper {\n  _config: ViewabilityConfig;\n  _hasInteracted: boolean = false;\n  _timers: Set<number> = new Set();\n  _viewableIndices: Array<number> = [];\n  _viewableItems: Map<string, ViewToken> = new Map();\n\n  constructor(\n    config: ViewabilityConfig = {viewAreaCoveragePercentThreshold: 0},\n  ) {\n    this._config = config;\n  }\n\n  /**\n   * Cleanup, e.g. on unmount. Clears any pending timers.\n   */\n  dispose() {\n    /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n     * comment suppresses an error found when Flow v0.63 was deployed. To see\n     * the error delete this comment and run Flow. */\n    this._timers.forEach(clearTimeout);\n  }\n\n  /**\n   * Determines which items are viewable based on the current metrics and config.\n   */\n  computeViewableItems(\n    props: CellMetricProps,\n    scrollOffset: number,\n    viewportHeight: number,\n    listMetrics: ListMetricsAggregator,\n    // Optional optimization to reduce the scan size\n    renderRange?: {\n      first: number,\n      last: number,\n      ...\n    },\n  ): Array<number> {\n    const itemCount = props.getItemCount(props.data);\n    const {itemVisiblePercentThreshold, viewAreaCoveragePercentThreshold} =\n      this._config;\n    const viewAreaMode = viewAreaCoveragePercentThreshold != null;\n    const viewablePercentThreshold = viewAreaMode\n      ? viewAreaCoveragePercentThreshold\n      : itemVisiblePercentThreshold;\n    invariant(\n      viewablePercentThreshold != null &&\n        (itemVisiblePercentThreshold != null) !==\n          (viewAreaCoveragePercentThreshold != null),\n      'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold',\n    );\n    const viewableIndices = [];\n    if (itemCount === 0) {\n      return viewableIndices;\n    }\n    let firstVisible = -1;\n    const {first, last} = renderRange || {first: 0, last: itemCount - 1};\n    if (last >= itemCount) {\n      console.warn(\n        'Invalid render range computing viewability ' +\n          JSON.stringify({renderRange, itemCount}),\n      );\n      return [];\n    }\n    for (let idx = first; idx <= last; idx++) {\n      const metrics = listMetrics.getCellMetrics(idx, props);\n      if (!metrics) {\n        continue;\n      }\n      const top = Math.floor(metrics.offset - scrollOffset);\n      const bottom = Math.floor(top + metrics.length);\n\n      if (top < viewportHeight && bottom > 0) {\n        firstVisible = idx;\n        if (\n          _isViewable(\n            viewAreaMode,\n            viewablePercentThreshold,\n            top,\n            bottom,\n            viewportHeight,\n            metrics.length,\n          )\n        ) {\n          viewableIndices.push(idx);\n        }\n      } else if (firstVisible >= 0) {\n        break;\n      }\n    }\n    return viewableIndices;\n  }\n\n  /**\n   * Figures out which items are viewable and how that has changed from before and calls\n   * `onViewableItemsChanged` as appropriate.\n   */\n  onUpdate(\n    props: CellMetricProps,\n    scrollOffset: number,\n    viewportHeight: number,\n    listMetrics: ListMetricsAggregator,\n    createViewToken: (\n      index: number,\n      isViewable: boolean,\n      props: CellMetricProps,\n    ) => ViewToken,\n    onViewableItemsChanged: ({\n      viewableItems: Array<ViewToken>,\n      changed: Array<ViewToken>,\n      ...\n    }) => void,\n    // Optional optimization to reduce the scan size\n    renderRange?: {\n      first: number,\n      last: number,\n      ...\n    },\n  ): void {\n    const itemCount = props.getItemCount(props.data);\n    if (\n      (this._config.waitForInteraction && !this._hasInteracted) ||\n      itemCount === 0 ||\n      !listMetrics.getCellMetrics(0, props)\n    ) {\n      return;\n    }\n    let viewableIndices: Array<number> = [];\n    if (itemCount) {\n      viewableIndices = this.computeViewableItems(\n        props,\n        scrollOffset,\n        viewportHeight,\n        listMetrics,\n        renderRange,\n      );\n    }\n    if (\n      this._viewableIndices.length === viewableIndices.length &&\n      this._viewableIndices.every((v, ii) => v === viewableIndices[ii])\n    ) {\n      // We might get a lot of scroll events where visibility doesn't change and we don't want to do\n      // extra work in those cases.\n      return;\n    }\n    this._viewableIndices = viewableIndices;\n    if (this._config.minimumViewTime) {\n      const handle: TimeoutID = setTimeout(() => {\n        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n         * comment suppresses an error found when Flow v0.63 was deployed. To\n         * see the error delete this comment and run Flow. */\n        this._timers.delete(handle);\n        this._onUpdateSync(\n          props,\n          viewableIndices,\n          onViewableItemsChanged,\n          createViewToken,\n        );\n      }, this._config.minimumViewTime);\n      /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n       * comment suppresses an error found when Flow v0.63 was deployed. To see\n       * the error delete this comment and run Flow. */\n      this._timers.add(handle);\n    } else {\n      this._onUpdateSync(\n        props,\n        viewableIndices,\n        onViewableItemsChanged,\n        createViewToken,\n      );\n    }\n  }\n\n  /**\n   * clean-up cached _viewableIndices to evaluate changed items on next update\n   */\n  resetViewableIndices() {\n    this._viewableIndices = [];\n  }\n\n  /**\n   * Records that an interaction has happened even if there has been no scroll.\n   */\n  recordInteraction() {\n    this._hasInteracted = true;\n  }\n\n  _onUpdateSync(\n    props: CellMetricProps,\n    viewableIndicesToCheck: Array<number>,\n    onViewableItemsChanged: ({\n      changed: Array<ViewToken>,\n      viewableItems: Array<ViewToken>,\n      ...\n    }) => void,\n    createViewToken: (\n      index: number,\n      isViewable: boolean,\n      props: CellMetricProps,\n    ) => ViewToken,\n  ) {\n    // Filter out indices that have gone out of view since this call was scheduled.\n    viewableIndicesToCheck = viewableIndicesToCheck.filter(ii =>\n      this._viewableIndices.includes(ii),\n    );\n    const prevItems = this._viewableItems;\n    const nextItems = new Map(\n      viewableIndicesToCheck.map(ii => {\n        const viewable = createViewToken(ii, true, props);\n        return [viewable.key, viewable];\n      }),\n    );\n\n    const changed = [];\n    for (const [key, viewable] of nextItems) {\n      if (!prevItems.has(key)) {\n        changed.push(viewable);\n      }\n    }\n    for (const [key, viewable] of prevItems) {\n      if (!nextItems.has(key)) {\n        changed.push({...viewable, isViewable: false});\n      }\n    }\n    if (changed.length > 0) {\n      this._viewableItems = nextItems;\n      onViewableItemsChanged({\n        viewableItems: Array.from(nextItems.values()),\n        changed,\n        viewabilityConfig: this._config,\n      });\n    }\n  }\n}\n\nfunction _isViewable(\n  viewAreaMode: boolean,\n  viewablePercentThreshold: number,\n  top: number,\n  bottom: number,\n  viewportHeight: number,\n  itemLength: number,\n): boolean {\n  if (_isEntirelyVisible(top, bottom, viewportHeight)) {\n    return true;\n  } else {\n    const pixels = _getPixelsVisible(top, bottom, viewportHeight);\n    const percent =\n      100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);\n    return percent >= viewablePercentThreshold;\n  }\n}\n\nfunction _getPixelsVisible(\n  top: number,\n  bottom: number,\n  viewportHeight: number,\n): number {\n  const visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);\n  return Math.max(0, visibleHeight);\n}\n\nfunction _isEntirelyVisible(\n  top: number,\n  bottom: number,\n  viewportHeight: number,\n): boolean {\n  return top >= 0 && bottom <= viewportHeight && bottom > top;\n}\n\nmodule.exports = ViewabilityHelper;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type ListMetricsAggregator, {\n  CellMetricProps,\n} from './ListMetricsAggregator';\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nexport function elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  props: CellMetricProps,\n  listMetrics: ListMetricsAggregator,\n  zoomScale: number = 1,\n): Array<number> {\n  const itemCount = props.getItemCount(props.data);\n  const result = [];\n  for (let offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    const currentOffset = offsets[offsetIndex];\n    let left = 0;\n    let right = itemCount - 1;\n\n    while (left <= right) {\n      const mid = left + Math.floor((right - left) / 2);\n      const frame = listMetrics.getCellMetricsApprox(mid, props);\n      const scaledOffsetStart = frame.offset * zoomScale;\n      const scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n\n      // We want the first frame that contains the offset, with inclusive bounds. Thus, for the\n      // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.\n      if (\n        (mid === 0 && currentOffset < scaledOffsetStart) ||\n        (mid !== 0 && currentOffset <= scaledOffsetStart)\n      ) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nexport function newRangeCount(\n  prev: {\n    first: number,\n    last: number,\n    ...\n  },\n  next: {\n    first: number,\n    last: number,\n    ...\n  },\n): number {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nexport function computeWindowedRenderLimits(\n  props: CellMetricProps,\n  maxToRenderPerBatch: number,\n  windowSize: number,\n  prev: {\n    first: number,\n    last: number,\n  },\n  listMetrics: ListMetricsAggregator,\n  scrollMetrics: {\n    dt: number,\n    offset: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n    ...\n  },\n): {\n  first: number,\n  last: number,\n} {\n  const itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {first: 0, last: -1};\n  }\n  const {offset, velocity, visibleLength, zoomScale = 1} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  const lastItemOffset =\n    listMetrics.getCellMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1,\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props,\n    listMetrics,\n    zoomScale,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nexport function keyExtractor(item: any, index: number): string {\n  if (typeof item === 'object' && item?.key != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && item?.id != null) {\n    return item.id;\n  }\n  return String(index);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {ScrollResponderType} from 'react-native/Libraries/Components/ScrollView/ScrollView';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  LayoutEvent,\n  ScrollEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\nimport type {ViewToken} from './ViewabilityHelper';\nimport type {\n  Item,\n  Props,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './VirtualizedListProps';\nimport type {CellMetricProps, ListOrientation} from './ListMetricsAggregator';\n\nimport {\n  I18nManager,\n  Platform,\n  RefreshControl,\n  ScrollView,\n  View,\n  StyleSheet,\n  findNodeHandle,\n} from 'react-native';\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport {CellRenderMask} from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport ListMetricsAggregator from './ListMetricsAggregator';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport {\n  VirtualizedListCellContextProvider,\n  VirtualizedListContext,\n  VirtualizedListContextProvider,\n} from './VirtualizedListContext.js';\nimport {\n  computeWindowedRenderLimits,\n  keyExtractor as defaultKeyExtractor,\n} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\n\nimport {\n  horizontalOrDefault,\n  initialNumToRenderOrDefault,\n  maxToRenderPerBatchOrDefault,\n  onStartReachedThresholdOrDefault,\n  onEndReachedThresholdOrDefault,\n  windowSizeOrDefault,\n} from './VirtualizedListProps';\n\nexport type {RenderItemProps, RenderItemType, Separators};\n\nconst ON_EDGE_REACHED_EPSILON = 0.001;\n\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName: string = '';\n\ntype ViewabilityHelperCallbackTuple = {\n  viewabilityHelper: ViewabilityHelper,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\ntype State = {\n  renderMask: CellRenderMask,\n  cellsAroundViewport: {first: number, last: number},\n  // Used to track items added at the start of the list for maintainVisibleContentPosition.\n  firstVisibleItemKey: ?string,\n  // When > 0 the scroll position available in JS is considered stale and should not be used.\n  pendingScrollUpdateCount: number,\n};\n\nfunction getScrollingThreshold(threshold: number, visibleLength: number) {\n  return (threshold * visibleLength) / 2;\n}\n\n/**\n * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)\n * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better\n * documented. In general, this should only really be used if you need more flexibility than\n * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.\n *\n * Virtualization massively improves memory consumption and performance of large lists by\n * maintaining a finite render window of active items and replacing all items outside of the render\n * window with appropriately sized blank space. The window adapts to scrolling behavior, and items\n * are rendered incrementally with low-pri (after any running interactions) if they are far from the\n * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.\n *\n * Some caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n * - As an effort to remove defaultProps, use helper functions when referencing certain props\n *\n */\nclass VirtualizedList extends StateSafePureComponent<Props, State> {\n  static contextType: typeof VirtualizedListContext = VirtualizedListContext;\n\n  // scrollToEnd may be janky without getItemLayout prop\n  scrollToEnd(params?: ?{animated?: ?boolean, ...}) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);\n    const offset = Math.max(\n      0,\n      frame.offset +\n        frame.length +\n        this._footerLength -\n        this._scrollMetrics.visibleLength,\n    );\n\n    // TODO: consider using `ref.scrollToEnd` directly\n    this.scrollToOffset({animated, offset});\n  }\n\n  // scrollToIndex may be janky without getItemLayout prop\n  scrollToIndex(params: {\n    animated?: ?boolean,\n    index: number,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }): $FlowFixMe {\n    const {data, getItemCount, getItemLayout, onScrollToIndexFailed} =\n      this.props;\n    const {animated, index, viewOffset, viewPosition} = params;\n    invariant(\n      index >= 0,\n      `scrollToIndex out of range: requested index ${index} but minimum is 0`,\n    );\n    invariant(\n      getItemCount(data) >= 1,\n      `scrollToIndex out of range: item length ${getItemCount(\n        data,\n      )} but minimum is 1`,\n    );\n    invariant(\n      index < getItemCount(data),\n      `scrollToIndex out of range: requested index ${index} is out of 0 to ${\n        getItemCount(data) - 1\n      }`,\n    );\n    if (\n      !getItemLayout &&\n      index > this._listMetrics.getHighestMeasuredCellIndex()\n    ) {\n      invariant(\n        !!onScrollToIndexFailed,\n        'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' +\n          'otherwise there is no way to know the location of offscreen indices or handle failures.',\n      );\n      onScrollToIndexFailed({\n        averageItemLength: this._listMetrics.getAverageCellLength(),\n        highestMeasuredFrameIndex:\n          this._listMetrics.getHighestMeasuredCellIndex(),\n        index,\n      });\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(\n      Math.floor(index),\n      this.props,\n    );\n    const offset =\n      Math.max(\n        0,\n        this._listMetrics.getCellOffsetApprox(index, this.props) -\n          (viewPosition || 0) *\n            (this._scrollMetrics.visibleLength - frame.length),\n      ) - (viewOffset || 0);\n\n    this.scrollToOffset({offset, animated});\n  }\n\n  // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -\n  // use scrollToIndex instead if possible.\n  scrollToItem(params: {\n    animated?: ?boolean,\n    item: Item,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }) {\n    const {item} = params;\n    const {data, getItem, getItemCount} = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex({...params, index});\n        break;\n      }\n    }\n  }\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   *\n   * Param `offset` expects the offset to scroll to.\n   * In case of `horizontal` is true, the offset is the x-value,\n   * in any other case the offset is the y-value.\n   *\n   * Param `animated` (`true` by default) defines whether the list\n   * should do an animation while scrolling.\n   */\n  scrollToOffset(params: {animated?: ?boolean, offset: number, ...}) {\n    const {animated, offset} = params;\n    const scrollRef = this._scrollRef;\n\n    if (scrollRef == null) {\n      return;\n    }\n\n    if (scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl && !this._listMetrics.hasContentLength()) {\n      console.warn(\n        'scrollToOffset may not be called in RTL before content is laid out',\n      );\n      return;\n    }\n\n    scrollRef.scrollTo({\n      animated,\n      ...this._scrollToParamsFromOffset(offset),\n    });\n  }\n\n  _scrollToParamsFromOffset(offset: number): {x?: number, y?: number} {\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      // Add the visible length of the scrollview so that the offset is right-aligned\n      const cartOffset = this._listMetrics.cartesianOffset(\n        offset + this._scrollMetrics.visibleLength,\n      );\n      return horizontal ? {x: cartOffset} : {y: cartOffset};\n    } else {\n      return horizontal ? {x: offset} : {y: offset};\n    }\n  }\n\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    this._scrollRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollRef` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder(): ?ScrollResponderType {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode(): ?number {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n\n  getScrollRef():\n    | ?React.ElementRef<typeof ScrollView>\n    | ?React.ElementRef<typeof View> {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n\n  setNativeProps(props: Object) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n\n  _getCellKey(): string {\n    return this.context?.cellKey || 'rootList';\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n\n  hasMore(): boolean {\n    return this._hasMore;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n\n  _registerAsNestedChild = (childList: {\n    cellKey: string,\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n\n  _unregisterAsNestedChild = (childList: {\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n\n  state: State;\n\n  constructor(props: Props) {\n    super(props);\n    this._checkProps(props);\n\n    this._fillRateHelper = new FillRateHelper(this._listMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(\n      this._updateCellsToRender,\n      this.props.updateCellsBatchingPeriod ?? 50,\n    );\n\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(\n        pair => ({\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged,\n        }),\n      );\n    } else {\n      const {onViewableItemsChanged, viewabilityConfig} = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged,\n        });\n      }\n    }\n\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n\n    const minIndexForVisible =\n      this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey:\n        this.props.getItemCount(this.props.data) > minIndexForVisible\n          ? VirtualizedList._getItemKey(this.props, minIndexForVisible)\n          : null,\n      // When we have a non-zero initialScrollIndex, we will receive a\n      // scroll event later so this will prevent the window from updating\n      // until we get a valid offset.\n      pendingScrollUpdateCount:\n        this.props.initialScrollIndex != null &&\n        this.props.initialScrollIndex > 0\n          ? 1\n          : 0,\n    };\n  }\n\n  _checkProps(props: Props) {\n    const {onScroll, windowSize, getItemCount, data, initialScrollIndex} =\n      props;\n\n    invariant(\n      // $FlowFixMe[prop-missing]\n      !onScroll || !onScroll.__isNative,\n      'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' +\n        'to support native onScroll events with useNativeDriver',\n    );\n    invariant(\n      windowSizeOrDefault(windowSize) > 0,\n      'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.',\n    );\n\n    invariant(\n      getItemCount,\n      'VirtualizedList: The \"getItemCount\" prop must be provided',\n    );\n\n    const itemCount = getItemCount(data);\n\n    if (\n      initialScrollIndex != null &&\n      !this._hasTriggeredInitialScrollToIndex &&\n      (initialScrollIndex < 0 ||\n        (itemCount > 0 && initialScrollIndex >= itemCount)) &&\n      !this._hasWarned.initialScrollIndex\n    ) {\n      console.warn(\n        `initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`,\n      );\n      this._hasWarned.initialScrollIndex = true;\n    }\n\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn(\n          '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' +\n            'Consider using `numColumns` with `FlatList` instead.',\n        );\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n\n  static _findItemIndexWithKey(\n    props: Props,\n    key: string,\n    hint: ?number,\n  ): ?number {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  static _getItemKey(\n    props: {\n      data: Props['data'],\n      getItem: Props['getItem'],\n      keyExtractor: Props['keyExtractor'],\n      ...\n    },\n    index: number,\n  ): string {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n\n  static _createRenderMask(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    additionalRegions?: ?$ReadOnlyArray<{first: number, last: number}>,\n  ): CellRenderMask {\n    const itemCount = props.getItemCount(props.data);\n\n    invariant(\n      cellsAroundViewport.first >= 0 &&\n        cellsAroundViewport.last >= cellsAroundViewport.first - 1 &&\n        cellsAroundViewport.last < itemCount,\n      `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`,\n    );\n\n    const renderMask = new CellRenderMask(itemCount);\n\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n\n      // The initially rendered cells are retained as part of the\n      // \"scroll-to-top\" optimization\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n\n      // The layout coordinates of sticker headers may be off-screen while the\n      // actual header is on-screen. Keep the most recent before the viewport\n      // rendered, even if its layout coordinates are not in viewport.\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(\n        props,\n        stickyIndicesSet,\n        renderMask,\n        cellsAroundViewport.first,\n      );\n    }\n\n    return renderMask;\n  }\n\n  static _initialRenderRegion(props: Props): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n\n    const firstCellIndex = Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)),\n    );\n\n    const lastCellIndex =\n      Math.min(\n        itemCount,\n        firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender),\n      ) - 1;\n\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex,\n    };\n  }\n\n  static _ensureClosestStickyHeader(\n    props: Props,\n    stickyIndicesSet: Set<number>,\n    renderMask: CellRenderMask,\n    cellIdx: number,\n  ) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({first: itemIdx, last: itemIdx});\n        break;\n      }\n    }\n  }\n\n  _adjustCellsAroundViewport(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    pendingScrollUpdateCount: number,\n  ): {first: number, last: number} {\n    const {data, getItemCount} = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      props.onEndReachedThreshold,\n    );\n    const {offset, visibleLength} = this._scrollMetrics;\n    const contentLength = this._listMetrics.getContentLength();\n    const distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Wait until the scroll view metrics have been set up. And until then,\n    // we will trust the initialNumToRender suggestion\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data)\n        ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n        : cellsAroundViewport;\n    }\n\n    let newCellsAroundViewport: {first: number, last: number};\n    if (props.disableVirtualization) {\n      const renderAhead =\n        distanceFromEnd < onEndReachedThreshold * visibleLength\n          ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch)\n          : 0;\n\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(\n          cellsAroundViewport.last + renderAhead,\n          getItemCount(data) - 1,\n        ),\n      };\n    } else {\n      // If we have a pending scroll update, we should not adjust the render window as it\n      // might override the correct window.\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data)\n          ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n          : cellsAroundViewport;\n      }\n\n      newCellsAroundViewport = computeWindowedRenderLimits(\n        props,\n        maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch),\n        windowSizeOrDefault(props.windowSize),\n        cellsAroundViewport,\n        this._listMetrics,\n        this._scrollMetrics,\n      );\n      invariant(\n        newCellsAroundViewport.last < getItemCount(data),\n        'computeWindowedRenderLimits() should return range in-bounds',\n      );\n    }\n\n    if (this._nestedChildLists.size() > 0) {\n      // If some cell in the new state has a child list in it, we should only render\n      // up through that item, so that we give that list a chance to render.\n      // Otherwise there's churn from multiple child lists mounting and un-mounting\n      // their items.\n\n      // Will this prevent rendering if the nested list doesn't realize the end?\n      const childIdx = this._findFirstChildWithMore(\n        newCellsAroundViewport.first,\n        newCellsAroundViewport.last,\n      );\n\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n\n    return newCellsAroundViewport;\n  }\n\n  _findFirstChildWithMore(first: number, last: number): number | null {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (\n        cellKeyForIndex != null &&\n        this._nestedChildLists.anyInCell(cellKeyForIndex, childList =>\n          childList.hasMore(),\n        )\n      ) {\n        return ii;\n      }\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({ref: this});\n    }\n    this._updateCellsToRenderBatcher.dispose({abort: true});\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n\n  static getDerivedStateFromProps(newProps: Props, prevState: State): State {\n    // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make\n    // sure we're rendering a reasonable range here.\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n\n    let maintainVisibleContentPositionAdjustment: ?number = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible =\n      newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey =\n      newProps.getItemCount(newProps.data) > minIndexForVisible\n        ? VirtualizedList._getItemKey(newProps, minIndexForVisible)\n        : null;\n    if (\n      newProps.maintainVisibleContentPosition != null &&\n      prevFirstVisibleItemKey != null &&\n      newFirstVisibleItemKey != null\n    ) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        // Fast path if items were added at the start of the list.\n        const hint =\n          itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(\n          newProps,\n          prevFirstVisibleItemKey,\n          hint,\n        );\n        maintainVisibleContentPositionAdjustment =\n          firstVisibleItemIndex != null\n            ? firstVisibleItemIndex - minIndexForVisible\n            : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n\n    const constrainedCells = VirtualizedList._constrainToItemCount(\n      maintainVisibleContentPositionAdjustment != null\n        ? {\n            first:\n              prevState.cellsAroundViewport.first +\n              maintainVisibleContentPositionAdjustment,\n            last:\n              prevState.cellsAroundViewport.last +\n              maintainVisibleContentPositionAdjustment,\n          }\n        : prevState.cellsAroundViewport,\n      newProps,\n    );\n\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount:\n        maintainVisibleContentPositionAdjustment != null\n          ? prevState.pendingScrollUpdateCount + 1\n          : prevState.pendingScrollUpdateCount,\n    };\n  }\n\n  _pushCells(\n    cells: Array<Object>,\n    stickyHeaderIndices: Array<number>,\n    stickyIndicesFromProps: Set<number>,\n    first: number,\n    last: number,\n    inversionStyle: ViewStyleProp,\n  ) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem,\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n\n      const shouldListenForLayout =\n        getItemLayout == null || debug || this._fillRateHelper.enabled();\n\n      cells.push(\n        <CellRenderer\n          CellRendererComponent={CellRendererComponent}\n          ItemSeparatorComponent={ii < end ? ItemSeparatorComponent : undefined}\n          ListItemComponent={ListItemComponent}\n          cellKey={key}\n          horizontal={horizontal}\n          index={ii}\n          inversionStyle={inversionStyle}\n          item={item}\n          key={key}\n          prevCellKey={prevCellKey}\n          onUpdateSeparators={this._onUpdateSeparators}\n          onCellFocusCapture={e => this._onCellFocusCapture(key)}\n          onUnmount={this._onCellUnmount}\n          ref={ref => {\n            this._cellRefs[key] = ref;\n          }}\n          renderItem={renderItem}\n          {...(shouldListenForLayout && {\n            onCellLayout: this._onCellLayout,\n          })}\n        />,\n      );\n      prevCellKey = key;\n    }\n  }\n\n  static _constrainToItemCount(\n    cells: {first: number, last: number},\n    props: Props,\n  ): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n    const lastPossibleCellIndex = itemCount - 1;\n\n    // Constraining `last` may significantly shrink the window. Adjust `first`\n    // to expand the window if the new `last` results in a new window smaller\n    // than the number of cells rendered per batch.\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(\n      props.maxToRenderPerBatch,\n    );\n    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);\n\n    return {\n      first: clamp(0, cells.first, maxFirst),\n      last: Math.min(lastPossibleCellIndex, cells.last),\n    };\n  }\n\n  _onUpdateSeparators = (keys: Array<?string>, newProps: Object) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n\n  _isNestedWithSameOrientation(): boolean {\n    const nestedContext = this.context;\n    return !!(\n      nestedContext &&\n      !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal)\n    );\n  }\n\n  _getSpacerKey = (isVertical: boolean): string =>\n    isVertical ? 'height' : 'width';\n\n  static _keyExtractor(\n    item: Item,\n    index: number,\n    props: {\n      keyExtractor?: ?(item: Item, index: number) => string,\n      ...\n    },\n  ): string {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n\n  render(): React.Node {\n    this._checkProps(this.props);\n    const {ListEmptyComponent, ListFooterComponent, ListHeaderComponent} =\n      this.props;\n    const {data, horizontal} = this.props;\n    const inversionStyle = this.props.inverted\n      ? horizontalOrDefault(this.props.horizontal)\n        ? styles.horizontallyInverted\n        : styles.verticallyInverted\n      : null;\n    const cells: Array<any | React.Node> = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n\n    // 1. Add cell for ListHeaderComponent\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? (\n        ListHeaderComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListHeaderComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-header'}\n          key=\"$header\">\n          <View\n            // We expect that header component will be a single native view so make it\n            // not collapsable to avoid this view being flattened and make this assumption\n            // no longer true.\n            collapsable={false}\n            onLayout={this._onLayoutHeader}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListHeaderComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2a. Add a cell for ListEmptyComponent if applicable\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element: React.Element<any> = ((React.isValidElement(\n        ListEmptyComponent,\n      ) ? (\n        ListEmptyComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListEmptyComponent />\n      )): any);\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-empty'}\n          key=\"$empty\">\n          {React.cloneElement(element, {\n            onLayout: (event: LayoutEvent) => {\n              this._onLayoutEmpty(event);\n              if (element.props.onLayout) {\n                element.props.onLayout(event);\n              }\n            },\n            style: StyleSheet.compose(inversionStyle, element.props.style),\n          })}\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2b. Add cells and spacers for each item\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastRegion = renderRegions[renderRegions.length - 1];\n      const lastSpacer = lastRegion?.isSpacer ? lastRegion : null;\n\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          // Legacy behavior is to avoid spacers when virtualization is\n          // disabled (including head spacers on initial render).\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n\n          // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to\n          // prevent the user for hyperscrolling into un-measured area because otherwise content will\n          // likely jump around as it renders in above the viewport.\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured\n            ? clamp(\n                section.first - 1,\n                section.last,\n                this._listMetrics.getHighestMeasuredCellIndex(),\n              )\n            : section.last;\n\n          const firstMetrics = this._listMetrics.getCellMetricsApprox(\n            section.first,\n            this.props,\n          );\n          const lastMetrics = this._listMetrics.getCellMetricsApprox(\n            last,\n            this.props,\n          );\n          const spacerSize =\n            lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(\n            <View\n              key={`$spacer-${section.first}`}\n              style={{[spacerKey]: spacerSize}}\n            />,\n          );\n        } else {\n          this._pushCells(\n            cells,\n            stickyHeaderIndices,\n            stickyIndicesFromProps,\n            section.first,\n            section.last,\n            inversionStyle,\n          );\n        }\n      }\n\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn(\n          'VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' +\n            'item or provide a custom keyExtractor.',\n          _keylessItemComponentName,\n        );\n        this._hasWarned.keys = true;\n      }\n    }\n\n    // 3. Add cell for ListFooterComponent\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? (\n        ListFooterComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListFooterComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getFooterCellKey()}\n          key=\"$footer\">\n          <View\n            onLayout={this._onLayoutFooter}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListFooterComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 4. Render the ScrollView\n    const scrollProps = {\n      ...this.props,\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      // iOS/macOS requires a non-zero scrollEventThrottle to fire more than a\n      // single notification while scrolling. This will otherwise no-op.\n      scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,\n      invertStickyHeaders:\n        this.props.invertStickyHeaders !== undefined\n          ? this.props.invertStickyHeaders\n          : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle\n        ? [inversionStyle, this.props.style]\n        : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition:\n        this.props.maintainVisibleContentPosition != null\n          ? {\n              ...this.props.maintainVisibleContentPosition,\n              // Adjust index to account for ListHeaderComponent.\n              minIndexForVisible:\n                this.props.maintainVisibleContentPosition.minIndexForVisible +\n                (this.props.ListHeaderComponent ? 1 : 0),\n            }\n          : undefined,\n    };\n\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n    const innerRet = (\n      <VirtualizedListContextProvider\n        value={{\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild,\n        }}>\n        {React.cloneElement(\n          (\n            this.props.renderScrollComponent ||\n            this._defaultRenderScrollComponent\n          )(scrollProps),\n          {\n            ref: this._captureScrollRef,\n          },\n          cells,\n        )}\n      </VirtualizedListContextProvider>\n    );\n    let ret: React.Node = innerRet;\n    if (__DEV__) {\n      ret = (\n        <ScrollView.Context.Consumer>\n          {scrollContext => {\n            if (\n              scrollContext != null &&\n              !scrollContext.horizontal ===\n                !horizontalOrDefault(this.props.horizontal) &&\n              !this._hasWarned.nesting &&\n              this.context == null &&\n              this.props.scrollEnabled !== false\n            ) {\n              // TODO (T46547044): use React.warn once 16.9 is sync'd: https://github.com/facebook/react/pull/15170\n              console.error(\n                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +\n                  'orientation because it can break windowing and other functionality - use another ' +\n                  'VirtualizedList-backed container instead.',\n              );\n              this._hasWarned.nesting = true;\n            }\n            return innerRet;\n          }}\n        </ScrollView.Context.Consumer>\n      );\n    }\n    if (this.props.debug) {\n      return (\n        <View style={styles.debug}>\n          {ret}\n          {this._renderDebugOverlay()}\n        </View>\n      );\n    } else {\n      return ret;\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const {data, extraData} = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      // clear the viewableIndices cache to also trigger\n      // the onViewableItemsChanged callback with the new data\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen\n    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true\n    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with\n    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The\n    // `_scheduleCellsToRenderUpdate` will check this condition and not perform\n    // another hiPri update.\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`\n    // is triggered with `this._hiPriInProgress = true`\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n\n  _cellRefs: {[string]: null | CellRenderer<any>} = {};\n  _fillRateHelper: FillRateHelper;\n  _listMetrics: ListMetricsAggregator = new ListMetricsAggregator();\n  _footerLength = 0;\n  // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned: {[string]: boolean} = {};\n  _headerLength = 0;\n  _hiPriInProgress: boolean = false; // flag to prevent infinite hiPri cell limit update\n  _indicesToKeys: Map<number, string> = new Map();\n  _lastFocusedCellKey: ?string = null;\n  _nestedChildLists: ChildListCollection<VirtualizedList> =\n    new ChildListCollection();\n  _offsetFromParentVirtualizedList: number = 0;\n  _pendingViewabilityUpdate: boolean = false;\n  _prevParentOffset: number = 0;\n  _scrollMetrics: {\n    dOffset: number,\n    dt: number,\n    offset: number,\n    timestamp: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n  } = {\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1,\n  };\n  _scrollRef: ?React.ElementRef<any> = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _updateCellsToRenderBatcher: Batchinator;\n  _viewabilityTuples: Array<ViewabilityHelperCallbackTuple> = [];\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._scrollMetrics,\n    );\n  }\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors\n      return <View {...props} />;\n    } else if (onRefresh) {\n      invariant(\n        typeof props.refreshing === 'boolean',\n        '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' +\n          JSON.stringify(props.refreshing ?? 'undefined') +\n          '`',\n      );\n      return (\n        // $FlowFixMe[prop-missing] Invalid prop usage\n        // $FlowFixMe[incompatible-use]\n        <ScrollView\n          {...props}\n          refreshControl={\n            props.refreshControl == null ? (\n              <RefreshControl\n                // $FlowFixMe[incompatible-type]\n                refreshing={props.refreshing}\n                onRefresh={onRefresh}\n                progressViewOffset={props.progressViewOffset}\n              />\n            ) : (\n              props.refreshControl\n            )\n          }\n        />\n      );\n    } else {\n      // $FlowFixMe[prop-missing] Invalid prop usage\n      // $FlowFixMe[incompatible-use]\n      return <ScrollView {...props} />;\n    }\n  };\n\n  _onCellLayout = (\n    e: LayoutEvent,\n    cellKey: string,\n    cellIndex: number,\n  ): void => {\n    const layoutHasChanged = this._listMetrics.notifyCellLayout({\n      cellIndex,\n      cellKey,\n      layout: e.nativeEvent.layout,\n      orientation: this._orientation(),\n    });\n\n    if (layoutHasChanged) {\n      this._scheduleCellsToRenderUpdate();\n    }\n\n    this._triggerRemeasureForChildListsInCell(cellKey);\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n\n  _onCellFocusCapture(cellKey: string) {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  }\n\n  _onCellUnmount = (cellKey: string) => {\n    delete this._cellRefs[cellKey];\n    this._listMetrics.notifyCellUnmounted(cellKey);\n  };\n\n  _triggerRemeasureForChildListsInCell(cellKey: string): void {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n\n  measureLayoutRelativeToContainingList(): void {\n    // TODO (T35574538): findNodeHandle sometimes crashes with \"Unable to find\n    // node on an unmounted component\" during scrolling\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      // We are assuming that getOutermostParentListRef().getScrollRef()\n      // is a non-null reference to a ScrollView\n      this._scrollRef.measureLayout(\n        this.context.getOutermostParentListRef().getScrollRef(),\n        (x, y, width, height) => {\n          this._offsetFromParentVirtualizedList = this._selectOffset({x, y});\n          this._listMetrics.notifyListContentLayout({\n            layout: {width, height},\n            orientation: this._orientation(),\n          });\n          const scrollMetrics = this._convertParentScrollMetrics(\n            this.context.getScrollMetrics(),\n          );\n\n          const metricsChanged =\n            this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength ||\n            this._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            this._scrollMetrics.offset = scrollMetrics.offset;\n\n            // If metrics of the scrollView changed, then we triggered remeasure for child list\n            // to ensure VirtualizedList has the right information.\n            this._nestedChildLists.forEach(childList => {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        },\n        error => {\n          console.warn(\n            \"VirtualizedList: Encountered an error while measuring a list's\" +\n              ' offset from its containing VirtualizedList.',\n          );\n        },\n      );\n    } catch (error) {\n      console.warn(\n        'measureLayoutRelativeToContainingList threw an error',\n        error.stack,\n      );\n    }\n  }\n\n  _onLayout = (e: LayoutEvent) => {\n    if (this._isNestedWithSameOrientation()) {\n      // Need to adjust our scroll metrics to be relative to our containing\n      // VirtualizedList before we can make claims about list item viewability\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(\n        e.nativeEvent.layout,\n      );\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  _onLayoutEmpty = (e: LayoutEvent) => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n\n  _getFooterCellKey(): string {\n    return this._getCellKey() + '-footer';\n  }\n\n  _onLayoutFooter = (e: LayoutEvent) => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  _onLayoutHeader = (e: LayoutEvent) => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  // $FlowFixMe[missing-local-annot]\n  _renderDebugOverlay() {\n    const normalize =\n      this._scrollMetrics.visibleLength /\n      (this._listMetrics.getContentLength() || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this._listMetrics.getCellMetricsApprox(ii, this.props);\n      if (frame.isMounted) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.first,\n      this.props,\n    ).offset;\n    const frameLast = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.last,\n      this.props,\n    );\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n\n    return (\n      <View style={[styles.debugOverlayBase, styles.debugOverlay]}>\n        {framesInLayout.map((f, ii) => (\n          <View\n            key={'f' + ii}\n            style={[\n              styles.debugOverlayBase,\n              styles.debugOverlayFrame,\n              {\n                top: f.offset * normalize,\n                height: f.length * normalize,\n              },\n            ]}\n          />\n        ))}\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameLast,\n            {\n              top: windowTop * normalize,\n              height: windowLen * normalize,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameVis,\n            {\n              top: visTop * normalize,\n              height: visLen * normalize,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n\n  _selectLength(\n    metrics: $ReadOnly<{\n      height: number,\n      width: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal)\n      ? metrics.height\n      : metrics.width;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation().horizontal ? x : y;\n  }\n\n  _orientation(): ListOrientation {\n    return {\n      horizontal: horizontalOrDefault(this.props.horizontal),\n      rtl: I18nManager.isRTL,\n    };\n  }\n\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold,\n    } = this.props;\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the edge reached callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n\n    const {visibleLength, offset} = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd =\n      this._listMetrics.getContentLength() - visibleLength - offset;\n\n    // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0\n    // since debouncing causes us to not fire this event for every single \"pixel\" we scroll and can thus\n    // be at the edge of the list with a distance approximating 0 but not quite there.\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n\n    // TODO: T121172172 Look into why we're \"defaulting\" to a threshold of 2px\n    // when oERT is not present (different from 2 viewports used elsewhere)\n    const DEFAULT_THRESHOLD_PX = 2;\n\n    const startThreshold =\n      onStartReachedThreshold != null\n        ? onStartReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const endThreshold =\n      onEndReachedThreshold != null\n        ? onEndReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n\n    // First check if the user just scrolled within the end threshold\n    // and call onEndReached only once for a given content length,\n    // and only if onStartReached is not being executed\n    if (\n      onEndReached &&\n      this.state.cellsAroundViewport.last === getItemCount(data) - 1 &&\n      isWithinEndThreshold &&\n      this._listMetrics.getContentLength() !== this._sentEndForContentLength\n    ) {\n      this._sentEndForContentLength = this._listMetrics.getContentLength();\n      onEndReached({distanceFromEnd});\n    }\n\n    // Next check if the user just scrolled within the start threshold\n    // and call onStartReached only once for a given content length,\n    // and only if onEndReached is not being executed\n    else if (\n      onStartReached != null &&\n      this.state.cellsAroundViewport.first === 0 &&\n      isWithinStartThreshold &&\n      this._listMetrics.getContentLength() !== this._sentStartForContentLength\n    ) {\n      this._sentStartForContentLength = this._listMetrics.getContentLength();\n      onStartReached({distanceFromStart});\n    }\n\n    // If the user scrolls away from the start or end and back again,\n    // cause onStartReached or onEndReached to be triggered again\n    else {\n      this._sentStartForContentLength = isWithinStartThreshold\n        ? this._sentStartForContentLength\n        : 0;\n      this._sentEndForContentLength = isWithinEndThreshold\n        ? this._sentEndForContentLength\n        : 0;\n    }\n  }\n\n  _onContentSizeChange = (width: number, height: number) => {\n    this._listMetrics.notifyListContentLayout({\n      layout: {width, height},\n      orientation: this._orientation(),\n    });\n\n    this._maybeScrollToInitialScrollIndex(width, height);\n\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  /**\n   * Scroll to a specified `initialScrollIndex` prop after the ScrollView\n   * content has been laid out, if it is still valid. Only a single scroll is\n   * triggered throughout the lifetime of the list.\n   */\n  _maybeScrollToInitialScrollIndex(\n    contentWidth: number,\n    contentHeight: number,\n  ) {\n    if (\n      contentWidth > 0 &&\n      contentHeight > 0 &&\n      this.props.initialScrollIndex != null &&\n      this.props.initialScrollIndex > 0 &&\n      !this._hasTriggeredInitialScrollToIndex\n    ) {\n      if (this.props.contentOffset == null) {\n        if (\n          this.props.initialScrollIndex <\n          this.props.getItemCount(this.props.data)\n        ) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex),\n          });\n        } else {\n          this.scrollToEnd({animated: false});\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n  }\n\n  /* Translates metrics from a scroll event in a parent VirtualizedList into\n   * coordinates relative to the child list.\n   */\n  _convertParentScrollMetrics = (metrics: {\n    visibleLength: number,\n    offset: number,\n    ...\n  }): $FlowFixMe => {\n    // Offset of the top of the nested list relative to the top of its parent's viewport\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    // Child's visible length is the same as its parent's\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._listMetrics.getContentLength();\n\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset,\n    };\n  };\n\n  _onScroll = (e: Object) => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._offsetFromScrollEvent(e);\n    let dOffset = offset - this._scrollMetrics.offset;\n\n    if (this._isNestedWithSameOrientation()) {\n      if (this._listMetrics.getContentLength() === 0) {\n        // Ignore scroll events until onLayout has been called and we\n        // know our offset from our offset from our parent\n        return;\n      }\n      ({visibleLength, contentLength, offset, dOffset} =\n        this._convertParentScrollMetrics({\n          visibleLength,\n          offset,\n        }));\n    }\n\n    const dt = this._scrollMetrics.timestamp\n      ? Math.max(1, timestamp - this._scrollMetrics.timestamp)\n      : 1;\n    const velocity = dOffset / dt;\n\n    if (\n      dt > 500 &&\n      this._scrollMetrics.dt > 500 &&\n      contentLength > 5 * visibleLength &&\n      !this._hasWarned.perf\n    ) {\n      infoLog(\n        'VirtualizedList: You have a large list that is slow to update - make sure your ' +\n          'renderItem function renders components that follow React performance best practices ' +\n          'like PureComponent, shouldComponentUpdate, etc.',\n        {dt, prevDt: this._scrollMetrics.dt, contentLength},\n      );\n      this._hasWarned.perf = true;\n    }\n\n    // For invalid negative values (w/ RTL), set this to 1.\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale,\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1,\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n\n  _offsetFromScrollEvent(e: ScrollEvent): number {\n    const {contentOffset, contentSize, layoutMeasurement} = e.nativeEvent;\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      return (\n        this._selectLength(contentSize) -\n        (this._selectOffset(contentOffset) +\n          this._selectLength(layoutMeasurement))\n      );\n    } else {\n      return this._selectOffset(contentOffset);\n    }\n  }\n\n  _scheduleCellsToRenderUpdate() {\n    // Only trigger high-priority updates if we've actually rendered cells,\n    // and with that size estimate, accurately compute how many cells we should render.\n    // Otherwise, it would just render as many cells as it can (of zero dimension),\n    // each time through attempting to render more (limited by maxToRenderPerBatch),\n    // starving the renderer from actually laying out the objects and computing _averageCellLength.\n    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate\n    // We shouldn't do another hipri cellToRenderUpdate\n    if (\n      (this._listMetrics.getAverageCellLength() > 0 ||\n        this.props.getItemLayout != null) &&\n      this._shouldRenderWithPriority() &&\n      !this._hiPriInProgress\n    ) {\n      this._hiPriInProgress = true;\n      // Don't worry about interactions when scrolling quickly; focus on filling content as fast\n      // as possible.\n      this._updateCellsToRenderBatcher.dispose({abort: true});\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n\n  _shouldRenderWithPriority(): boolean {\n    const {first, last} = this.state.cellsAroundViewport;\n    const {offset, visibleLength, velocity} = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(\n      this.props.onStartReachedThreshold,\n    );\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      this.props.onEndReachedThreshold,\n    );\n    // Mark as high priority if we're close to the start of the first item\n    // But only if there are items before the first rendered item\n    if (first > 0) {\n      const distTop =\n        offset -\n        this._listMetrics.getCellMetricsApprox(first, this.props).offset;\n      hiPri =\n        distTop < 0 ||\n        (velocity < -2 &&\n          distTop <\n            getScrollingThreshold(onStartReachedThreshold, visibleLength));\n    }\n    // Mark as high priority if we're close to the end of the last item\n    // But only if there are items after the last rendered item\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom =\n        this._listMetrics.getCellMetricsApprox(last, this.props).offset -\n        (offset + visibleLength);\n      hiPri =\n        distBottom < 0 ||\n        (velocity > 2 &&\n          distBottom <\n            getScrollingThreshold(onEndReachedThreshold, visibleLength));\n    }\n\n    return hiPri;\n  }\n\n  _onScrollBeginDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  _onScrollEndDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {velocity} = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  _onMomentumScrollBegin = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  _onMomentumScrollEnd = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(\n        props,\n        state.cellsAroundViewport,\n        state.pendingScrollUpdateCount,\n      );\n      const renderMask = VirtualizedList._createRenderMask(\n        props,\n        cellsAroundViewport,\n        this._getNonViewportRenderRegions(props),\n      );\n\n      if (\n        cellsAroundViewport.first === state.cellsAroundViewport.first &&\n        cellsAroundViewport.last === state.cellsAroundViewport.last &&\n        renderMask.equals(state.renderMask)\n      ) {\n        return null;\n      }\n\n      return {cellsAroundViewport, renderMask};\n    });\n  };\n\n  _createViewToken = (\n    index: number,\n    isViewable: boolean,\n    props: CellMetricProps,\n    // $FlowFixMe[missing-local-annot]\n  ) => {\n    const {data, getItem} = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable,\n    };\n  };\n\n  __getListMetrics(): ListMetricsAggregator {\n    return this._listMetrics;\n  }\n\n  _getNonViewportRenderRegions = (\n    props: CellMetricProps,\n  ): $ReadOnlyArray<{\n    first: number,\n    last: number,\n  }> => {\n    // Keep a viewport's worth of content around the last focused cell to allow\n    // random navigation around it without any blanking. E.g. tabbing from one\n    // focused item out of viewport to another.\n    if (\n      !(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])\n    ) {\n      return [];\n    }\n\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n\n    // The last cell we rendered may be at a new index. Bail if we don't know\n    // where it is.\n    if (\n      focusedCellIndex >= itemCount ||\n      VirtualizedList._getItemKey(props, focusedCellIndex) !==\n        this._lastFocusedCellKey\n    ) {\n      return [];\n    }\n\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (\n      let i = first - 1;\n      i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength;\n      i--\n    ) {\n      first--;\n      heightOfCellsBeforeFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (\n      let i = last + 1;\n      i < itemCount &&\n      heightOfCellsAfterFocused < this._scrollMetrics.visibleLength;\n      i++\n    ) {\n      last++;\n      heightOfCellsAfterFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    return [{first, last}];\n  };\n\n  _updateViewableItems(\n    props: CellMetricProps,\n    cellsAroundViewport: {first: number, last: number},\n  ) {\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the visibility callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(\n        props,\n        this._scrollMetrics.offset,\n        this._scrollMetrics.visibleLength,\n        this._listMetrics,\n        this._createViewToken,\n        tuple.onViewableItemsChanged,\n        cellsAroundViewport,\n      );\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  verticallyInverted:\n    Platform.OS === 'android'\n      ? {transform: [{scale: -1}]}\n      : {transform: [{scaleY: -1}]},\n  horizontallyInverted: {\n    transform: [{scaleX: -1}],\n  },\n  debug: {\n    flex: 1,\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1,\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange',\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2,\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2,\n  },\n});\n\nmodule.exports = VirtualizedList;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  FocusEvent,\n  LayoutEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\nimport type {CellRendererProps, RenderItemType} from './VirtualizedListProps';\n\nimport {View, StyleSheet} from 'react-native';\nimport {VirtualizedListCellContextProvider} from './VirtualizedListContext.js';\nimport invariant from 'invariant';\nimport * as React from 'react';\n\nexport type Props<ItemT> = {\n  CellRendererComponent?: ?React.ComponentType<CellRendererProps<ItemT>>,\n  ItemSeparatorComponent: ?React.ComponentType<\n    any | {highlighted: boolean, leadingItem: ?ItemT},\n  >,\n  ListItemComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  cellKey: string,\n  horizontal: ?boolean,\n  index: number,\n  inversionStyle: ViewStyleProp,\n  item: ItemT,\n  onCellLayout?: (event: LayoutEvent, cellKey: string, index: number) => void,\n  onCellFocusCapture?: (event: FocusEvent) => void,\n  onUnmount: (cellKey: string) => void,\n  onUpdateSeparators: (\n    cellKeys: Array<?string>,\n    props: Partial<SeparatorProps<ItemT>>,\n  ) => void,\n  prevCellKey: ?string,\n  renderItem?: ?RenderItemType<ItemT>,\n  ...\n};\n\ntype SeparatorProps<ItemT> = $ReadOnly<{|\n  highlighted: boolean,\n  leadingItem: ?ItemT,\n|}>;\n\ntype State<ItemT> = {\n  separatorProps: SeparatorProps<ItemT>,\n  ...\n};\n\nexport default class CellRenderer<ItemT> extends React.Component<\n  Props<ItemT>,\n  State<ItemT>,\n> {\n  state: State<ItemT> = {\n    separatorProps: {\n      highlighted: false,\n      leadingItem: this.props.item,\n    },\n  };\n\n  static getDerivedStateFromProps(\n    props: Props<ItemT>,\n    prevState: State<ItemT>,\n  ): ?State<ItemT> {\n    return {\n      separatorProps: {\n        ...prevState.separatorProps,\n        leadingItem: props.item,\n      },\n    };\n  }\n\n  // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not\n  // reused by SectionList and we can keep VirtualizedList simpler.\n  // $FlowFixMe[missing-local-annot]\n  _separators = {\n    highlight: () => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators([cellKey, prevCellKey], {\n        highlighted: true,\n      });\n    },\n    unhighlight: () => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators([cellKey, prevCellKey], {\n        highlighted: false,\n      });\n    },\n    updateProps: (\n      select: 'leading' | 'trailing',\n      newProps: SeparatorProps<ItemT>,\n    ) => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators(\n        [select === 'leading' ? prevCellKey : cellKey],\n        newProps,\n      );\n    },\n  };\n\n  updateSeparatorProps(newProps: SeparatorProps<ItemT>) {\n    this.setState(state => ({\n      separatorProps: {...state.separatorProps, ...newProps},\n    }));\n  }\n\n  componentWillUnmount() {\n    this.props.onUnmount(this.props.cellKey);\n  }\n\n  _onLayout = (nativeEvent: LayoutEvent): void => {\n    this.props.onCellLayout &&\n      this.props.onCellLayout(\n        nativeEvent,\n        this.props.cellKey,\n        this.props.index,\n      );\n  };\n\n  _renderElement(\n    renderItem: ?RenderItemType<ItemT>,\n    ListItemComponent: any,\n    item: ItemT,\n    index: number,\n  ): React.Node {\n    if (renderItem && ListItemComponent) {\n      console.warn(\n        'VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' +\n          ' precedence over renderItem.',\n      );\n    }\n\n    if (ListItemComponent) {\n      /* $FlowFixMe[not-a-component] (>=0.108.0 site=react_native_fb) This\n       * comment suppresses an error found when Flow v0.108 was deployed. To\n       * see the error, delete this comment and run Flow. */\n      /* $FlowFixMe[incompatible-type-arg] (>=0.108.0 site=react_native_fb)\n       * This comment suppresses an error found when Flow v0.108 was deployed.\n       * To see the error, delete this comment and run Flow. */\n      return React.createElement(ListItemComponent, {\n        item,\n        index,\n        separators: this._separators,\n      });\n    }\n\n    if (renderItem) {\n      return renderItem({\n        item,\n        index,\n        separators: this._separators,\n      });\n    }\n\n    invariant(\n      false,\n      'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.',\n    );\n  }\n\n  render(): React.Node {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListItemComponent,\n      cellKey,\n      horizontal,\n      item,\n      index,\n      inversionStyle,\n      onCellFocusCapture,\n      onCellLayout,\n      renderItem,\n    } = this.props;\n    const element = this._renderElement(\n      renderItem,\n      ListItemComponent,\n      item,\n      index,\n    );\n\n    // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and\n    // called explicitly by `ScrollViewStickyHeader`.\n    const itemSeparator: React.Node = React.isValidElement(\n      ItemSeparatorComponent,\n    )\n      ? // $FlowFixMe[incompatible-type]\n        ItemSeparatorComponent\n      : // $FlowFixMe[incompatible-type]\n        ItemSeparatorComponent && (\n          <ItemSeparatorComponent {...this.state.separatorProps} />\n        );\n    const cellStyle = inversionStyle\n      ? horizontal\n        ? [styles.rowReverse, inversionStyle]\n        : [styles.columnReverse, inversionStyle]\n      : horizontal\n      ? [styles.row, inversionStyle]\n      : inversionStyle;\n    const result = !CellRendererComponent ? (\n      <View\n        style={cellStyle}\n        onFocusCapture={onCellFocusCapture}\n        {...(onCellLayout && {onLayout: this._onLayout})}>\n        {element}\n        {itemSeparator}\n      </View>\n    ) : (\n      <CellRendererComponent\n        cellKey={cellKey}\n        index={index}\n        item={item}\n        style={cellStyle}\n        onFocusCapture={onCellFocusCapture}\n        {...(onCellLayout && {onLayout: this._onLayout})}>\n        {element}\n        {itemSeparator}\n      </CellRendererComponent>\n    );\n\n    return (\n      <VirtualizedListCellContextProvider cellKey={this.props.cellKey}>\n        {result}\n      </VirtualizedListCellContextProvider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n  },\n  rowReverse: {\n    flexDirection: 'row-reverse',\n  },\n  columnReverse: {\n    flexDirection: 'column-reverse',\n  },\n});\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport typeof VirtualizedList from './VirtualizedList';\n\nimport * as React from 'react';\nimport {useContext, useMemo} from 'react';\n\ntype Context = $ReadOnly<{\n  cellKey: ?string,\n  getScrollMetrics: () => {\n    contentLength: number,\n    dOffset: number,\n    dt: number,\n    offset: number,\n    timestamp: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n  },\n  horizontal: ?boolean,\n  getOutermostParentListRef: () => React.ElementRef<VirtualizedList>,\n  registerAsNestedChild: ({\n    cellKey: string,\n    ref: React.ElementRef<VirtualizedList>,\n  }) => void,\n  unregisterAsNestedChild: ({ref: React.ElementRef<VirtualizedList>}) => void,\n}>;\n\nexport const VirtualizedListContext: React.Context<?Context> =\n  React.createContext(null);\nif (__DEV__) {\n  VirtualizedListContext.displayName = 'VirtualizedListContext';\n}\n\n/**\n * Resets the context. Intended for use by portal-like components (e.g. Modal).\n */\nexport function VirtualizedListContextResetter({\n  children,\n}: {\n  children: React.Node,\n}): React.Node {\n  return (\n    <VirtualizedListContext.Provider value={null}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n\n/**\n * Sets the context with memoization. Intended to be used by `VirtualizedList`.\n */\nexport function VirtualizedListContextProvider({\n  children,\n  value,\n}: {\n  children: React.Node,\n  value: Context,\n}): React.Node {\n  // Avoid setting a newly created context object if the values are identical.\n  const context = useMemo(\n    () => ({\n      cellKey: null,\n      getScrollMetrics: value.getScrollMetrics,\n      horizontal: value.horizontal,\n      getOutermostParentListRef: value.getOutermostParentListRef,\n      registerAsNestedChild: value.registerAsNestedChild,\n      unregisterAsNestedChild: value.unregisterAsNestedChild,\n    }),\n    [\n      value.getScrollMetrics,\n      value.horizontal,\n      value.getOutermostParentListRef,\n      value.registerAsNestedChild,\n      value.unregisterAsNestedChild,\n    ],\n  );\n  return (\n    <VirtualizedListContext.Provider value={context}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n\n/**\n * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.\n */\nexport function VirtualizedListCellContextProvider({\n  cellKey,\n  children,\n}: {\n  cellKey: string,\n  children: React.Node,\n}): React.Node {\n  // Avoid setting a newly created context object if the values are identical.\n  const currContext = useContext(VirtualizedListContext);\n  const context = useMemo(\n    () => (currContext == null ? null : {...currContext, cellKey}),\n    [currContext, cellKey],\n  );\n  return (\n    <VirtualizedListContext.Provider value={context}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport {typeof ScrollView} from 'react-native';\nimport type {\n  FocusEvent,\n  LayoutEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  ViewabilityConfig,\n  ViewabilityConfigCallbackPair,\n  ViewToken,\n} from './ViewabilityHelper';\n\nimport * as React from 'react';\n\nexport type Item = any;\n\nexport type Separators = {\n  highlight: () => void,\n  unhighlight: () => void,\n  updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n  ...\n};\n\nexport type RenderItemProps<ItemT> = {\n  item: ItemT,\n  index: number,\n  separators: Separators,\n  ...\n};\n\nexport type CellRendererProps<ItemT> = $ReadOnly<{\n  cellKey: string,\n  children: React.Node,\n  index: number,\n  item: ItemT,\n  onFocusCapture?: (event: FocusEvent) => void,\n  onLayout?: (event: LayoutEvent) => void,\n  style: ViewStyleProp,\n}>;\n\nexport type RenderItemType<ItemT> = (\n  info: RenderItemProps<ItemT>,\n) => React.Node;\n\ntype RequiredProps = {|\n  /**\n   * The default accessor functions assume this is an Array<{key: string} | {id: string}> but you can override\n   * getItem, getItemCount, and keyExtractor to handle any type of index-based data.\n   */\n  data?: any,\n  /**\n   * A generic accessor for extracting an item from any sort of data blob.\n   */\n  getItem: (data: any, index: number) => ?Item,\n  /**\n   * Determines how many items are in the data blob.\n   */\n  getItemCount: (data: any) => number,\n|};\ntype OptionalProps = {|\n  renderItem?: ?RenderItemType<Item>,\n  /**\n   * `debug` will turn on extra logging and visual overlays to aid with debugging both usage and\n   * implementation, but with a significant perf hit.\n   */\n  debug?: ?boolean,\n  /**\n   * DEPRECATED: Virtualization provides significant performance and memory optimizations, but fully\n   * unmounts react instances that are outside of the render window. You should only need to disable\n   * this for debugging purposes. Defaults to false.\n   */\n  disableVirtualization?: ?boolean,\n  /**\n   * A marker property for telling the list to re-render (since it implements `PureComponent`). If\n   * any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the\n   * `data` prop, stick it here and treat it immutably.\n   */\n  extraData?: any,\n  // e.g. height, y\n  getItemLayout?: (\n    data: any,\n    index: number,\n  ) => {\n    length: number,\n    offset: number,\n    index: number,\n    ...\n  },\n  horizontal?: ?boolean,\n  /**\n   * How many items to render in the initial batch. This should be enough to fill the screen but not\n   * much more. Note these items will never be unmounted as part of the windowed rendering in order\n   * to improve perceived performance of scroll-to-top actions.\n   */\n  initialNumToRender?: ?number,\n  /**\n   * Instead of starting at the top with the first item, start at `initialScrollIndex`. This\n   * disables the \"scroll to top\" optimization that keeps the first `initialNumToRender` items\n   * always rendered and immediately renders the items starting at this initial index. Requires\n   * `getItemLayout` to be implemented.\n   */\n  initialScrollIndex?: ?number,\n  /**\n   * Reverses the direction of scroll. Uses scale transforms of -1.\n   */\n  inverted?: ?boolean,\n  keyExtractor?: ?(item: Item, index: number) => string,\n  /**\n   * CellRendererComponent allows customizing how cells rendered by\n   * `renderItem`/`ListItemComponent` are wrapped when placed into the\n   * underlying ScrollView. This component must accept event handlers which\n   * notify VirtualizedList of changes within the cell.\n   */\n  CellRendererComponent?: ?React.ComponentType<CellRendererProps<Item>>,\n  /**\n   * Rendered in between each item, but not at the top or bottom. By default, `highlighted` and\n   * `leadingItem` props are provided. `renderItem` provides `separators.highlight`/`unhighlight`\n   * which will update the `highlighted` prop, but you can also add custom props with\n   * `separators.updateProps`.\n   */\n  ItemSeparatorComponent?: ?React.ComponentType<any>,\n  /**\n   * Takes an item from `data` and renders it into the list. Example usage:\n   *\n   *     <FlatList\n   *       ItemSeparatorComponent={Platform.OS !== 'android' && ({highlighted}) => (\n   *         <View style={[style.separator, highlighted && {marginLeft: 0}]} />\n   *       )}\n   *       data={[{title: 'Title Text', key: 'item1'}]}\n   *       ListItemComponent={({item, separators}) => (\n   *         <TouchableHighlight\n   *           onPress={() => this._onPress(item)}\n   *           onShowUnderlay={separators.highlight}\n   *           onHideUnderlay={separators.unhighlight}>\n   *           <View style={{backgroundColor: 'white'}}>\n   *             <Text>{item.title}</Text>\n   *           </View>\n   *         </TouchableHighlight>\n   *       )}\n   *     />\n   *\n   * Provides additional metadata like `index` if you need it, as well as a more generic\n   * `separators.updateProps` function which let's you set whatever props you want to change the\n   * rendering of either the leading separator or trailing separator in case the more common\n   * `highlight` and `unhighlight` (which set the `highlighted: boolean` prop) are insufficient for\n   * your use-case.\n   */\n  ListItemComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Rendered when the list is empty. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListEmptyComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Rendered at the bottom of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListFooterComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Styling for internal View for ListFooterComponent\n   */\n  ListFooterComponentStyle?: ViewStyleProp,\n  /**\n   * Rendered at the top of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListHeaderComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Styling for internal View for ListHeaderComponent\n   */\n  ListHeaderComponentStyle?: ViewStyleProp,\n  /**\n   * The maximum number of items to render in each incremental render batch. The more rendered at\n   * once, the better the fill rate, but responsiveness may suffer because rendering content may\n   * interfere with responding to button taps or other interactions.\n   */\n  maxToRenderPerBatch?: ?number,\n  /**\n   * Called once when the scroll position gets within within `onEndReachedThreshold`\n   * from the logical end of the list.\n   */\n  onEndReached?: ?(info: {distanceFromEnd: number, ...}) => void,\n  /**\n   * How far from the end (in units of visible length of the list) the trailing edge of the\n   * list must be from the end of the content to trigger the `onEndReached` callback.\n   * Thus, a value of 0.5 will trigger `onEndReached` when the end of the content is\n   * within half the visible length of the list.\n   */\n  onEndReachedThreshold?: ?number,\n  /**\n   * If provided, a standard RefreshControl will be added for \"Pull to Refresh\" functionality. Make\n   * sure to also set the `refreshing` prop correctly.\n   */\n  onRefresh?: ?() => void,\n  /**\n   * Used to handle failures when scrolling to an index that has not been measured yet. Recommended\n   * action is to either compute your own offset and `scrollTo` it, or scroll as far as possible and\n   * then try again after more items have been rendered.\n   */\n  onScrollToIndexFailed?: ?(info: {\n    index: number,\n    highestMeasuredFrameIndex: number,\n    averageItemLength: number,\n    ...\n  }) => void,\n  /**\n   * Called once when the scroll position gets within within `onStartReachedThreshold`\n   * from the logical start of the list.\n   */\n  onStartReached?: ?(info: {distanceFromStart: number, ...}) => void,\n  /**\n   * How far from the start (in units of visible length of the list) the leading edge of the\n   * list must be from the start of the content to trigger the `onStartReached` callback.\n   * Thus, a value of 0.5 will trigger `onStartReached` when the start of the content is\n   * within half the visible length of the list.\n   */\n  onStartReachedThreshold?: ?number,\n  /**\n   * Called when the viewability of rows changes, as defined by the\n   * `viewabilityConfig` prop.\n   */\n  onViewableItemsChanged?: ?(info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  persistentScrollbar?: ?boolean,\n  /**\n   * Set this when offset is needed for the loading indicator to show correctly.\n   */\n  progressViewOffset?: number,\n  /**\n   * A custom refresh control element. When set, it overrides the default\n   * <RefreshControl> component built internally. The onRefresh and refreshing\n   * props are also ignored. Only works for vertical VirtualizedList.\n   */\n  refreshControl?: ?React.Element<any>,\n  /**\n   * Set this true while waiting for new data from a refresh.\n   */\n  refreshing?: ?boolean,\n  /**\n   * Note: may have bugs (missing content) in some circumstances - use at your own risk.\n   *\n   * This may improve scroll performance for large lists.\n   */\n  removeClippedSubviews?: boolean,\n  /**\n   * Render a custom scroll component, e.g. with a differently styled `RefreshControl`.\n   */\n  renderScrollComponent?: (props: Object) => React.Element<any>,\n  /**\n   * Amount of time between low-pri item render batches, e.g. for rendering items quite a ways off\n   * screen. Similar fill rate/responsiveness tradeoff as `maxToRenderPerBatch`.\n   */\n  updateCellsBatchingPeriod?: ?number,\n  /**\n   * See `ViewabilityHelper` for flow type and further documentation.\n   */\n  viewabilityConfig?: ViewabilityConfig,\n  /**\n   * List of ViewabilityConfig/onViewableItemsChanged pairs. A specific onViewableItemsChanged\n   * will be called when its corresponding ViewabilityConfig's conditions are met.\n   */\n  viewabilityConfigCallbackPairs?: Array<ViewabilityConfigCallbackPair>,\n  /**\n   * Determines the maximum number of items rendered outside of the visible area, in units of\n   * visible lengths. So if your list fills the screen, then `windowSize={21}` (the default) will\n   * render the visible screen area plus up to 10 screens above and 10 below the viewport. Reducing\n   * this number will reduce memory consumption and may improve performance, but will increase the\n   * chance that fast scrolling may reveal momentary blank areas of unrendered content.\n   */\n  windowSize?: ?number,\n  /**\n   * The legacy implementation is no longer supported.\n   */\n  legacyImplementation?: empty,\n|};\n\nexport type Props = {|\n  ...React.ElementConfig<ScrollView>,\n  ...RequiredProps,\n  ...OptionalProps,\n|};\n\n/**\n * Default Props Helper Functions\n * Use the following helper functions for default values\n */\n\n// horizontalOrDefault(this.props.horizontal)\nexport function horizontalOrDefault(horizontal: ?boolean): boolean {\n  return horizontal ?? false;\n}\n\n// initialNumToRenderOrDefault(this.props.initialNumToRender)\nexport function initialNumToRenderOrDefault(\n  initialNumToRender: ?number,\n): number {\n  return initialNumToRender ?? 10;\n}\n\n// maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)\nexport function maxToRenderPerBatchOrDefault(\n  maxToRenderPerBatch: ?number,\n): number {\n  return maxToRenderPerBatch ?? 10;\n}\n\n// onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)\nexport function onStartReachedThresholdOrDefault(\n  onStartReachedThreshold: ?number,\n): number {\n  return onStartReachedThreshold ?? 2;\n}\n\n// onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)\nexport function onEndReachedThresholdOrDefault(\n  onEndReachedThreshold: ?number,\n): number {\n  return onEndReachedThreshold ?? 2;\n}\n\n// windowSizeOrDefault(this.props.windowSize)\nexport function windowSizeOrDefault(windowSize: ?number): number {\n  return windowSize ?? 21;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {ViewToken} from './ViewabilityHelper';\n\nimport {View} from 'react-native';\nimport VirtualizedList from './VirtualizedList';\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport * as React from 'react';\n\ntype Item = any;\n\nexport type SectionBase<SectionItemT> = {\n  /**\n   * The data for rendering items in this section.\n   */\n  data: $ReadOnlyArray<SectionItemT>,\n  /**\n   * Optional key to keep track of section re-ordering. If you don't plan on re-ordering sections,\n   * the array index will be used by default.\n   */\n  key?: string,\n  // Optional props will override list-wide props just for this section.\n  renderItem?: ?(info: {\n    item: SectionItemT,\n    index: number,\n    section: SectionBase<SectionItemT>,\n    separators: {\n      highlight: () => void,\n      unhighlight: () => void,\n      updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n      ...\n    },\n    ...\n  }) => null | React.Element<any>,\n  ItemSeparatorComponent?: ?React.ComponentType<any>,\n  keyExtractor?: (item: SectionItemT, index?: ?number) => string,\n  ...\n};\n\ntype RequiredProps<SectionT: SectionBase<any>> = {|\n  sections: $ReadOnlyArray<SectionT>,\n|};\n\ntype OptionalProps<SectionT: SectionBase<any>> = {|\n  /**\n   * Default renderer for every item in every section.\n   */\n  renderItem?: (info: {\n    item: Item,\n    index: number,\n    section: SectionT,\n    separators: {\n      highlight: () => void,\n      unhighlight: () => void,\n      updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n      ...\n    },\n    ...\n  }) => null | React.Element<any>,\n  /**\n   * Rendered at the top of each section. These stick to the top of the `ScrollView` by default on\n   * iOS. See `stickySectionHeadersEnabled`.\n   */\n  renderSectionHeader?: ?(info: {\n    section: SectionT,\n    ...\n  }) => null | React.Element<any>,\n  /**\n   * Rendered at the bottom of each section.\n   */\n  renderSectionFooter?: ?(info: {\n    section: SectionT,\n    ...\n  }) => null | React.Element<any>,\n  /**\n   * Rendered at the top and bottom of each section (note this is different from\n   * `ItemSeparatorComponent` which is only rendered between items). These are intended to separate\n   * sections from the headers above and below and typically have the same highlight response as\n   * `ItemSeparatorComponent`. Also receives `highlighted`, `[leading/trailing][Item/Separator]`,\n   * and any custom props from `separators.updateProps`.\n   */\n  SectionSeparatorComponent?: ?React.ComponentType<any>,\n  /**\n   * Makes section headers stick to the top of the screen until the next one pushes it off. Only\n   * enabled by default on iOS because that is the platform standard there.\n   */\n  stickySectionHeadersEnabled?: boolean,\n  onEndReached?: ?({distanceFromEnd: number, ...}) => void,\n|};\n\ntype VirtualizedListProps = React.ElementConfig<typeof VirtualizedList>;\n\nexport type Props<SectionT> = {|\n  ...RequiredProps<SectionT>,\n  ...OptionalProps<SectionT>,\n  ...$Diff<\n    VirtualizedListProps,\n    {\n      renderItem: $PropertyType<VirtualizedListProps, 'renderItem'>,\n      data: $PropertyType<VirtualizedListProps, 'data'>,\n      ...\n    },\n  >,\n|};\nexport type ScrollToLocationParamsType = {|\n  animated?: ?boolean,\n  itemIndex: number,\n  sectionIndex: number,\n  viewOffset?: number,\n  viewPosition?: number,\n|};\n\ntype State = {childProps: VirtualizedListProps, ...};\n\n/**\n * Right now this just flattens everything into one list and uses VirtualizedList under the\n * hood. The only operation that might not scale well is concatting the data arrays of all the\n * sections when new props are received, which should be plenty fast for up to ~10,000 items.\n */\nclass VirtualizedSectionList<\n  SectionT: SectionBase<any>,\n> extends React.PureComponent<Props<SectionT>, State> {\n  scrollToLocation(params: ScrollToLocationParamsType) {\n    let index = params.itemIndex;\n    for (let i = 0; i < params.sectionIndex; i++) {\n      index += this.props.getItemCount(this.props.sections[i].data) + 2;\n    }\n    let viewOffset = params.viewOffset || 0;\n    if (this._listRef == null) {\n      return;\n    }\n    const listRef = this._listRef;\n    if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {\n      const frame = listRef\n        .__getListMetrics()\n        .getCellMetricsApprox(index - params.itemIndex, listRef.props);\n      viewOffset += frame.length;\n    }\n    const toIndexParams = {\n      ...params,\n      viewOffset,\n      index,\n    };\n    // $FlowFixMe[incompatible-use]\n    this._listRef.scrollToIndex(toIndexParams);\n  }\n\n  getListRef(): ?React.ElementRef<typeof VirtualizedList> {\n    return this._listRef;\n  }\n\n  render(): React.Node {\n    const {\n      ItemSeparatorComponent, // don't pass through, rendered with renderItem\n      SectionSeparatorComponent,\n      renderItem: _renderItem,\n      renderSectionFooter,\n      renderSectionHeader,\n      sections: _sections,\n      stickySectionHeadersEnabled,\n      ...passThroughProps\n    } = this.props;\n\n    const listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;\n\n    const stickyHeaderIndices = this.props.stickySectionHeadersEnabled\n      ? ([]: Array<number>)\n      : undefined;\n\n    let itemCount = 0;\n    for (const section of this.props.sections) {\n      // Track the section header indices\n      if (stickyHeaderIndices != null) {\n        stickyHeaderIndices.push(itemCount + listHeaderOffset);\n      }\n\n      // Add two for the section header and footer.\n      itemCount += 2;\n      itemCount += this.props.getItemCount(section.data);\n    }\n    const renderItem = this._renderItem(itemCount);\n\n    return (\n      <VirtualizedList\n        {...passThroughProps}\n        keyExtractor={this._keyExtractor}\n        stickyHeaderIndices={stickyHeaderIndices}\n        renderItem={renderItem}\n        data={this.props.sections}\n        getItem={(sections, index) =>\n          this._getItem(this.props, sections, index)\n        }\n        getItemCount={() => itemCount}\n        onViewableItemsChanged={\n          this.props.onViewableItemsChanged\n            ? this._onViewableItemsChanged\n            : undefined\n        }\n        ref={this._captureRef}\n      />\n    );\n  }\n\n  _getItem(\n    props: Props<SectionT>,\n    sections: ?$ReadOnlyArray<Item>,\n    index: number,\n  ): ?Item {\n    if (!sections) {\n      return null;\n    }\n    let itemIdx = index - 1;\n    for (let i = 0; i < sections.length; i++) {\n      const section = sections[i];\n      const sectionData = section.data;\n      const itemCount = props.getItemCount(sectionData);\n      if (itemIdx === -1 || itemIdx === itemCount) {\n        // We intend for there to be overflow by one on both ends of the list.\n        // This will be for headers and footers. When returning a header or footer\n        // item the section itself is the item.\n        return section;\n      } else if (itemIdx < itemCount) {\n        // If we are in the bounds of the list's data then return the item.\n        return props.getItem(sectionData, itemIdx);\n      } else {\n        itemIdx -= itemCount + 2; // Add two for the header and footer\n      }\n    }\n    return null;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _keyExtractor = (item: Item, index: number) => {\n    const info = this._subExtractor(index);\n    return (info && info.key) || String(index);\n  };\n\n  _subExtractor(index: number): ?{\n    section: SectionT,\n    // Key of the section or combined key for section + item\n    key: string,\n    // Relative index within the section\n    index: ?number,\n    // True if this is the section header\n    header?: ?boolean,\n    leadingItem?: ?Item,\n    leadingSection?: ?SectionT,\n    trailingItem?: ?Item,\n    trailingSection?: ?SectionT,\n    ...\n  } {\n    let itemIndex = index;\n    const {getItem, getItemCount, keyExtractor, sections} = this.props;\n    for (let i = 0; i < sections.length; i++) {\n      const section = sections[i];\n      const sectionData = section.data;\n      const key = section.key || String(i);\n      itemIndex -= 1; // The section adds an item for the header\n      if (itemIndex >= getItemCount(sectionData) + 1) {\n        itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.\n      } else if (itemIndex === -1) {\n        return {\n          section,\n          key: key + ':header',\n          index: null,\n          header: true,\n          trailingSection: sections[i + 1],\n        };\n      } else if (itemIndex === getItemCount(sectionData)) {\n        return {\n          section,\n          key: key + ':footer',\n          index: null,\n          header: false,\n          trailingSection: sections[i + 1],\n        };\n      } else {\n        const extractor =\n          section.keyExtractor || keyExtractor || defaultKeyExtractor;\n        return {\n          section,\n          key:\n            key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),\n          index: itemIndex,\n          leadingItem: getItem(sectionData, itemIndex - 1),\n          leadingSection: sections[i - 1],\n          trailingItem: getItem(sectionData, itemIndex + 1),\n          trailingSection: sections[i + 1],\n        };\n      }\n    }\n  }\n\n  _convertViewable = (viewable: ViewToken): ?ViewToken => {\n    invariant(viewable.index != null, 'Received a broken ViewToken');\n    const info = this._subExtractor(viewable.index);\n    if (!info) {\n      return null;\n    }\n    const keyExtractorWithNullableIndex = info.section.keyExtractor;\n    const keyExtractorWithNonNullableIndex =\n      this.props.keyExtractor || defaultKeyExtractor;\n    const key =\n      keyExtractorWithNullableIndex != null\n        ? keyExtractorWithNullableIndex(viewable.item, info.index)\n        : keyExtractorWithNonNullableIndex(viewable.item, info.index ?? 0);\n\n    return {\n      ...viewable,\n      index: info.index,\n      key,\n      section: info.section,\n    };\n  };\n\n  _onViewableItemsChanged = ({\n    viewableItems,\n    changed,\n  }: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => {\n    const onViewableItemsChanged = this.props.onViewableItemsChanged;\n    if (onViewableItemsChanged != null) {\n      onViewableItemsChanged({\n        viewableItems: viewableItems\n          .map(this._convertViewable, this)\n          .filter(Boolean),\n        changed: changed.map(this._convertViewable, this).filter(Boolean),\n      });\n    }\n  };\n\n  _renderItem =\n    (listItemCount: number): $FlowFixMe =>\n    // eslint-disable-next-line react/no-unstable-nested-components\n    ({item, index}: {item: Item, index: number, ...}) => {\n      const info = this._subExtractor(index);\n      if (!info) {\n        return null;\n      }\n      const infoIndex = info.index;\n      if (infoIndex == null) {\n        const {section} = info;\n        if (info.header === true) {\n          const {renderSectionHeader} = this.props;\n          return renderSectionHeader ? renderSectionHeader({section}) : null;\n        } else {\n          const {renderSectionFooter} = this.props;\n          return renderSectionFooter ? renderSectionFooter({section}) : null;\n        }\n      } else {\n        const renderItem = info.section.renderItem || this.props.renderItem;\n        const SeparatorComponent = this._getSeparatorComponent(\n          index,\n          info,\n          listItemCount,\n        );\n        invariant(renderItem, 'no renderItem!');\n        return (\n          <ItemWithSeparator\n            SeparatorComponent={SeparatorComponent}\n            LeadingSeparatorComponent={\n              infoIndex === 0 ? this.props.SectionSeparatorComponent : undefined\n            }\n            cellKey={info.key}\n            index={infoIndex}\n            item={item}\n            leadingItem={info.leadingItem}\n            leadingSection={info.leadingSection}\n            prevCellKey={(this._subExtractor(index - 1) || {}).key}\n            // Callback to provide updateHighlight for this item\n            setSelfHighlightCallback={this._setUpdateHighlightFor}\n            setSelfUpdatePropsCallback={this._setUpdatePropsFor}\n            // Provide child ability to set highlight/updateProps for previous item using prevCellKey\n            updateHighlightFor={this._updateHighlightFor}\n            updatePropsFor={this._updatePropsFor}\n            renderItem={renderItem}\n            section={info.section}\n            trailingItem={info.trailingItem}\n            trailingSection={info.trailingSection}\n            inverted={!!this.props.inverted}\n          />\n        );\n      }\n    };\n\n  _updatePropsFor = (cellKey: string, value: any) => {\n    const updateProps = this._updatePropsMap[cellKey];\n    if (updateProps != null) {\n      updateProps(value);\n    }\n  };\n\n  _updateHighlightFor = (cellKey: string, value: boolean) => {\n    const updateHighlight = this._updateHighlightMap[cellKey];\n    if (updateHighlight != null) {\n      updateHighlight(value);\n    }\n  };\n\n  _setUpdateHighlightFor = (\n    cellKey: string,\n    updateHighlightFn: ?(boolean) => void,\n  ) => {\n    if (updateHighlightFn != null) {\n      this._updateHighlightMap[cellKey] = updateHighlightFn;\n    } else {\n      // $FlowFixMe[prop-missing]\n      delete this._updateHighlightFor[cellKey];\n    }\n  };\n\n  _setUpdatePropsFor = (cellKey: string, updatePropsFn: ?(boolean) => void) => {\n    if (updatePropsFn != null) {\n      this._updatePropsMap[cellKey] = updatePropsFn;\n    } else {\n      delete this._updatePropsMap[cellKey];\n    }\n  };\n\n  _getSeparatorComponent(\n    index: number,\n    info?: ?Object,\n    listItemCount: number,\n  ): ?React.ComponentType<any> {\n    info = info || this._subExtractor(index);\n    if (!info) {\n      return null;\n    }\n    const ItemSeparatorComponent =\n      info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;\n    const {SectionSeparatorComponent} = this.props;\n    const isLastItemInList = index === listItemCount - 1;\n    const isLastItemInSection =\n      info.index === this.props.getItemCount(info.section.data) - 1;\n    if (SectionSeparatorComponent && isLastItemInSection) {\n      return SectionSeparatorComponent;\n    }\n    if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {\n      return ItemSeparatorComponent;\n    }\n    return null;\n  }\n\n  _updateHighlightMap: {[string]: (boolean) => void} = {};\n  _updatePropsMap: {[string]: void | (boolean => void)} = {};\n  _listRef: ?React.ElementRef<typeof VirtualizedList>;\n  _captureRef = (ref: null | React$ElementRef<Class<VirtualizedList>>) => {\n    this._listRef = ref;\n  };\n}\n\ntype ItemWithSeparatorCommonProps = $ReadOnly<{|\n  leadingItem: ?Item,\n  leadingSection: ?Object,\n  section: Object,\n  trailingItem: ?Item,\n  trailingSection: ?Object,\n|}>;\n\ntype ItemWithSeparatorProps = $ReadOnly<{|\n  ...ItemWithSeparatorCommonProps,\n  LeadingSeparatorComponent: ?React.ComponentType<any>,\n  SeparatorComponent: ?React.ComponentType<any>,\n  cellKey: string,\n  index: number,\n  item: Item,\n  setSelfHighlightCallback: (\n    cellKey: string,\n    updateFn: ?(boolean) => void,\n  ) => void,\n  setSelfUpdatePropsCallback: (\n    cellKey: string,\n    updateFn: ?(boolean) => void,\n  ) => void,\n  prevCellKey?: ?string,\n  updateHighlightFor: (prevCellKey: string, value: boolean) => void,\n  updatePropsFor: (prevCellKey: string, value: Object) => void,\n  renderItem: Function,\n  inverted: boolean,\n|}>;\n\nfunction ItemWithSeparator(props: ItemWithSeparatorProps): React.Node {\n  const {\n    LeadingSeparatorComponent,\n    // this is the trailing separator and is associated with this item\n    SeparatorComponent,\n    cellKey,\n    prevCellKey,\n    setSelfHighlightCallback,\n    updateHighlightFor,\n    setSelfUpdatePropsCallback,\n    updatePropsFor,\n    item,\n    index,\n    section,\n    inverted,\n  } = props;\n\n  const [leadingSeparatorHiglighted, setLeadingSeparatorHighlighted] =\n    React.useState(false);\n\n  const [separatorHighlighted, setSeparatorHighlighted] = React.useState(false);\n\n  const [leadingSeparatorProps, setLeadingSeparatorProps] = React.useState({\n    leadingItem: props.leadingItem,\n    leadingSection: props.leadingSection,\n    section: props.section,\n    trailingItem: props.item,\n    trailingSection: props.trailingSection,\n  });\n  const [separatorProps, setSeparatorProps] = React.useState({\n    leadingItem: props.item,\n    leadingSection: props.leadingSection,\n    section: props.section,\n    trailingItem: props.trailingItem,\n    trailingSection: props.trailingSection,\n  });\n\n  React.useEffect(() => {\n    setSelfHighlightCallback(cellKey, setSeparatorHighlighted);\n    // $FlowFixMe[incompatible-call]\n    setSelfUpdatePropsCallback(cellKey, setSeparatorProps);\n\n    return () => {\n      setSelfUpdatePropsCallback(cellKey, null);\n      setSelfHighlightCallback(cellKey, null);\n    };\n  }, [\n    cellKey,\n    setSelfHighlightCallback,\n    setSeparatorProps,\n    setSelfUpdatePropsCallback,\n  ]);\n\n  const separators = {\n    highlight: () => {\n      setLeadingSeparatorHighlighted(true);\n      setSeparatorHighlighted(true);\n      if (prevCellKey != null) {\n        updateHighlightFor(prevCellKey, true);\n      }\n    },\n    unhighlight: () => {\n      setLeadingSeparatorHighlighted(false);\n      setSeparatorHighlighted(false);\n      if (prevCellKey != null) {\n        updateHighlightFor(prevCellKey, false);\n      }\n    },\n    updateProps: (\n      select: 'leading' | 'trailing',\n      newProps: Partial<ItemWithSeparatorCommonProps>,\n    ) => {\n      if (select === 'leading') {\n        if (LeadingSeparatorComponent != null) {\n          setLeadingSeparatorProps({...leadingSeparatorProps, ...newProps});\n        } else if (prevCellKey != null) {\n          // update the previous item's separator\n          updatePropsFor(prevCellKey, {...leadingSeparatorProps, ...newProps});\n        }\n      } else if (select === 'trailing' && SeparatorComponent != null) {\n        setSeparatorProps({...separatorProps, ...newProps});\n      }\n    },\n  };\n  const element = props.renderItem({\n    item,\n    index,\n    section,\n    separators,\n  });\n  const leadingSeparator = LeadingSeparatorComponent != null && (\n    <LeadingSeparatorComponent\n      highlighted={leadingSeparatorHiglighted}\n      {...leadingSeparatorProps}\n    />\n  );\n  const separator = SeparatorComponent != null && (\n    <SeparatorComponent\n      highlighted={separatorHighlighted}\n      {...separatorProps}\n    />\n  );\n  return leadingSeparator || separator ? (\n    <View>\n      {inverted === false ? leadingSeparator : separator}\n      {element}\n      {inverted === false ? separator : leadingSeparator}\n    </View>\n  ) : (\n    element\n  );\n}\n\n/* $FlowFixMe[class-object-subtyping] added when improving typing for this\n * parameters */\n// $FlowFixMe[method-unbinding]\nmodule.exports = (VirtualizedSectionList: React.AbstractComponent<\n  React.ElementConfig<typeof VirtualizedSectionList>,\n  $ReadOnly<{\n    getListRef: () => ?React.ElementRef<typeof VirtualizedList>,\n    scrollToLocation: (params: ScrollToLocationParamsType) => void,\n    ...\n  }>,\n>);\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\n'use strict';\n\nfunction clamp(min: number, value: number, max: number): number {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nmodule.exports = clamp;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\n'use strict';\n\n/**\n * Intentional info-level logging for clear separation from ad-hoc console debug logging.\n */\nfunction infoLog(...args: Array<mixed>): void {\n  return console.log(...args);\n}\n\nmodule.exports = infoLog;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport {keyExtractor} from './Lists/VirtualizeUtils';\n\nimport typeof VirtualizedList from './Lists/VirtualizedList';\nimport typeof VirtualizedSectionList from './Lists/VirtualizedSectionList';\nimport {typeof VirtualizedListContextResetter} from './Lists/VirtualizedListContext';\nimport typeof ViewabilityHelper from './Lists/ViewabilityHelper';\nimport typeof FillRateHelper from './Lists/FillRateHelper';\n\nexport type {\n  ViewToken,\n  ViewabilityConfig,\n  ViewabilityConfigCallbackPair,\n} from './Lists/ViewabilityHelper';\nexport type {\n  CellRendererProps,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './Lists/VirtualizedListProps';\nexport type {\n  Props as VirtualizedSectionListProps,\n  ScrollToLocationParamsType,\n  SectionBase,\n} from './Lists/VirtualizedSectionList';\nexport type {FillRateInfo} from './Lists/FillRateHelper';\n\nmodule.exports = {\n  keyExtractor,\n\n  get VirtualizedList(): VirtualizedList {\n    return require('./Lists/VirtualizedList');\n  },\n  get VirtualizedSectionList(): VirtualizedSectionList {\n    return require('./Lists/VirtualizedSectionList');\n  },\n  get VirtualizedListContextResetter(): VirtualizedListContextResetter {\n    const VirtualizedListContext = require('./Lists/VirtualizedListContext');\n    return VirtualizedListContext.VirtualizedListContextResetter;\n  },\n  get ViewabilityHelper(): ViewabilityHelper {\n    return require('./Lists/ViewabilityHelper');\n  },\n  get FillRateHelper(): FillRateHelper {\n    return require('./Lists/FillRateHelper');\n  },\n};\n"],"names":["_interopRequireDefault","require","_classCallCheck2","_createClass2","InteractionManager","Batchinator","callback","delayMS","default","this","_delay","_callback","key","value","options","arguments","length","undefined","abort","_taskHandle","cancel","_this","timeoutHandle","setTimeout","runAfterInteractions","clearTimeout","module","exports","_invariant","CellRenderMask","numCells","invariant","_numCells","_regions","first","last","isSpacer","cells","_this$_regions","_this$_findRegion","_findRegion","_this$_findRegion2","_slicedToArray2","firstIntersect","firstIntersectIdx","_this$_findRegion3","_this$_findRegion4","lastIntersect","lastIntersectIdx","newLeadRegion","newTailRegion","newMainRegion","Object","assign","push","replacementRegions","concat","numRegionsToDelete","splice","apply","_toConsumableArray2","other","every","region","i","cellIdx","firstIdx","lastIdx","middleIdx","Math","floor","middleRegion","ChildListCollection","_cellKeyToChildren","Map","_childrenToCellKey","list","cellKey","_this$_cellKeyToChild","has","cellLists","get","Set","add","set","delete","size","fn","listSet","values","_this$_cellKeyToChild2","_this$_cellKeyToChild3","Info","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","_listeners","_minSampleCount","_sampleRate","FillRateHelper","listMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_listMetrics","random","_resetData","global","performance","now","start","info","forEach","listener","props","cellsAroundViewport","scrollMetrics","getItemCount","data","dOffset","offset","velocity","visibleLength","round","abs","scrollSpeed","blankTop","firstFrame","getCellMetrics","isMounted","min","max","blankBottom","lastFrame","bottomEdge","blankness","deactivateAndFlush","console","warn","remove","filter","sampleRate","minSampleCount","_VirtualizeUtils","ListMetricsAggregator","_averageCellLength","_cellMetrics","_highestMeasuredCellIndex","_measuredCellsLength","_measuredCellsCount","_orientation","horizontal","rtl","_ref","cellIndex","orientation","layout","_invalidateIfOrientationChanged","next","index","_selectLength","flowRelativeOffset","curr","dLength","_ref2","_contentLength","frame","_props$keyExtractor","getItem","getItemLayout","keyExtractor","defaultKeyExtractor","_getItemLayout","Number","isInteger","getCellMetricsApprox","frameMetrics","remainder","_this$_contentLength","referenceContentLength","_this$_orientation","contentLength","_selectOffset","_this$_orientation2","clear","_ref3","width","height","_ref4","x","y","React","e","r","__esModule","t","_getRequireWildcardCache","n","__proto__","a","defineProperty","getOwnPropertyDescriptor","u","prototype","hasOwnProperty","call","_interopRequireWildcard","WeakMap","_callSuper","o","_getPrototypeOf2","_possibleConstructorReturn2","_isNativeReflectConstruct","Reflect","construct","constructor","Boolean","valueOf","_React$PureComponent","StateSafePureComponent","_inAsyncStateUpdate","_installSetStateHooks","_inherits2","partialState","_this2","_get2","state","ret","err","that","newProps","newState","PureComponent","ViewabilityHelper","config","viewAreaCoveragePercentThreshold","_hasInteracted","_timers","_viewableIndices","_viewableItems","_config","scrollOffset","viewportHeight","renderRange","itemCount","_this$_config","itemVisiblePercentThreshold","viewAreaMode","viewablePercentThreshold","viewableIndices","firstVisible","JSON","stringify","idx","metrics","top","bottom","_isViewable","createViewToken","onViewableItemsChanged","waitForInteraction","computeViewableItems","v","ii","minimumViewTime","handle","_onUpdateSync","viewableIndicesToCheck","includes","prevItems","nextItems","map","viewable","changed","_ref5","isViewable","viewableItems","Array","from","viewabilityConfig","itemLength","_isEntirelyVisible","pixels","visibleHeight","_getPixelsVisible","maxToRenderPerBatch","windowSize","prev","_scrollMetrics$zoomSc","zoomScale","visibleBegin","visibleEnd","overscanLength","fillPreference","overscanBegin","overscanEnd","_elementsThatOverlapO","elementsThatOverlapOffsets","_elementsThatOverlapO2","overscanFirst","overscanLast","visible","newCellCount","newRangeCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","item","id","String","offsets","result","offsetIndex","currentOffset","left","right","mid","scaledOffsetStart","scaledOffsetEnd","_reactNative","_Batchinator","_clamp","_infoLog","_CellRenderMask","_ChildListCollection","_FillRateHelper","_ListMetricsAggregator","_StateSafePureComponent","_ViewabilityHelper","_VirtualizedListCellRenderer","_VirtualizedListContext","_nullthrows","_VirtualizedListProps","_jsxRuntime","_usedIndexForKey","_keylessItemComponentName","getScrollingThreshold","threshold","VirtualizedList","_StateSafePureCompone","_this$props$updateCel","_this$props$maintainV","_this$props$maintainV2","_getScrollMetrics","_scrollMetrics","_getOutermostParentListRef","_isNestedWithSameOrientation","context","getOutermostParentListRef","_assertThisInitialized2","_registerAsNestedChild","childList","_nestedChildLists","ref","recordInteraction","_unregisterAsNestedChild","_onUpdateSeparators","keys","_cellRefs","updateSeparatorProps","_getSpacerKey","isVertical","_footerLength","_hasTriggeredInitialScrollToIndex","_hasMore","_hasWarned","_headerLength","_hiPriInProgress","_indicesToKeys","_lastFocusedCellKey","_offsetFromParentVirtualizedList","_pendingViewabilityUpdate","_prevParentOffset","dt","timestamp","_scrollRef","_sentStartForContentLength","_sentEndForContentLength","_viewabilityTuples","_captureScrollRef","_defaultRenderScrollComponent","_props$refreshing","onRefresh","jsx","View","refreshing","ScrollView","refreshControl","RefreshControl","progressViewOffset","_onCellLayout","notifyCellLayout","nativeEvent","_scheduleCellsToRenderUpdate","_triggerRemeasureForChildListsInCell","_computeBlankness","_updateViewableItems","_onCellUnmount","notifyCellUnmounted","_onLayout","measureLayoutRelativeToContainingList","onLayout","_maybeCallOnEdgeReached","_onLayoutEmpty","_onLayoutFooter","_getFooterCellKey","_onLayoutHeader","_onContentSizeChange","notifyListContentLayout","_maybeScrollToInitialScrollIndex","onContentSizeChange","_convertParentScrollMetrics","getContentLength","_onScroll","onScroll","timeStamp","layoutMeasurement","contentSize","_offsetFromScrollEvent","_this$_convertParentS","perf","infoLog","prevDt","pendingScrollUpdateCount","setState","_fillRateHelper","activate","_onScrollBeginDrag","tuple","viewabilityHelper","onScrollBeginDrag","_onScrollEndDrag","onScrollEndDrag","_onMomentumScrollBegin","onMomentumScrollBegin","_onMomentumScrollEnd","onMomentumScrollEnd","_updateCellsToRender","_adjustCellsAroundViewport","renderMask","_createRenderMask","_getNonViewportRenderRegions","equals","_createViewToken","_keyExtractor","focusedCellIndex","_getItemKey","heightOfCellsBeforeFocused","heightOfCellsAfterFocused","_checkProps","_updateCellsToRenderBatcher","updateCellsBatchingPeriod","viewabilityConfigCallbackPairs","pair","_this$props","initialRenderRegion","_initialRenderRegion","minIndexForVisible","maintainVisibleContentPosition","firstVisibleItemKey","initialScrollIndex","params","animated","veryLast","scrollToOffset","_this$props2","onScrollToIndexFailed","viewOffset","viewPosition","getHighestMeasuredCellIndex","averageItemLength","getAverageCellLength","highestMeasuredFrameIndex","getCellOffsetApprox","_this$props3","scrollToIndex","scrollRef","scrollTo","hasContentLength","_scrollToParamsFromOffset","cartOffset","cartesianOffset","flashScrollIndicators","getScrollResponder","getScrollableNode","findNodeHandle","getScrollRef","setNativeProps","_this$context","__isNative","windowSizeOrDefault","newCellsAroundViewport","onEndReachedThreshold","onEndReachedThresholdOrDefault","_this$_scrollMetrics","distanceFromEnd","_constrainToItemCount","disableVirtualization","renderAhead","maxToRenderPerBatchOrDefault","computeWindowedRenderLimits","childIdx","_findFirstChildWithMore","cellKeyForIndex","anyInCell","hasMore","registerAsNestedChild","unregisterAsNestedChild","dispose","stickyHeaderIndices","stickyIndicesFromProps","inversionStyle","prevCellKey","_this$props4","CellRendererComponent","ItemSeparatorComponent","ListHeaderComponent","ListItemComponent","debug","renderItem","stickyOffset","end","_loop","shouldListenForLayout","enabled","onUpdateSeparators","onCellFocusCapture","_onCellFocusCapture","onUnmount","onCellLayout","nestedContext","horizontalOrDefault","_this$props$scrollEve","_this3","_this$props5","ListEmptyComponent","ListFooterComponent","_this$props6","inverted","styles","horizontallyInverted","verticallyInverted","element","isValidElement","VirtualizedListCellContextProvider","_getCellKey","children","collapsable","style","StyleSheet","compose","ListHeaderComponentStyle","cloneElement","event","spacerKey","renderRegions","enumerateRegions","lastRegion","lastSpacer","section","clamp","firstMetrics","lastMetrics","spacerSize","_defineProperty2","_pushCells","ListFooterComponentStyle","scrollProps","scrollEventThrottle","invertStickyHeaders","isInvertedVirtualizedList","VirtualizedListContextProvider","getScrollMetrics","renderScrollComponent","jsxs","_renderDebugOverlay","prevProps","_this$props7","extraData","resetViewableIndices","hiPriInProgress","computeBlankness","forEachInCell","_this4","measureLayout","error","stack","normalize","framesInLayout","windowTop","frameLast","windowLen","visTop","visLen","debugOverlayBase","debugOverlay","f","debugOverlayFrame","debugOverlayFrameLast","debugOverlayFrameVis","I18nManager","isRTL","_this$props8","onStartReached","onStartReachedThreshold","onEndReached","_this$_scrollMetrics2","distanceFromStart","isWithinStartThreshold","isWithinEndThreshold","contentWidth","contentHeight","contentOffset","nullthrows","scrollToEnd","_e$nativeEvent","_this$_orientation3","_shouldRenderWithPriority","schedule","_this$state$cellsArou","_this$_scrollMetrics3","hiPri","onStartReachedThresholdOrDefault","distTop","distBottom","_this5","onUpdate","hint","additionalRegions","allRegions","addCells","initialRegion","stickyIndicesSet","_ensureClosestStickyHeader","_props$initialScrollI","firstCellIndex","initialNumToRenderOrDefault","initialNumToRender","itemIdx","prevState","_newProps$maintainVis","_newProps$maintainVis2","maintainVisibleContentPositionAdjustment","prevFirstVisibleItemKey","newFirstVisibleItemKey","firstVisibleItemIndex","_findItemIndexWithKey","constrainedCells","lastPossibleCellIndex","maxFirst","type","displayName","contextType","VirtualizedListContext","create","Platform","OS","transform","scale","scaleY","scaleX","flex","position","borderColor","borderWidth","backgroundColor","_React$Component","CellRenderer","_len","args","_key","separatorProps","highlighted","leadingItem","_separators","highlight","unhighlight","updateProps","select","createElement","separators","_renderElement","itemSeparator","cellStyle","rowReverse","columnReverse","row","onFocusCapture","Component","flexDirection","currContext","useContext","useMemo","Provider","_react","createContext","_VirtualizedList","_excluded","VirtualizedSectionList","_subExtractor","_convertViewable","_info$index","keyExtractorWithNullableIndex","keyExtractorWithNonNullableIndex","_onViewableItemsChanged","_renderItem","listItemCount","infoIndex","header","renderSectionHeader","renderSectionFooter","SeparatorComponent","_getSeparatorComponent","ItemWithSeparator","LeadingSeparatorComponent","SectionSeparatorComponent","leadingSection","setSelfHighlightCallback","_setUpdateHighlightFor","setSelfUpdatePropsCallback","_setUpdatePropsFor","updateHighlightFor","_updateHighlightFor","updatePropsFor","_updatePropsFor","trailingItem","trailingSection","_updatePropsMap","updateHighlight","_updateHighlightMap","updateHighlightFn","updatePropsFn","_captureRef","_listRef","itemIndex","sectionIndex","sections","listRef","stickySectionHeadersEnabled","__getListMetrics","toIndexParams","passThroughProps","_objectWithoutProperties2","listHeaderOffset","_getItem","sectionData","isLastItemInList","isLastItemInSection","_React$useState","useState","_React$useState2","leadingSeparatorHiglighted","setLeadingSeparatorHighlighted","_React$useState3","_React$useState4","separatorHighlighted","setSeparatorHighlighted","_React$useState5","_React$useState6","leadingSeparatorProps","setLeadingSeparatorProps","_React$useState7","_React$useState8","setSeparatorProps","useEffect","leadingSeparator","separator","_console","log","VirtualizedListContextResetter"],"sourceRoot":""}