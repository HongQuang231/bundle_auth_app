{"version":3,"file":"vendors-8cbd2506.bundle","mappings":"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","sources":["webpack:///../src/lruMemoize.ts","webpack:///../src/autotrackMemoize/autotrackMemoize.ts","webpack:///../src/autotrackMemoize/autotracking.ts","webpack:///../src/devModeChecks/setGlobalDevModeChecks.ts","webpack:///../src/utils.ts","webpack:///../src/autotrackMemoize/tracking.ts","webpack:///../src/autotrackMemoize/proxy.ts","webpack:///../src/weakMapMemoize.ts","webpack:///../src/createSelectorCreator.ts","webpack:///../src/createStructuredSelector.ts","webpack:///./node_modules/scheduler/cjs/scheduler.native.production.min.js","webpack:///./node_modules/scheduler/index.native.js","webpack:///./node_modules/shallowequal/index.js","webpack:///./node_modules/simple-swizzle/index.js","webpack:///./node_modules/simple-swizzle/node_modules/is-arrayish/index.js","webpack:///./node_modules/split-on-first/index.js","webpack:///./node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js","webpack:///./node_modules/strict-uri-encode/index.js"],"sourcesContent":["import type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nimport type { NOT_FOUND_TYPE } from './utils'\r\nimport { NOT_FOUND } from './utils'\r\n\r\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\r\n// https://github.com/erikras/lru-memoize\r\n\r\ninterface Entry {\r\n  key: unknown\r\n  value: unknown\r\n}\r\n\r\ninterface Cache {\r\n  get(key: unknown): unknown | NOT_FOUND_TYPE\r\n  put(key: unknown, value: unknown): void\r\n  getEntries(): Entry[]\r\n  clear(): void\r\n}\r\n\r\nfunction createSingletonCache(equals: EqualityFn): Cache {\r\n  let entry: Entry | undefined\r\n  return {\r\n    get(key: unknown) {\r\n      if (entry && equals(entry.key, key)) {\r\n        return entry.value\r\n      }\r\n\r\n      return NOT_FOUND\r\n    },\r\n\r\n    put(key: unknown, value: unknown) {\r\n      entry = { key, value }\r\n    },\r\n\r\n    getEntries() {\r\n      return entry ? [entry] : []\r\n    },\r\n\r\n    clear() {\r\n      entry = undefined\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLruCache(maxSize: number, equals: EqualityFn): Cache {\r\n  let entries: Entry[] = []\r\n\r\n  function get(key: unknown) {\r\n    const cacheIndex = entries.findIndex(entry => equals(key, entry.key))\r\n\r\n    // We found a cached entry\r\n    if (cacheIndex > -1) {\r\n      const entry = entries[cacheIndex]\r\n\r\n      // Cached entry not at top of cache, move it to the top\r\n      if (cacheIndex > 0) {\r\n        entries.splice(cacheIndex, 1)\r\n        entries.unshift(entry)\r\n      }\r\n\r\n      return entry.value\r\n    }\r\n\r\n    // No entry found in cache, return sentinel\r\n    return NOT_FOUND\r\n  }\r\n\r\n  function put(key: unknown, value: unknown) {\r\n    if (get(key) === NOT_FOUND) {\r\n      // TODO Is unshift slow?\r\n      entries.unshift({ key, value })\r\n      if (entries.length > maxSize) {\r\n        entries.pop()\r\n      }\r\n    }\r\n  }\r\n\r\n  function getEntries() {\r\n    return entries\r\n  }\r\n\r\n  function clear() {\r\n    entries = []\r\n  }\r\n\r\n  return { get, put, getEntries, clear }\r\n}\r\n\r\n/**\r\n * Runs a simple reference equality check.\r\n * What {@linkcode lruMemoize lruMemoize} uses by default.\r\n *\r\n * **Note**: This function was previously known as `defaultEqualityCheck`.\r\n *\r\n * @public\r\n */\r\nexport const referenceEqualityCheck: EqualityFn = (a, b) => a === b\r\n\r\nexport function createCacheKeyComparator(equalityCheck: EqualityFn) {\r\n  return function areArgumentsShallowlyEqual(\r\n    prev: unknown[] | IArguments | null,\r\n    next: unknown[] | IArguments | null\r\n  ): boolean {\r\n    if (prev === null || next === null || prev.length !== next.length) {\r\n      return false\r\n    }\r\n\r\n    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n    const { length } = prev\r\n    for (let i = 0; i < length; i++) {\r\n      if (!equalityCheck(prev[i], next[i])) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Options for configuring the behavior of a function memoized with\r\n * LRU (Least Recently Used) caching.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @public\r\n */\r\nexport interface LruMemoizeOptions<Result = any> {\r\n  /**\r\n   * Function used to compare the individual arguments of the\r\n   * provided calculation function.\r\n   *\r\n   * @default referenceEqualityCheck\r\n   */\r\n  equalityCheck?: EqualityFn\r\n\r\n  /**\r\n   * If provided, used to compare a newly generated output value against\r\n   * previous values in the cache. If a match is found,\r\n   * the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes\r\n   * a recalculation due to changed references, but the output is still\r\n   * effectively the same.\r\n   *\r\n   * @since 4.1.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n\r\n  /**\r\n   * The maximum size of the cache used by the selector.\r\n   * A size greater than 1 means the selector will use an\r\n   * LRU (Least Recently Used) cache, allowing for the caching of multiple\r\n   * results based on different sets of arguments.\r\n   *\r\n   * @default 1\r\n   */\r\n  maxSize?: number\r\n}\r\n\r\n/**\r\n * Creates a memoized version of a function with an optional\r\n * LRU (Least Recently Used) cache. The memoized function uses a cache to\r\n * store computed values. Depending on the `maxSize` option, it will use\r\n * either a singleton cache (for a single entry) or an\r\n * LRU cache (for multiple entries).\r\n *\r\n * **Note**: This function was previously known as `defaultMemoize`.\r\n *\r\n * @param func - The function to be memoized.\r\n * @param equalityCheckOrOptions - Either an equality check function or an options object.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/lruMemoize `lruMemoize`}\r\n *\r\n * @public\r\n */\r\nexport function lruMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  equalityCheckOrOptions?: EqualityFn | LruMemoizeOptions<ReturnType<Func>>\r\n) {\r\n  const providedOptions =\r\n    typeof equalityCheckOrOptions === 'object'\r\n      ? equalityCheckOrOptions\r\n      : { equalityCheck: equalityCheckOrOptions }\r\n\r\n  const {\r\n    equalityCheck = referenceEqualityCheck,\r\n    maxSize = 1,\r\n    resultEqualityCheck\r\n  } = providedOptions\r\n\r\n  const comparator = createCacheKeyComparator(equalityCheck)\r\n\r\n  let resultsCount = 0\r\n\r\n  const cache =\r\n    maxSize <= 1\r\n      ? createSingletonCache(comparator)\r\n      : createLruCache(maxSize, comparator)\r\n\r\n  function memoized() {\r\n    let value = cache.get(arguments) as ReturnType<Func>\r\n    if (value === NOT_FOUND) {\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      value = func.apply(null, arguments) as ReturnType<Func>\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const entries = cache.getEntries()\r\n        const matchingEntry = entries.find(entry =>\r\n          resultEqualityCheck(entry.value as ReturnType<Func>, value)\r\n        )\r\n\r\n        if (matchingEntry) {\r\n          value = matchingEntry.value as ReturnType<Func>\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n      }\r\n\r\n      cache.put(arguments, value)\r\n    }\r\n    return value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    cache.clear()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { createNode, updateNode } from './proxy'\r\nimport type { Node } from './tracking'\r\n\r\nimport { createCacheKeyComparator, referenceEqualityCheck } from '../lruMemoize'\r\nimport type { AnyFunction, DefaultMemoizeFields, Simplify } from '../types'\r\nimport { createCache } from './autotracking'\r\n\r\n/**\r\n * Uses an \"auto-tracking\" approach inspired by the work of the Ember Glimmer team.\r\n * It uses a Proxy to wrap arguments and track accesses to nested fields\r\n * in your selector on first read. Later, when the selector is called with\r\n * new arguments, it identifies which accessed fields have changed and\r\n * only recalculates the result if one or more of those accessed fields have changed.\r\n * This allows it to be more precise than the shallow equality checks in `lruMemoize`.\r\n *\r\n * __Design Tradeoffs for `autotrackMemoize`:__\r\n * - Pros:\r\n *    - It is likely to avoid excess calculations and recalculate fewer times than `lruMemoize` will,\r\n *    which may also result in fewer component re-renders.\r\n * - Cons:\r\n *    - It only has a cache size of 1.\r\n *    - It is slower than `lruMemoize`, because it has to do more work. (How much slower is dependent on the number of accessed fields in a selector, number of calls, frequency of input changes, etc)\r\n *    - It can have some unexpected behavior. Because it tracks nested field accesses,\r\n *    cases where you don't access a field will not recalculate properly.\r\n *    For example, a badly-written selector like:\r\n *      ```ts\r\n *      createSelector([state => state.todos], todos => todos)\r\n *      ```\r\n *      that just immediately returns the extracted value will never update, because it doesn't see any field accesses to check.\r\n *\r\n * __Use Cases for `autotrackMemoize`:__\r\n * - It is likely best used for cases where you need to access specific nested fields\r\n * in data, and avoid recalculating if other fields in the same data objects are immutably updated.\r\n *\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelector } from 'reselect'\r\n *\r\n * const selectTodoIds = createSelector(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id),\r\n *   { memoize: autotrackMemoize }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelectorCreator } from 'reselect'\r\n *\r\n * const createSelectorAutotrack = createSelectorCreator({ memoize: autotrackMemoize })\r\n *\r\n * const selectTodoIds = createSelectorAutotrack(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/unstable_autotrackMemoize autotrackMemoize}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function autotrackMemoize<Func extends AnyFunction>(func: Func) {\r\n  // we reference arguments instead of spreading them for performance reasons\r\n\r\n  const node: Node<Record<string, unknown>> = createNode(\r\n    [] as unknown as Record<string, unknown>\r\n  )\r\n\r\n  let lastArgs: IArguments | null = null\r\n\r\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck)\r\n\r\n  const cache = createCache(() => {\r\n    const res = func.apply(null, node.proxy as unknown as any[])\r\n    return res\r\n  })\r\n\r\n  function memoized() {\r\n    if (!shallowEqual(lastArgs, arguments)) {\r\n      updateNode(node, arguments as unknown as Record<string, unknown>)\r\n      lastArgs = arguments\r\n    }\r\n    return cache.value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    return cache.clear()\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","// Original autotracking implementation source:\r\n// - https://gist.github.com/pzuraq/79bf862e0f8cd9521b79c4b6eccdc4f9\r\n// Additional references:\r\n// - https://www.pzuraq.com/blog/how-autotracking-works\r\n// - https://v5.chriskrycho.com/journal/autotracking-elegant-dx-via-cutting-edge-cs/\r\nimport type { EqualityFn } from '../types'\r\nimport { assertIsFunction } from '../utils'\r\n\r\n// The global revision clock. Every time state changes, the clock increments.\r\nexport let $REVISION = 0\r\n\r\n// The current dependency tracker. Whenever we compute a cache, we create a Set\r\n// to track any dependencies that are used while computing. If no cache is\r\n// computing, then the tracker is null.\r\nlet CURRENT_TRACKER: Set<Cell<any> | TrackingCache> | null = null\r\n\r\n// Storage represents a root value in the system - the actual state of our app.\r\nexport class Cell<T> {\r\n  revision = $REVISION\r\n\r\n  _value: T\r\n  _lastValue: T\r\n  _isEqual: EqualityFn = tripleEq\r\n\r\n  constructor(initialValue: T, isEqual: EqualityFn = tripleEq) {\r\n    this._value = this._lastValue = initialValue\r\n    this._isEqual = isEqual\r\n  }\r\n\r\n  // Whenever a storage value is read, it'll add itself to the current tracker if\r\n  // one exists, entangling its state with that cache.\r\n  get value() {\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    return this._value\r\n  }\r\n\r\n  // Whenever a storage value is updated, we bump the global revision clock,\r\n  // assign the revision for this storage to the new value, _and_ we schedule a\r\n  // rerender. This is important, and it's what makes autotracking  _pull_\r\n  // based. We don't actively tell the caches which depend on the storage that\r\n  // anything has happened. Instead, we recompute the caches when needed.\r\n  set value(newValue) {\r\n    if (this.value === newValue) return\r\n\r\n    this._value = newValue\r\n    this.revision = ++$REVISION\r\n  }\r\n}\r\n\r\nfunction tripleEq(a: unknown, b: unknown) {\r\n  return a === b\r\n}\r\n\r\n// Caches represent derived state in the system. They are ultimately functions\r\n// that are memoized based on what state they use to produce their output,\r\n// meaning they will only rerun IFF a storage value that could affect the output\r\n// has changed. Otherwise, they'll return the cached value.\r\nexport class TrackingCache {\r\n  _cachedValue: any\r\n  _cachedRevision = -1\r\n  _deps: any[] = []\r\n  hits = 0\r\n\r\n  fn: () => any\r\n\r\n  constructor(fn: () => any) {\r\n    this.fn = fn\r\n  }\r\n\r\n  clear() {\r\n    this._cachedValue = undefined\r\n    this._cachedRevision = -1\r\n    this._deps = []\r\n    this.hits = 0\r\n  }\r\n\r\n  get value() {\r\n    // When getting the value for a Cache, first we check all the dependencies of\r\n    // the cache to see what their current revision is. If the current revision is\r\n    // greater than the cached revision, then something has changed.\r\n    if (this.revision > this._cachedRevision) {\r\n      const { fn } = this\r\n\r\n      // We create a new dependency tracker for this cache. As the cache runs\r\n      // its function, any Storage or Cache instances which are used while\r\n      // computing will be added to this tracker. In the end, it will be the\r\n      // full list of dependencies that this Cache depends on.\r\n      const currentTracker = new Set<Cell<any>>()\r\n      const prevTracker = CURRENT_TRACKER\r\n\r\n      CURRENT_TRACKER = currentTracker\r\n\r\n      // try {\r\n      this._cachedValue = fn()\r\n      // } finally {\r\n      CURRENT_TRACKER = prevTracker\r\n      this.hits++\r\n      this._deps = Array.from(currentTracker)\r\n\r\n      // Set the cached revision. This is the current clock count of all the\r\n      // dependencies. If any dependency changes, this number will be less\r\n      // than the new revision.\r\n      this._cachedRevision = this.revision\r\n      // }\r\n    }\r\n\r\n    // If there is a current tracker, it means another Cache is computing and\r\n    // using this one, so we add this one to the tracker.\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    // Always return the cached value.\r\n    return this._cachedValue\r\n  }\r\n\r\n  get revision() {\r\n    // The current revision is the max of all the dependencies' revisions.\r\n    return Math.max(...this._deps.map(d => d.revision), 0)\r\n  }\r\n}\r\n\r\nexport function getValue<T>(cell: Cell<T>): T {\r\n  if (!(cell instanceof Cell)) {\r\n    console.warn('Not a valid cell! ', cell)\r\n  }\r\n\r\n  return cell.value\r\n}\r\n\r\ntype CellValue<T extends Cell<unknown>> = T extends Cell<infer U> ? U : never\r\n\r\nexport function setValue<T extends Cell<unknown>>(\r\n  storage: T,\r\n  value: CellValue<T>\r\n): void {\r\n  if (!(storage instanceof Cell)) {\r\n    throw new TypeError(\r\n      'setValue must be passed a tracked store created with `createStorage`.'\r\n    )\r\n  }\r\n\r\n  storage.value = storage._lastValue = value\r\n}\r\n\r\nexport function createCell<T = unknown>(\r\n  initialValue: T,\r\n  isEqual: EqualityFn = tripleEq\r\n): Cell<T> {\r\n  return new Cell(initialValue, isEqual)\r\n}\r\n\r\nexport function createCache<T = unknown>(fn: () => T): TrackingCache {\r\n  assertIsFunction(\r\n    fn,\r\n    'the first parameter to `createCache` must be a function'\r\n  )\r\n\r\n  return new TrackingCache(fn)\r\n}\r\n","import type { DevModeChecks } from '../types'\r\n\r\n/**\r\n * Global configuration for development mode checks. This specifies the default\r\n * frequency at which each development mode check should be performed.\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const globalDevModeChecks: DevModeChecks = {\r\n  inputStabilityCheck: 'once',\r\n  identityFunctionCheck: 'once'\r\n}\r\n\r\n/**\r\n * Overrides the development mode checks settings for all selectors.\r\n *\r\n * Reselect performs additional checks in development mode to help identify and\r\n * warn about potential issues in selector behavior. This function allows you to\r\n * customize the behavior of these checks across all selectors in your application.\r\n *\r\n * **Note**: This setting can still be overridden per selector inside `createSelector`'s `options` object.\r\n * See {@link https://github.com/reduxjs/reselect#2-per-selector-by-passing-an-identityfunctioncheck-option-directly-to-createselector per-selector-configuration}\r\n * and {@linkcode CreateSelectorOptions.identityFunctionCheck identityFunctionCheck} for more details.\r\n *\r\n * _The development mode checks do not run in production builds._\r\n *\r\n * @param devModeChecks - An object specifying the desired settings for development mode checks. You can provide partial overrides. Unspecified settings will retain their current values.\r\n *\r\n * @example\r\n * ```ts\r\n * import { setGlobalDevModeChecks } from 'reselect'\r\n * import { DevModeChecks } from '../types'\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'always' })\r\n *\r\n * // Never run the input stability check.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'never' })\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'always' })\r\n *\r\n * // Never run the identity function check.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'never' })\r\n * ```\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks Development-Only Stability Checks}\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#1-globally-through-setglobaldevmodechecks global-configuration}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport const setGlobalDevModeChecks = (\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  Object.assign(globalDevModeChecks, devModeChecks)\r\n}\r\n","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = /* @__PURE__ */ Symbol('NOT_FOUND')\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","import type { Cell } from './autotracking'\r\nimport {\r\n  getValue as consumeTag,\r\n  createCell as createStorage,\r\n  setValue\r\n} from './autotracking'\r\n\r\nexport type Tag = Cell<unknown>\r\n\r\nconst neverEq = (a: any, b: any): boolean => false\r\n\r\nexport function createTag(): Tag {\r\n  return createStorage(null, neverEq)\r\n}\r\nexport { consumeTag }\r\nexport function dirtyTag(tag: Tag, value: any): void {\r\n  setValue(tag, value)\r\n}\r\n\r\nexport interface Node<\r\n  T extends Array<unknown> | Record<string, unknown> =\r\n    | Array<unknown>\r\n    | Record<string, unknown>\r\n> {\r\n  collectionTag: Tag | null\r\n  tag: Tag | null\r\n  tags: Record<string, Tag>\r\n  children: Record<string, Node>\r\n  proxy: T\r\n  value: T\r\n  id: number\r\n}\r\n\r\nexport const consumeCollection = (node: Node): void => {\r\n  let tag = node.collectionTag\r\n\r\n  if (tag === null) {\r\n    tag = node.collectionTag = createTag()\r\n  }\r\n\r\n  consumeTag(tag)\r\n}\r\n\r\nexport const dirtyCollection = (node: Node): void => {\r\n  const tag = node.collectionTag\r\n\r\n  if (tag !== null) {\r\n    dirtyTag(tag, null)\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const lastResultValue = lastResult?.deref?.() ?? lastResult\r\n\r\n        if (\r\n          lastResultValue != null &&\r\n          resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n        ) {\r\n          result = lastResultValue\r\n\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n\r\n        const needsWeakRef =\r\n          (typeof result === 'object' && result !== null) ||\r\n          typeof result === 'function'\r\n\r\n        lastResult = needsWeakRef ? new Ref(result) : result\r\n      }\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template StateType - The type of state that the selectors created with this selector creator will operate on.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  StateType = any\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <InputSelectors extends SelectorArray<StateType>, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of {@linkcode createSelector createSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every {@linkcode createSelector createSelector} call.\r\n   *\r\n   * @returns A pre-typed `createSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createAppSelector = createSelector.withTypes<RootState>()\r\n   *\r\n   * const selectTodoIds = createAppSelector(\r\n   *   [\r\n   *     // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *     state => state.todos\r\n   *   ],\r\n   *   todos => todos.map(({ id }) => id)\r\n   * )\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all selectors created with this selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector#defining-a-pre-typed-createselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <OverrideStateType extends StateType>() => CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction,\r\n    OverrideStateType\r\n  >\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization\r\n * function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments as unknown as Parameters<Combiner<InputSelectors, Result>>\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>,\r\n            inputSelectorResults,\r\n            lastResult\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n\r\n  Object.assign(createSelector, {\r\n    withTypes: () => createSelector\r\n  })\r\n\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from './createSelectorCreator'\r\n\r\nimport type { CreateSelectorFunction } from './createSelectorCreator'\r\nimport type {\r\n  InterruptRecursion,\r\n  ObjectValuesToTuple,\r\n  OutputSelector,\r\n  Selector,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\nimport { assertIsObject } from './utils'\r\nimport type { weakMapMemoize } from './weakMapMemoize'\r\n\r\n/**\r\n * Represents a mapping of selectors to their return types.\r\n *\r\n * @template TObject - An object type where each property is a selector function.\r\n *\r\n * @public\r\n */\r\nexport type SelectorResultsMap<TObject extends SelectorsObject> = {\r\n  [Key in keyof TObject]: ReturnType<TObject[Key]>\r\n}\r\n\r\n/**\r\n * Represents a mapping of selectors for each key in a given root state.\r\n *\r\n * This type is a utility that takes a root state object type and\r\n * generates a corresponding set of selectors. Each selector is associated\r\n * with a key in the root state, allowing for the selection\r\n * of specific parts of the state.\r\n *\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type RootStateSelectors<RootState = any> = {\r\n  [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\r\n}\r\n\r\n/**\r\n * @deprecated Please use {@linkcode StructuredSelectorCreator.withTypes createStructuredSelector.withTypes<RootState>()} instead. This type will be removed in the future.\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type TypedStructuredSelectorCreator<RootState = any> =\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends RootStateSelectors<RootState> = RootStateSelectors<RootState>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ) => OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n/**\r\n * Represents an object where each property is a selector function.\r\n *\r\n * @template StateType - The type of state that all the selectors operate on.\r\n *\r\n * @public\r\n */\r\nexport type SelectorsObject<StateType = any> = Record<\r\n  string,\r\n  Selector<StateType>\r\n>\r\n\r\n/**\r\n * It provides a way to create structured selectors.\r\n * The structured selector can take multiple input selectors\r\n * and map their output to an object with specific keys.\r\n *\r\n * @template StateType - The type of state that the structured selectors created with this structured selector creator will operate on.\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport interface StructuredSelectorCreator<StateType = any> {\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends SelectorsObject<StateType>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ): OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of\r\n   * {@linkcode createStructuredSelector createStructuredSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every\r\n   * {@linkcode createStructuredSelector createStructuredSelector} call.\r\n   *\r\n   * @returns A pre-typed `createStructuredSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createStructuredSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createStructuredAppSelector =\r\n   *   createStructuredSelector.withTypes<RootState>()\r\n   *\r\n   * const structuredAppSelector = createStructuredAppSelector({\r\n   *   // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *   todos: state => state.todos,\r\n   *   alerts: state => state.alerts,\r\n   *   todoById: (state, id: number) => state.todos[id]\r\n   * })\r\n   *\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all structured selectors created with this structured selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createstructuredselector#defining-a-pre-typed-createstructuredselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <\r\n    OverrideStateType extends StateType\r\n  >() => StructuredSelectorCreator<OverrideStateType>\r\n}\r\n\r\n/**\r\n * A convenience function that simplifies returning an object\r\n * made up of selector results.\r\n *\r\n * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n * @returns A memoized structured selector.\r\n *\r\n * @example\r\n * <caption>Modern Use Case</caption>\r\n * ```ts\r\n * import { createSelector, createStructuredSelector } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   todos: {\r\n *     id: number\r\n *     completed: boolean\r\n *     title: string\r\n *     description: string\r\n *   }[]\r\n *   alerts: { id: number; read: boolean }[]\r\n * }\r\n *\r\n * // This:\r\n * const structuredSelector = createStructuredSelector(\r\n *   {\r\n *     todos: (state: RootState) => state.todos,\r\n *     alerts: (state: RootState) => state.alerts,\r\n *     todoById: (state: RootState, id: number) => state.todos[id]\r\n *   },\r\n *   createSelector\r\n * )\r\n *\r\n * // Is essentially the same as this:\r\n * const selector = createSelector(\r\n *   [\r\n *     (state: RootState) => state.todos,\r\n *     (state: RootState) => state.alerts,\r\n *     (state: RootState, id: number) => state.todos[id]\r\n *   ],\r\n *   (todos, alerts, todoById) => {\r\n *     return {\r\n *       todos,\r\n *       alerts,\r\n *       todoById\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createStructuredSelector: StructuredSelectorCreator =\r\n  Object.assign(\r\n    <\r\n      InputSelectorsObject extends SelectorsObject,\r\n      MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n      ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n    >(\r\n      inputSelectorsObject: InputSelectorsObject,\r\n      selectorCreator: CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      > = createSelector as CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >\r\n    ) => {\r\n      assertIsObject(\r\n        inputSelectorsObject,\r\n        'createStructuredSelector expects first argument to be an object ' +\r\n          `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\r\n      )\r\n      const inputSelectorKeys = Object.keys(inputSelectorsObject)\r\n      const dependencies = inputSelectorKeys.map(\r\n        key => inputSelectorsObject[key]\r\n      )\r\n      const structuredSelector = selectorCreator(\r\n        dependencies,\r\n        (...inputSelectorResults: any[]) => {\r\n          return inputSelectorResults.reduce((composition, value, index) => {\r\n            composition[inputSelectorKeys[index]] = value\r\n            return composition\r\n          }, {})\r\n        }\r\n      )\r\n      return structuredSelector\r\n    },\r\n    { withTypes: () => createStructuredSelector }\r\n  ) as StructuredSelectorCreator\r\n","/**\n * @license React\n * scheduler.native.production.min.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,t=e>>>1;d<t;){var m=2*(d+1)-1,E=a[m],n=m+1,A=a[n];if(0>g(E,c))n<e&&0>g(A,E)?(a[d]=A,a[n]=c,d=n):(a[d]=E,a[m]=c,d=m);else if(n<e&&0>g(A,c))a[d]=A,a[n]=c,d=n;else break a}}return b}\nfunction g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var l;if(\"object\"===typeof performance&&\"function\"===typeof performance.now){var p=performance;l=function(){return p.now()}}else{var q=Date,r=q.now();l=function(){return q.now()-r}}var u=[],v=[],w=1,x=null,y=3,z=!1,B=!1,C=!1,D=\"function\"===typeof setTimeout?setTimeout:null,F=\"function\"===typeof clearTimeout?clearTimeout:null,G=\"undefined\"!==typeof setImmediate?setImmediate:null;\n\"undefined\"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending?navigator.scheduling.isInputPending.bind(navigator.scheduling):null;function H(a){for(var b=h(v);null!==b;){if(null===b.callback)k(v);else if(b.startTime<=a)k(v),b.sortIndex=b.expirationTime,f(u,b);else break;b=h(v)}}function I(a){C=!1;H(a);if(!B)if(null!==h(u))B=!0,J=K,L||(L=!0,M());else{var b=h(v);null!==b&&N(I,b.startTime-a)}}\nfunction K(a,b){B=!1;C&&(C=!1,F(O),O=-1);z=!0;var c=y;try{a:{H(b);for(x=h(u);null!==x&&(!(x.expirationTime>b)||a&&!P());){var d=x.callback;if(\"function\"===typeof d){x.callback=null;y=x.priorityLevel;var e=d(x.expirationTime<=b);b=l();if(\"function\"===typeof e){x.callback=e;H(b);var t=!0;break a}else x===h(u)&&k(u),H(b)}else k(u);x=h(u)}if(null!==x)t=!0;else{var m=h(v);null!==m&&N(I,m.startTime-b);t=!1}}return t}finally{x=null,y=c,z=!1}}\nfunction Q(a,b,c){var d=l();\"object\"===typeof c&&null!==c?(c=c.delay,c=\"number\"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:w++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(v,a),null===h(u)&&a===h(v)&&(C?(F(O),O=-1):C=!0,N(I,c-d))):(a.sortIndex=e,f(u,a),B||z||(B=!0,J=K,L||(L=!0,M())));return a}function R(a){a.callback=null}function S(){return y}\nvar L=!1,J=null,O=-1,T=-1;function P(){return 5>l()-T?!1:!0}function U(){}function V(){if(null!==J){var a=l();T=a;var b=!0;try{b=J(!0,a)}finally{b?M():(L=!1,J=null)}}else L=!1}var M;if(\"function\"===typeof G)M=function(){G(V)};else if(\"undefined\"!==typeof MessageChannel){var W=new MessageChannel,X=W.port2;W.port1.onmessage=V;M=function(){X.postMessage(null)}}else M=function(){D(V,0)};function N(a,b){O=D(function(){a(l())},b)}\nvar Y=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_UserBlockingPriority:2,aa=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_NormalPriority:3,ba=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_LowPriority:4,ca=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_ImmediatePriority:1,da=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_scheduleCallback:Q,ea=\"undefined\"!==\ntypeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_cancelCallback:R,fa=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_getCurrentPriorityLevel:S,ha=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_shouldYield:P,ia=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_requestPaint:U,ja=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_now:l;\nfunction Z(){throw Error(\"Not implemented.\");}exports.unstable_IdlePriority=\"undefined\"!==typeof nativeRuntimeScheduler?nativeRuntimeScheduler.unstable_IdlePriority:5;exports.unstable_ImmediatePriority=ca;exports.unstable_LowPriority=ba;exports.unstable_NormalPriority=aa;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=Y;exports.unstable_cancelCallback=ea;exports.unstable_continueExecution=Z;exports.unstable_forceFrameRate=Z;exports.unstable_getCurrentPriorityLevel=fa;\nexports.unstable_getFirstCallbackNode=Z;exports.unstable_next=Z;exports.unstable_now=ja;exports.unstable_pauseExecution=Z;exports.unstable_requestPaint=ia;exports.unstable_runWithPriority=Z;exports.unstable_scheduleCallback=da;exports.unstable_shouldYield=ha;exports.unstable_wrapCallback=Z;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.native.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.native.development.js');\n}\n","//\n\nmodule.exports = function shallowEqual(objA, objB, compare, compareContext) {\n  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n\n  if (ret !== void 0) {\n    return !!ret;\n  }\n\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n\n  // Test for A's keys different from B.\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n\n    if (!bHasOwnProperty(key)) {\n      return false;\n    }\n\n    var valueA = objA[key];\n    var valueB = objB[key];\n\n    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n\n    if (ret === false || (ret === void 0 && valueA !== valueB)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","'use strict';\n\nvar isArrayish = require('is-arrayish');\n\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\n\nvar swizzle = module.exports = function swizzle(args) {\n\tvar results = [];\n\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tvar arg = args[i];\n\n\t\tif (isArrayish(arg)) {\n\t\t\t// http://jsperf.com/javascript-array-concat-vs-push/98\n\t\t\tresults = concat.call(results, slice.call(arg));\n\t\t} else {\n\t\t\tresults.push(arg);\n\t\t}\n\t}\n\n\treturn results;\n};\n\nswizzle.wrap = function (fn) {\n\treturn function () {\n\t\treturn fn(swizzle(arguments));\n\t};\n};\n","module.exports = function isArrayish(obj) {\n\tif (!obj || typeof obj === 'string') {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && (obj.splice instanceof Function ||\n\t\t\t(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar UNKNOWN_FUNCTION = '<unknown>';\n/**\n * This parses the different stack traces and puts them into one format\n * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)\n */\n\nfunction parse(stackString) {\n  var lines = stackString.split('\\n');\n  return lines.reduce(function (stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n\n    return stack;\n  }, []);\n}\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n  var submatch = chromeEvalRe.exec(parts[2]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1]; // url\n\n    parts[3] = submatch[2]; // line\n\n    parts[4] = submatch[3]; // column\n  }\n\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null; // no column when eval\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(',') : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\n\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nexports.parse = parse;\n","'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n"],"names":["func","equalityCheckOrOptions","providedOptions","equalityCheck","_providedOptions$equa","referenceEqualityCheck","_providedOptions$maxS","maxSize","resultEqualityCheck","comparator","createCacheKeyComparator","resultsCount","cache","equals","get","key","entry","value","NOT_FOUND","put","getEntries","clear","entries","cacheIndex","findIndex","splice","unshift","length","pop","createLruCache","memoized","arguments","apply","matchingEntry","find","clearCache","resetResultsCount","node","createNode","lastArgs","shallowEqual","fn","proxy","assertIsFunction","TrackingCache","updateNode","globalDevModeChecks","inputStabilityCheck","identityFunctionCheck","exports","devModeChecks","Object","assign","Symbol","TypeError","undefined","ensureIsArray","item","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","errorMessage","every","itemTypes","map","name","join","assertIsArrayOfFunctions","$REVISION","CURRENT_TRACKER","Cell","_createClass2","default","initialValue","isEqual","tripleEq","_classCallCheck2","__publicField","this","_value","_lastValue","_isEqual","add","set","newValue","revision","a","b","_cachedValue","_cachedRevision","_deps","hits","currentTracker","Set","prevTracker","from","Math","max","_toConsumableArray2","d","concat","getValue","cell","console","warn","neverEq","createTag","createCell","dirtyTag","tag","storage","setValue","consumeCollection","collectionTag","dirtyCollection","nextId","proto","getPrototypeOf","ObjectTreeNode","Proxy","objectProxyHandler","childValue","Reflect","childNode","children","tags","calculateResult","ownKeys","getOwnPropertyDescriptor","prop","has","ArrayTreeNode","arrayProxyHandler","_ref","_slicedToArray2","_ref3","_ref5","_ref7","oldKeysSize","newKeysSize","anyKeysAdded","_key","newChildValue","deleteNode","prev","next","i","StrongRef","Ref","WeakRef","UNTERMINATED","TERMINATED","createCacheNode","s","v","o","p","weakMapMemoize","lastResult","options","fnNode","_a","_b","cacheNode","l","arg","objectCache","WeakMap","objectNode","primitiveCache","Map","primitiveNode","result","terminatedNode","lastResultValue","deref","call","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key5","createSelectorCreatorOptions","memoize","memoizeOptions","createSelector2","_len2","_key6","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","combinedOptions","__spreadValues","_combinedOptions$memo","_combinedOptions$args","argsMemoize","_combinedOptions$args2","argsMemoizeOptions","finalMemoizeOptions","finalArgsMemoizeOptions","memoizedResultFunc","selector","inputSelectorResults","inputSelectorArgs","push","collectInputSelectorResults","resetDependencyRecomputations","resetRecomputations","withTypes","createSelector","createStructuredSelector","inputSelectorsObject","selectorCreator","object","assertIsObject","inputSelectorKeys","keys","structuredSelector","_len3","_key7","reduce","composition","index","f","c","e","g","h","k","t","m","E","n","A","sortIndex","id","performance","now","q","Date","r","u","w","x","y","z","B","C","D","setTimeout","F","clearTimeout","G","setImmediate","H","callback","startTime","expirationTime","I","J","K","L","M","N","O","P","priorityLevel","navigator","scheduling","isInputPending","bind","T","V","MessageChannel","W","X","port2","port1","onmessage","postMessage","Y","nativeRuntimeScheduler","unstable_UserBlockingPriority","aa","unstable_NormalPriority","ba","unstable_LowPriority","ca","unstable_ImmediatePriority","da","unstable_scheduleCallback","delay","ea","unstable_cancelCallback","fa","unstable_getCurrentPriorityLevel","ha","unstable_shouldYield","ia","unstable_requestPaint","ja","unstable_now","Z","Error","unstable_IdlePriority","unstable_Profiling","unstable_continueExecution","unstable_forceFrameRate","unstable_getFirstCallbackNode","unstable_next","unstable_pauseExecution","unstable_runWithPriority","unstable_wrapCallback","module","objA","objB","compare","compareContext","ret","keysA","keysB","bHasOwnProperty","prototype","hasOwnProperty","idx","valueA","valueB","isArrayish","slice","swizzle","args","results","len","wrap","obj","Function","constructor","string","separator","separatorIndex","indexOf","defineProperty","UNKNOWN_FUNCTION","chromeRe","chromeEvalRe","winjsRe","geckoRe","geckoEvalRe","javaScriptCoreRe","nodeRe","parse","stackString","split","stack","line","parseResult","parts","exec","isNative","isEval","submatch","file","methodName","lineNumber","column","parseChrome","parseWinjs","parseGecko","parseNode","parseJSC","str","encodeURIComponent","replace","charCodeAt","toString","toUpperCase"],"sourceRoot":""}