{"version":3,"file":"vendors-node_modules_react-native-reanimated_src_reanimated2_interpolateColor_ts-node_modules-f539b7.chunk.bundle","mappings":"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","sources":["webpack:///./node_modules/react-native-reanimated/src/reanimated2/interpolateColor.ts","webpack:///./node_modules/react-native-reanimated/src/reanimated2/interpolation.ts","webpack:///./node_modules/react-native-reanimated/src/reanimated2/isSharedValue.ts","webpack:///./node_modules/react-native-reanimated/src/reanimated2/jestUtils.ts"],"sourcesContent":["'use strict';\nimport {\n  hsvToColor,\n  RGBtoHSV,\n  rgbaColor,\n  processColor,\n  red,\n  green,\n  blue,\n  opacity,\n} from './Colors';\nimport { makeMutable } from './core';\nimport { Extrapolation, interpolate } from './interpolation';\nimport type { SharedValue } from './commonTypes';\nimport { useSharedValue } from './hook/useSharedValue';\n\n/**\n * @deprecated Please use Extrapolation instead\n */\nexport const Extrapolate = Extrapolation;\n\n/**\n * Options for color interpolation.\n *\n * @param gamma - Gamma value used in gamma correction. Defaults to `2.2`.\n * @param useCorrectedHSVInterpolation - Whether to reduce the number of colors the interpolation has to go through. Defaults to `true`.\n */\nexport type InterpolationOptions = {\n  gamma?: number;\n  useCorrectedHSVInterpolation?: boolean;\n};\n\nconst interpolateColorsHSV = (\n  value: number,\n  inputRange: readonly number[],\n  colors: InterpolateHSV,\n  options: InterpolationOptions\n) => {\n  'worklet';\n  let h = 0;\n  const { useCorrectedHSVInterpolation = true } = options;\n  if (useCorrectedHSVInterpolation) {\n    // if the difference between hues in a range is > 180 deg\n    // then move the hue at the right end of the range +/- 360 deg\n    // and add the next point in the original place + 0.00001 with original hue\n    // to not break the next range\n    const correctedInputRange = [inputRange[0]];\n    const originalH = colors.h;\n    const correctedH = [originalH[0]];\n\n    for (let i = 1; i < originalH.length; ++i) {\n      const d = originalH[i] - originalH[i - 1];\n      if (originalH[i] > originalH[i - 1] && d > 0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] - 1);\n        correctedH.push(originalH[i]);\n      } else if (originalH[i] < originalH[i - 1] && d < -0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] + 1);\n        correctedH.push(originalH[i]);\n      } else {\n        correctedInputRange.push(inputRange[i]);\n        correctedH.push(originalH[i]);\n      }\n    }\n    h =\n      (interpolate(\n        value,\n        correctedInputRange,\n        correctedH,\n        Extrapolation.CLAMP\n      ) +\n        1) %\n      1;\n  } else {\n    h = interpolate(value, inputRange, colors.h, Extrapolation.CLAMP);\n  }\n  const s = interpolate(value, inputRange, colors.s, Extrapolation.CLAMP);\n  const v = interpolate(value, inputRange, colors.v, Extrapolation.CLAMP);\n  const a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  return hsvToColor(h, s, v, a);\n};\n\nconst toLinearSpace = (x: number[], gamma: number): number[] => {\n  'worklet';\n  return x.map((v) => Math.pow(v / 255, gamma));\n};\n\nconst toGammaSpace = (x: number, gamma: number): number => {\n  'worklet';\n  return Math.round(Math.pow(x, 1 / gamma) * 255);\n};\n\nconst interpolateColorsRGB = (\n  value: number,\n  inputRange: readonly number[],\n  colors: InterpolateRGB,\n  options: InterpolationOptions\n) => {\n  'worklet';\n  const { gamma = 2.2 } = options;\n  let { r: outputR, g: outputG, b: outputB } = colors;\n  if (gamma !== 1) {\n    outputR = toLinearSpace(outputR, gamma);\n    outputG = toLinearSpace(outputG, gamma);\n    outputB = toLinearSpace(outputB, gamma);\n  }\n  const r = interpolate(value, inputRange, outputR, Extrapolation.CLAMP);\n  const g = interpolate(value, inputRange, outputG, Extrapolation.CLAMP);\n  const b = interpolate(value, inputRange, outputB, Extrapolation.CLAMP);\n  const a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  if (gamma === 1) {\n    return rgbaColor(r, g, b, a);\n  }\n  return rgbaColor(\n    toGammaSpace(r, gamma),\n    toGammaSpace(g, gamma),\n    toGammaSpace(b, gamma),\n    a\n  );\n};\n\nexport interface InterpolateRGB {\n  r: number[];\n  g: number[];\n  b: number[];\n  a: number[];\n}\n\nconst getInterpolateRGB = (\n  colors: readonly (string | number)[]\n): InterpolateRGB => {\n  'worklet';\n\n  const r = [];\n  const g = [];\n  const b = [];\n  const a = [];\n  for (let i = 0; i < colors.length; ++i) {\n    const color = colors[i];\n    const processedColor = processColor(color);\n    // explicit check in case if processedColor is 0\n    if (processedColor !== null && processedColor !== undefined) {\n      r.push(red(processedColor));\n      g.push(green(processedColor));\n      b.push(blue(processedColor));\n      a.push(opacity(processedColor));\n    }\n  }\n  return { r, g, b, a };\n};\n\nexport interface InterpolateHSV {\n  h: number[];\n  s: number[];\n  v: number[];\n  a: number[];\n}\n\nconst getInterpolateHSV = (\n  colors: readonly (string | number)[]\n): InterpolateHSV => {\n  'worklet';\n  const h = [];\n  const s = [];\n  const v = [];\n  const a = [];\n  for (let i = 0; i < colors.length; ++i) {\n    const color = colors[i];\n    const processedColor = processColor(color) as any;\n    if (typeof processedColor === 'number') {\n      const processedHSVColor = RGBtoHSV(\n        red(processedColor),\n        green(processedColor),\n        blue(processedColor)\n      );\n\n      h.push(processedHSVColor.h);\n      s.push(processedHSVColor.s);\n      v.push(processedHSVColor.v);\n      a.push(opacity(processedColor));\n    }\n  }\n  return { h, s, v, a };\n};\n\n/**\n * Lets you map a value from a range of numbers to a range of colors using linear interpolation.\n *\n * @param value - A number from the `input` range that is going to be mapped to the color in the `output` range.\n * @param inputRange - An array of numbers specifying the input range of the interpolation.\n * @param outputRange - An array of output colors values (eg. \"red\", \"#00FFCC\", \"rgba(255, 0, 0, 0.5)\").\n * @param colorSpace - The color space to use for interpolation. Defaults to 'RGB'.\n * @param options - Additional options for interpolation - {@link InterpolationOptions}.\n * @returns The color after interpolation from within the output range in rgba(r, g, b, a) format.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/utilities/interpolateColor\n */\nexport function interpolateColor(\n  value: number,\n  inputRange: readonly number[],\n  outputRange: readonly string[],\n  colorSpace?: 'RGB' | 'HSV',\n  options?: InterpolationOptions\n): string;\n\nexport function interpolateColor(\n  value: number,\n  inputRange: readonly number[],\n  outputRange: readonly number[],\n  colorSpace?: 'RGB' | 'HSV',\n  options?: InterpolationOptions\n): number;\n\nexport function interpolateColor(\n  value: number,\n  inputRange: readonly number[],\n  outputRange: readonly (string | number)[],\n  colorSpace: 'RGB' | 'HSV' = 'RGB',\n  options: InterpolationOptions = {}\n): string | number {\n  'worklet';\n  if (colorSpace === 'HSV') {\n    return interpolateColorsHSV(\n      value,\n      inputRange,\n      getInterpolateHSV(outputRange),\n      options\n    );\n  } else if (colorSpace === 'RGB') {\n    return interpolateColorsRGB(\n      value,\n      inputRange,\n      getInterpolateRGB(outputRange),\n      options\n    );\n  }\n  throw new Error(\n    `[Reanimated] Invalid color space provided: ${\n      colorSpace as string\n    }. Supported values are: ['RGB', 'HSV'].`\n  );\n}\n\nexport enum ColorSpace {\n  RGB = 0,\n  HSV = 1,\n}\n\nexport interface InterpolateConfig {\n  inputRange: readonly number[];\n  outputRange: readonly (string | number)[];\n  colorSpace: ColorSpace;\n  cache: SharedValue<InterpolateRGB | InterpolateHSV | null>;\n  options: InterpolationOptions;\n}\n\nexport function useInterpolateConfig(\n  inputRange: readonly number[],\n  outputRange: readonly (string | number)[],\n  colorSpace = ColorSpace.RGB,\n  options: InterpolationOptions = {}\n): SharedValue<InterpolateConfig> {\n  return useSharedValue<InterpolateConfig>({\n    inputRange,\n    outputRange,\n    colorSpace,\n    cache: makeMutable<InterpolateRGB | InterpolateHSV | null>(null),\n    options,\n  });\n}\n","'use strict';\n\n/**\n * Extrapolation type.\n *\n * @param IDENTITY - Returns the provided value as is.\n * @param CLAMP - Clamps the value to the edge of the output range.\n * @param EXTEND - Predicts the values beyond the output range.\n */\nexport enum Extrapolation {\n  IDENTITY = 'identity',\n  CLAMP = 'clamp',\n  EXTEND = 'extend',\n}\n\n/**\n * Represents the possible values for extrapolation as a string.\n */\ntype ExtrapolationAsString = 'identity' | 'clamp' | 'extend';\n\ninterface InterpolationNarrowedInput {\n  leftEdgeInput: number;\n  rightEdgeInput: number;\n  leftEdgeOutput: number;\n  rightEdgeOutput: number;\n}\n\n/**\n * Allows to specify extrapolation for left and right edge of the interpolation.\n */\nexport interface ExtrapolationConfig {\n  extrapolateLeft?: Extrapolation | string;\n  extrapolateRight?: Extrapolation | string;\n}\n\ninterface RequiredExtrapolationConfig {\n  extrapolateLeft: Extrapolation;\n  extrapolateRight: Extrapolation;\n}\n\n/**\n * Configuration options for extrapolation.\n */\nexport type ExtrapolationType =\n  | ExtrapolationConfig\n  | Extrapolation\n  | ExtrapolationAsString\n  | undefined;\n\nfunction getVal(\n  type: Extrapolation,\n  coef: number,\n  val: number,\n  leftEdgeOutput: number,\n  rightEdgeOutput: number,\n  x: number\n): number {\n  'worklet';\n\n  switch (type) {\n    case Extrapolation.IDENTITY:\n      return x;\n    case Extrapolation.CLAMP:\n      if (coef * val < coef * leftEdgeOutput) {\n        return leftEdgeOutput;\n      }\n      return rightEdgeOutput;\n    case Extrapolation.EXTEND:\n    default:\n      return val;\n  }\n}\n\nfunction isExtrapolate(value: string): value is Extrapolation {\n  'worklet';\n\n  return (\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    value === Extrapolation.EXTEND ||\n    value === Extrapolation.CLAMP ||\n    value === Extrapolation.IDENTITY\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  );\n}\n\n// validates extrapolations type\n// if type is correct, converts it to ExtrapolationConfig\nfunction validateType(type: ExtrapolationType): RequiredExtrapolationConfig {\n  'worklet';\n  // initialize extrapolationConfig with default extrapolation\n  const extrapolationConfig: RequiredExtrapolationConfig = {\n    extrapolateLeft: Extrapolation.EXTEND,\n    extrapolateRight: Extrapolation.EXTEND,\n  };\n\n  if (!type) {\n    return extrapolationConfig;\n  }\n\n  if (typeof type === 'string') {\n    if (!isExtrapolate(type)) {\n      throw new Error(\n        `[Reanimated] Unsupported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`\n      );\n    }\n    extrapolationConfig.extrapolateLeft = type;\n    extrapolationConfig.extrapolateRight = type;\n    return extrapolationConfig;\n  }\n\n  // otherwise type is extrapolation config object\n  if (\n    (type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft)) ||\n    (type.extrapolateRight && !isExtrapolate(type.extrapolateRight))\n  ) {\n    throw new Error(\n      `[Reanimated] Unsupported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`\n    );\n  }\n\n  Object.assign(extrapolationConfig, type);\n  return extrapolationConfig;\n}\n\nfunction internalInterpolate(\n  x: number,\n  narrowedInput: InterpolationNarrowedInput,\n  extrapolationConfig: RequiredExtrapolationConfig\n) {\n  'worklet';\n  const { leftEdgeInput, rightEdgeInput, leftEdgeOutput, rightEdgeOutput } =\n    narrowedInput;\n  if (rightEdgeInput - leftEdgeInput === 0) {\n    return leftEdgeOutput;\n  }\n  const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n  const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n  const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n\n  if (coef * val < coef * leftEdgeOutput) {\n    return getVal(\n      extrapolationConfig.extrapolateLeft,\n      coef,\n      val,\n      leftEdgeOutput,\n      rightEdgeOutput,\n      x\n    );\n  } else if (coef * val > coef * rightEdgeOutput) {\n    return getVal(\n      extrapolationConfig.extrapolateRight,\n      coef,\n      val,\n      leftEdgeOutput,\n      rightEdgeOutput,\n      x\n    );\n  }\n\n  return val;\n}\n\n/**\n * Lets you map a value from one range to another using linear interpolation.\n *\n * @param value - A number from the `input` range that is going to be mapped to the `output` range.\n * @param inputRange - An array of numbers specifying the input range of the interpolation.\n * @param outputRange - An array of numbers specifying the output range of the interpolation.\n * @param extrapolate - determines what happens when the `value` goes beyond the `input` range. Defaults to `Extrapolation.EXTEND` - {@link ExtrapolationType}.\n * @returns A mapped value within the output range.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/utilities/interpolate\n */\nexport function interpolate(\n  x: number,\n  inputRange: readonly number[],\n  outputRange: readonly number[],\n  type?: ExtrapolationType\n): number {\n  'worklet';\n  if (inputRange.length < 2 || outputRange.length < 2) {\n    throw new Error(\n      '[Reanimated] Interpolation input and output ranges should contain at least two values.'\n    );\n  }\n\n  const extrapolationConfig = validateType(type);\n  const length = inputRange.length;\n  const narrowedInput: InterpolationNarrowedInput = {\n    leftEdgeInput: inputRange[0],\n    rightEdgeInput: inputRange[1],\n    leftEdgeOutput: outputRange[0],\n    rightEdgeOutput: outputRange[1],\n  };\n  if (length > 2) {\n    if (x > inputRange[length - 1]) {\n      narrowedInput.leftEdgeInput = inputRange[length - 2];\n      narrowedInput.rightEdgeInput = inputRange[length - 1];\n      narrowedInput.leftEdgeOutput = outputRange[length - 2];\n      narrowedInput.rightEdgeOutput = outputRange[length - 1];\n    } else {\n      for (let i = 1; i < length; ++i) {\n        if (x <= inputRange[i]) {\n          narrowedInput.leftEdgeInput = inputRange[i - 1];\n          narrowedInput.rightEdgeInput = inputRange[i];\n          narrowedInput.leftEdgeOutput = outputRange[i - 1];\n          narrowedInput.rightEdgeOutput = outputRange[i];\n          break;\n        }\n      }\n    }\n  }\n\n  return internalInterpolate(x, narrowedInput, extrapolationConfig);\n}\n\n/**\n * Lets you limit a value within a specified range.\n *\n * @param value - A number that will be returned as long as the provided value is in range between `min` and `max`.\n * @param min - A number which will be returned when provided `value` is lower than `min`.\n * @param max - A number which will be returned when provided `value` is higher than `max`.\n * @returns A number between min and max bounds.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/utilities/clamp/\n */\nexport function clamp(value: number, min: number, max: number) {\n  'worklet';\n  return Math.min(Math.max(value, min), max);\n}\n","'use strict';\nimport type { SharedValue } from './commonTypes';\n\nexport function isSharedValue<T = unknown>(\n  value: unknown\n): value is SharedValue<T> {\n  'worklet';\n  // We cannot use `in` operator here because `value` could be a HostObject and therefore we cast.\n  return (value as Record<string, unknown>)?._isReanimatedSharedValue === true;\n}\n","/* eslint-disable @typescript-eslint/no-namespace */\n'use strict';\n\nimport type { ReactTestInstance } from 'react-test-renderer';\nimport type {\n  AnimatedComponentProps,\n  IAnimatedComponentInternal,\n  InitialComponentProps,\n} from '../createAnimatedComponent/commonTypes';\nimport { isJest } from './PlatformChecker';\nimport type { DefaultStyle } from './hook/commonTypes';\n\ndeclare global {\n  namespace jest {\n    interface Matchers<R> {\n      toHaveAnimatedStyle(\n        style: Record<string, unknown>[] | Record<string, unknown>,\n        config?: {\n          shouldMatchAllProps?: boolean;\n        }\n      ): R;\n    }\n  }\n}\n\nconst defaultFramerateConfig = {\n  fps: 60,\n};\n\nconst getCurrentStyle = (component: TestComponent): DefaultStyle => {\n  const styleObject = component.props.style;\n  let currentStyle = {};\n  if (Array.isArray(styleObject)) {\n    styleObject.forEach((style) => {\n      currentStyle = {\n        ...currentStyle,\n        ...style,\n      };\n    });\n  } else {\n    currentStyle = {\n      ...styleObject,\n      ...component.props.jestAnimatedStyle?.value,\n    };\n  }\n  return currentStyle;\n};\n\nconst checkEqual = <Value>(current: Value, expected: Value) => {\n  if (Array.isArray(expected)) {\n    if (!Array.isArray(current) || expected.length !== current.length) {\n      return false;\n    }\n    for (let i = 0; i < current.length; i++) {\n      if (!checkEqual(current[i], expected[i])) {\n        return false;\n      }\n    }\n  } else if (typeof current === 'object' && current) {\n    if (typeof expected !== 'object' || !expected) {\n      return false;\n    }\n    for (const property in expected) {\n      if (!checkEqual(current[property], expected[property])) {\n        return false;\n      }\n    }\n  } else {\n    return current === expected;\n  }\n  return true;\n};\n\nconst findStyleDiff = (\n  current: DefaultStyle,\n  expected: DefaultStyle,\n  shouldMatchAllProps?: boolean\n) => {\n  const diffs = [];\n  let isEqual = true;\n  let property: keyof DefaultStyle;\n  for (property in expected) {\n    if (!checkEqual(current[property], expected[property])) {\n      isEqual = false;\n      diffs.push({\n        property,\n        current: current[property],\n        expect: expected[property],\n      });\n    }\n  }\n\n  if (\n    shouldMatchAllProps &&\n    Object.keys(current).length !== Object.keys(expected).length\n  ) {\n    isEqual = false;\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    let property: keyof DefaultStyle;\n    for (property in current) {\n      if (expected[property] === undefined) {\n        diffs.push({\n          property,\n          current: current[property],\n          expect: expected[property],\n        });\n      }\n    }\n  }\n\n  return { isEqual, diffs };\n};\n\nconst compareStyle = (\n  component: TestComponent,\n  expectedStyle: DefaultStyle,\n  config: ToHaveAnimatedStyleConfig\n) => {\n  if (!component.props.style) {\n    return { message: () => `Component doesn't have a style.`, pass: false };\n  }\n  const { shouldMatchAllProps } = config;\n  const currentStyle = getCurrentStyle(component);\n  const { isEqual, diffs } = findStyleDiff(\n    currentStyle,\n    expectedStyle,\n    shouldMatchAllProps\n  );\n\n  if (isEqual) {\n    return { message: () => 'ok', pass: true };\n  }\n\n  const currentStyleStr = JSON.stringify(currentStyle);\n  const expectedStyleStr = JSON.stringify(expectedStyle);\n  const differences = diffs\n    .map(\n      (diff) =>\n        `- '${diff.property}' should be ${JSON.stringify(\n          diff.expect\n        )}, but is ${JSON.stringify(diff.current)}`\n    )\n    .join('\\n');\n\n  return {\n    message: () =>\n      `Expected: ${expectedStyleStr}\\nReceived: ${currentStyleStr}\\n\\nDifferences:\\n${differences}`,\n    pass: false,\n  };\n};\n\nlet frameTime = Math.round(1000 / defaultFramerateConfig.fps);\n\nconst beforeTest = () => {\n  jest.useFakeTimers();\n};\n\nconst afterTest = () => {\n  jest.runOnlyPendingTimers();\n  jest.useRealTimers();\n};\n\nexport const withReanimatedTimer = (animationTest: () => void) => {\n  console.warn(\n    'This method is deprecated, you should define your own before and after test hooks to enable jest.useFakeTimers(). Check out the documentation for details on testing'\n  );\n  beforeTest();\n  animationTest();\n  afterTest();\n};\n\nexport const advanceAnimationByTime = (time = frameTime) => {\n  console.warn(\n    'This method is deprecated, use jest.advanceTimersByTime directly'\n  );\n  jest.advanceTimersByTime(time);\n  jest.runOnlyPendingTimers();\n};\n\nexport const advanceAnimationByFrame = (count: number) => {\n  console.warn(\n    'This method is deprecated, use jest.advanceTimersByTime directly'\n  );\n  jest.advanceTimersByTime(count * frameTime);\n  jest.runOnlyPendingTimers();\n};\n\nconst requireFunction = isJest()\n  ? require\n  : () => {\n      throw new Error(\n        '[Reanimated] `setUpTests` is available only in Jest environment.'\n      );\n    };\n\ntype ToHaveAnimatedStyleConfig = {\n  shouldMatchAllProps?: boolean;\n};\n\nexport const setUpTests = (userFramerateConfig = {}) => {\n  let expect: jest.Expect = (global as typeof global & { expect: jest.Expect })\n    .expect;\n  if (expect === undefined) {\n    const expectModule = requireFunction('expect');\n    expect = expectModule;\n    // Starting from Jest 28, \"expect\" package uses named exports instead of default export.\n    // So, requiring \"expect\" package doesn't give direct access to \"expect\" function anymore.\n    // It gives access to the module object instead.\n    // We use this info to detect if the project uses Jest 28 or higher.\n    if (typeof expect === 'object') {\n      const jestGlobals = requireFunction('@jest/globals');\n      expect = jestGlobals.expect;\n    }\n    if (expect === undefined || expect.extend === undefined) {\n      expect = expectModule.default;\n    }\n  }\n\n  const framerateConfig = {\n    ...defaultFramerateConfig,\n    ...userFramerateConfig,\n  };\n  frameTime = Math.round(1000 / framerateConfig.fps);\n\n  expect.extend({\n    toHaveAnimatedStyle(\n      component: React.Component<\n        AnimatedComponentProps<InitialComponentProps>\n      > &\n        IAnimatedComponentInternal,\n      expectedStyle: DefaultStyle,\n      config: ToHaveAnimatedStyleConfig = {}\n    ) {\n      return compareStyle(component, expectedStyle, config);\n    },\n  });\n};\n\ntype TestComponent = React.Component<\n  AnimatedComponentProps<InitialComponentProps> & {\n    jestAnimatedStyle?: { value: DefaultStyle };\n  }\n>;\n\nexport const getAnimatedStyle = (component: ReactTestInstance) => {\n  return getCurrentStyle(\n    // This type assertion is needed to get type checking in the following\n    // functions since `ReactTestInstance` has its `props` defined as `any`.\n    component as unknown as TestComponent\n  );\n};\n"],"names":["Object","value","exports","inputRange","outputRange","colorSpace","arguments","length","undefined","ColorSpace","RGB","options","useSharedValue","cache","makeMutable","anonymous","_Colors","require","_core","_interpolation","_useSharedValue","_worklet_14693378975429_init_data","Extrapolation","code","interpolateColorsHSV","colors","h","_options$useCorrected","useCorrectedHSVInterpolation","correctedInputRange","originalH","correctedH","i","d","push","interpolate","CLAMP","s","v","a","hsvToColor","__closure","__workletHash","__initData","_worklet_9548966570765_init_data","toLinearSpace","x","gamma","map","Math","pow","_worklet_12849438514316_init_data","toGammaSpace","round","_worklet_16236720403479_init_data","interpolateColorsRGB","_options$gamma","outputR","r","outputG","g","outputB","b","rgbaColor","_worklet_8695722846819_init_data","getInterpolateRGB","color","processedColor","processColor","red","green","blue","opacity","_worklet_14757969761783_init_data","getInterpolateHSV","processedHSVColor","RGBtoHSV","_worklet_15267273840583_init_data","interpolateColor","Error","_worklet_12947029934943_init_data","getVal","type","coef","val","leftEdgeOutput","rightEdgeOutput","IDENTITY","EXTEND","_worklet_9992753606300_init_data","isExtrapolate","_worklet_14909900493946_init_data","validateType","extrapolationConfig","extrapolateLeft","extrapolateRight","assign","_worklet_3513336466074_init_data","internalInterpolate","narrowedInput","leftEdgeInput","rightEdgeInput","_worklet_12904505828514_init_data","_worklet_1833118047486_init_data","clamp","min","max","_worklet_7960680803966_init_data","isSharedValue","_isReanimatedSharedValue","_PlatformChecker","defaultFramerateConfig","fps","getCurrentStyle","component","_component$props$jest","styleObject","props","style","currentStyle","Array","isArray","forEach","jestAnimatedStyle","checkEqual","current","expected","property","compareStyle","expectedStyle","config","message","pass","shouldMatchAllProps","_findStyleDiff","diffs","isEqual","expect","keys","findStyleDiff","currentStyleStr","JSON","stringify","expectedStyleStr","differences","diff","join","frameTime","requireFunction","animationTest","console","warn","jest","useFakeTimers","runOnlyPendingTimers","useRealTimers","time","advanceTimersByTime","count","isJest","userFramerateConfig","global","expectModule","extend","default","framerateConfig","toHaveAnimatedStyle"],"sourceRoot":""}