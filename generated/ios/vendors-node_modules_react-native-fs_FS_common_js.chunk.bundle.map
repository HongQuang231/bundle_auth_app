{"version":3,"file":"vendors-node_modules_react-native-fs_FS_common_js.chunk.bundle","mappings":"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","sources":["webpack:///./node_modules/react-native-fs/FS.common.js","webpack:///./node_modules/base-64/base64.js","webpack:///./node_modules/utf8/utf8.js"],"sourcesContent":["/**\n * React Native FS\n * @flow\n */\n\n'use strict';\n\n// This file supports both iOS and Android\n\nvar RNFSManager = require('react-native').NativeModules.RNFSManager;\n\nvar NativeEventEmitter = require('react-native').NativeEventEmitter;\n\nvar RNFS_NativeEventEmitter = new NativeEventEmitter(RNFSManager);\n\nvar base64 = require('base-64');\nvar utf8 = require('utf8');\nvar isIOS = require('react-native').Platform.OS === 'ios';\n\nvar RNFSFileTypeRegular = RNFSManager.RNFSFileTypeRegular;\nvar RNFSFileTypeDirectory = RNFSManager.RNFSFileTypeDirectory;\n\nvar jobId = 0;\n\nvar getJobId = () => {\n  jobId += 1;\n  return jobId;\n};\n\nvar normalizeFilePath = (path: string) => (path.startsWith('file://') ? path.slice(7) : path);\n\ntype MkdirOptions = {\n  NSURLIsExcludedFromBackupKey?: boolean; // iOS only\n  NSFileProtectionKey?: string; // IOS only\n};\n\ntype FileOptions = {\n  NSFileProtectionKey?: string; // IOS only\n};\n\ntype ReadDirItem = {\n  ctime: ?Date;    // The creation date of the file (iOS only)\n  mtime: ?Date;    // The last modified date of the file\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype StatResult = {\n  name: ?string;     // The name of the item TODO: why is this not documented?\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  mode: number;     // UNIX file mode\n  ctime: number;    // Created date\n  mtime: number;    // Last modified date\n  originalFilepath: string;    // In case of content uri this is the pointed file path, otherwise is the same as path\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype Headers = { [name: string]: string };\ntype Fields = { [name: string]: string };\n\ntype DownloadFileOptions = {\n  fromUrl: string;          // URL to download file from\n  toFile: string;           // Local filesystem path to save the file to\n  headers?: Headers;        // An object of headers to be passed to the server\n  background?: boolean;     // Continue the download in the background after the app terminates (iOS only)\n  discretionary?: boolean;  // Allow the OS to control the timing and speed of the download to improve perceived performance  (iOS only)\n  cacheable?: boolean;      // Whether the download can be stored in the shared NSURLCache (iOS only)\n  progressInterval?: number;\n  progressDivider?: number;\n  begin?: (res: DownloadBeginCallbackResult) => void;\n  progress?: (res: DownloadProgressCallbackResult) => void;\n  resumable?: () => void;    // only supported on iOS yet\n  connectionTimeout?: number; // only supported on Android yet\n  readTimeout?: number;       // supported on Android and iOS\n  backgroundTimeout?: number; // Maximum time (in milliseconds) to download an entire resource (iOS only, useful for timing out background downloads)\n};\n\ntype DownloadBeginCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  contentLength: number;  // The total size in bytes of the download resource\n  headers: Headers;       // The HTTP response headers from the server\n};\n\ntype DownloadProgressCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  contentLength: number;  // The total size in bytes of the download resource\n  bytesWritten: number;   // The number of bytes written to the file so far\n};\n\ntype DownloadResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  bytesWritten: number;   // The number of bytes written to the file\n};\n\ntype UploadFileOptions = {\n  toUrl: string;            // URL to upload file to\n  binaryStreamOnly?: boolean; // Allow for binary data stream for file to be uploaded without extra headers, Default is 'false'\n  files: UploadFileItem[];  // An array of objects with the file information to be uploaded.\n  headers?: Headers;        // An object of headers to be passed to the server\n  fields?: Fields;          // An object of fields to be passed to the server\n  method?: string;          // Default is 'POST', supports 'POST' and 'PUT'\n  beginCallback?: (res: UploadBeginCallbackResult) => void; // deprecated\n  progressCallback?: (res: UploadProgressCallbackResult) => void; // deprecated\n  begin?: (res: UploadBeginCallbackResult) => void;\n  progress?: (res: UploadProgressCallbackResult) => void;\n};\n\ntype UploadFileItem = {\n  name: string;       // Name of the file, if not defined then filename is used\n  filename: string;   // Name of file\n  filepath: string;   // Path to file\n  filetype: string;   // The mimetype of the file to be uploaded, if not defined it will get mimetype from `filepath` extension\n};\n\ntype UploadBeginCallbackResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n};\n\ntype UploadProgressCallbackResult = {\n  jobId: number;                      // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  totalBytesExpectedToSend: number;   // The total number of bytes that will be sent to the server\n  totalBytesSent: number;             // The number of bytes sent to the server\n};\n\ntype UploadResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  statusCode: number;   // The HTTP status code\n  headers: Headers;     // The HTTP response headers from the server\n  body: string;         // The HTTP response body\n};\n\ntype FSInfoResult = {\n  totalSpace: number;   // The total amount of storage space on the device (in bytes).\n  freeSpace: number;    // The amount of available storage space on the device (in bytes).\n};\n\n/**\n * Generic function used by readFile and readFileAssets\n */\nfunction readFileGeneric(filepath: string, encodingOrOptions: ?string, command: Function) {\n  var options = {\n    encoding: 'utf8'\n  };\n\n  if (encodingOrOptions) {\n    if (typeof encodingOrOptions === 'string') {\n      options.encoding = encodingOrOptions;\n    } else if (typeof encodingOrOptions === 'object') {\n      options = encodingOrOptions;\n    }\n  }\n\n  return command(normalizeFilePath(filepath)).then((b64) => {\n    var contents;\n\n    if (options.encoding === 'utf8') {\n      contents = utf8.decode(base64.decode(b64));\n    } else if (options.encoding === 'ascii') {\n      contents = base64.decode(b64);\n    } else if (options.encoding === 'base64') {\n      contents = b64;\n    } else {\n      throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n    }\n\n    return contents;\n  });\n}\n\n/**\n * Generic function used by readDir and readDirAssets\n */\nfunction readDirGeneric(dirpath: string, command: Function) {\n  return command(normalizeFilePath(dirpath)).then(files => {\n    return files.map(file => ({\n      ctime: file.ctime && new Date(file.ctime * 1000) || null,\n      mtime: file.mtime && new Date(file.mtime * 1000) || null,\n      name: file.name,\n      path: file.path,\n      size: file.size,\n      isFile: () => file.type === RNFSFileTypeRegular,\n      isDirectory: () => file.type === RNFSFileTypeDirectory,\n    }));\n  });\n}\n\nvar RNFS = {\n\n  mkdir(filepath: string, options: MkdirOptions = {}): Promise<void> {\n    return RNFSManager.mkdir(normalizeFilePath(filepath), options).then(() => void 0);\n  },\n\n  moveFile(filepath: string, destPath: string, options: FileOptions = {}): Promise<void> {\n    return RNFSManager.moveFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(() => void 0);\n  },\n\n  copyFile(filepath: string, destPath: string, options: FileOptions = {}): Promise<void> {\n    return RNFSManager.copyFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(() => void 0);\n  },\n\n  pathForBundle(bundleNamed: string): Promise<string> {\n    return RNFSManager.pathForBundle(bundleNamed);\n  },\n\n  pathForGroup(groupName: string): Promise<string> {\n    return RNFSManager.pathForGroup(groupName);\n  },\n\n  getFSInfo(): Promise<FSInfoResult> {\n    return RNFSManager.getFSInfo();\n  },\n\n  getAllExternalFilesDirs(): Promise<string> {\n    return RNFSManager.getAllExternalFilesDirs();\n  },\n\n  unlink(filepath: string): Promise<void> {\n    return RNFSManager.unlink(normalizeFilePath(filepath)).then(() => void 0);\n  },\n\n  exists(filepath: string): Promise<boolean> {\n    return RNFSManager.exists(normalizeFilePath(filepath));\n  },\n\n  stopDownload(jobId: number): void {\n    RNFSManager.stopDownload(jobId);\n  },\n\n  resumeDownload(jobId: number): void {\n    RNFSManager.resumeDownload(jobId);\n  },\n\n  isResumable(jobId: number): Promise<bool> {\n    return RNFSManager.isResumable(jobId);\n  },\n\n  stopUpload(jobId: number): void {\n    RNFSManager.stopUpload(jobId);\n  },\n\n  completeHandlerIOS(jobId: number): void {\n    return RNFSManager.completeHandlerIOS(jobId);\n  },\n\n  readDir(dirpath: string): Promise<ReadDirItem[]> {\n    return readDirGeneric(dirpath, RNFSManager.readDir);\n  },\n\n  // Android-only\n  readDirAssets(dirpath: string): Promise<ReadDirItem[]> {\n    if (!RNFSManager.readDirAssets) {\n      throw new Error('readDirAssets is not available on this platform');\n    }\n    return readDirGeneric(dirpath, RNFSManager.readDirAssets);\n  },\n\n  // Android-only\n  existsAssets(filepath: string) {\n    if (!RNFSManager.existsAssets) {\n      throw new Error('existsAssets is not available on this platform');\n    }\n    return RNFSManager.existsAssets(filepath);\n  },\n\n  // Android-only\n  existsRes(filename: string) {\n    if (!RNFSManager.existsRes) {\n      throw new Error('existsRes is not available on this platform');\n    }\n    return RNFSManager.existsRes(filename);\n  },\n\n  // Node style version (lowercase d). Returns just the names\n  readdir(dirpath: string): Promise<string[]> {\n    return RNFS.readDir(normalizeFilePath(dirpath)).then(files => {\n      return files.map(file => file.name);\n    });\n  },\n\n  // setReadable for Android\n  setReadable(filepath: string, readable: boolean, ownerOnly: boolean): Promise<boolean> {\n    return RNFSManager.setReadable(filepath, readable, ownerOnly).then((result) => {\n      return result;\n    })\n  },\n\n  stat(filepath: string): Promise<StatResult> {\n    return RNFSManager.stat(normalizeFilePath(filepath)).then((result) => {\n      return {\n        'path': filepath,\n        'ctime': new Date(result.ctime * 1000),\n        'mtime': new Date(result.mtime * 1000),\n        'size': result.size,\n        'mode': result.mode,\n        'originalFilepath': result.originalFilepath,\n        isFile: () => result.type === RNFSFileTypeRegular,\n        isDirectory: () => result.type === RNFSFileTypeDirectory,\n      };\n    });\n  },\n\n  readFile(filepath: string, encodingOrOptions?: any): Promise<string> {\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFile);\n  },\n\n  read(filepath: string, length: number = 0, position: number = 0, encodingOrOptions?: any): Promise<string> {\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    return RNFSManager.read(normalizeFilePath(filepath), length, position).then((b64) => {\n      var contents;\n\n      if (options.encoding === 'utf8') {\n        contents = utf8.decode(base64.decode(b64));\n      } else if (options.encoding === 'ascii') {\n        contents = base64.decode(b64);\n      } else if (options.encoding === 'base64') {\n        contents = b64;\n      } else {\n        throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n      }\n\n      return contents;\n    });\n  },\n\n  // Android only\n  readFileAssets(filepath: string, encodingOrOptions?: any): Promise<string> {\n    if (!RNFSManager.readFileAssets) {\n      throw new Error('readFileAssets is not available on this platform');\n    }\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFileAssets);\n  },\n\n  // Android only\n  readFileRes(filename: string, encodingOrOptions?: any): Promise<string> {\n    if (!RNFSManager.readFileRes) {\n      throw new Error('readFileRes is not available on this platform');\n    }\n    return readFileGeneric(filename, encodingOrOptions, RNFSManager.readFileRes);\n  },\n\n  hash(filepath: string, algorithm: string): Promise<string> {\n    return RNFSManager.hash(normalizeFilePath(filepath), algorithm);\n  },\n\n  // Android only\n  copyFileAssets(filepath: string, destPath: string) {\n    if (!RNFSManager.copyFileAssets) {\n      throw new Error('copyFileAssets is not available on this platform');\n    }\n    return RNFSManager.copyFileAssets(normalizeFilePath(filepath), normalizeFilePath(destPath)).then(() => void 0);\n  },\n\n  // Android only\n  copyFileRes(filename: string, destPath: string) {\n    if (!RNFSManager.copyFileRes) {\n      throw new Error('copyFileRes is not available on this platform');\n    }\n    return RNFSManager.copyFileRes(filename, normalizeFilePath(destPath)).then(() => void 0);\n  },\n\n  // iOS only\n  // Copies fotos from asset-library (camera-roll) to a specific location\n  // with a given width or height\n  // @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n  copyAssetsFileIOS(imageUri: string, destPath: string, width: number, height: number,\n    scale: number = 1.0, compression: number = 1.0, resizeMode: string = 'contain'): Promise<string> {\n    return RNFSManager.copyAssetsFileIOS(imageUri, destPath, width, height, scale, compression, resizeMode);\n  },\n\n  // iOS only\n  // Copies fotos from asset-library (camera-roll) to a specific location\n  // with a given width or height\n  // @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n  copyAssetsVideoIOS(imageUri: string, destPath: string): Promise<string> {\n    return RNFSManager.copyAssetsVideoIOS(imageUri, destPath);\n  },\n\n  writeFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = {\n          ...options,\n          ...encodingOrOptions\n        };\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.writeFile(normalizeFilePath(filepath), b64, options).then(() => void 0);\n  },\n\n  appendFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.appendFile(normalizeFilePath(filepath), b64);\n  },\n\n  write(filepath: string, contents: string, position?: number, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    if (position === undefined) {\n      position = -1;\n    }\n\n    return RNFSManager.write(normalizeFilePath(filepath), b64, position).then(() => void 0);\n  },\n\n  downloadFile(options: DownloadFileOptions): { jobId: number, promise: Promise<DownloadResult> } {\n    if (typeof options !== 'object') throw new Error('downloadFile: Invalid value for argument `options`');\n    if (typeof options.fromUrl !== 'string') throw new Error('downloadFile: Invalid value for property `fromUrl`');\n    if (typeof options.toFile !== 'string') throw new Error('downloadFile: Invalid value for property `toFile`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('downloadFile: Invalid value for property `headers`');\n    if (options.background && typeof options.background !== 'boolean') throw new Error('downloadFile: Invalid value for property `background`');\n    if (options.progressDivider && typeof options.progressDivider !== 'number') throw new Error('downloadFile: Invalid value for property `progressDivider`');\n    if (options.progressInterval && typeof options.progressInterval !== 'number') throw new Error('downloadFile: Invalid value for property `progressInterval`');\n    if (options.readTimeout && typeof options.readTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `readTimeout`');\n    if (options.connectionTimeout && typeof options.connectionTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `connectionTimeout`');\n    if (options.backgroundTimeout && typeof options.backgroundTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `backgroundTimeout`');\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadBegin', (res) => {\n        if (res.jobId === jobId) options.begin(res);\n      }));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadProgress', (res) => {\n        if (res.jobId === jobId) options.progress(res);\n      }));\n    }\n\n    if (options.resumable) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadResumable', (res) => {\n        if (res.jobId === jobId) options.resumable(res);\n      }));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      fromUrl: options.fromUrl,\n      toFile: normalizeFilePath(options.toFile),\n      headers: options.headers || {},\n      background: !!options.background,\n      progressDivider: options.progressDivider || 0,\n      progressInterval: options.progressInterval || 0,\n      readTimeout: options.readTimeout || 15000,\n      connectionTimeout: options.connectionTimeout || 5000,\n      backgroundTimeout: options.backgroundTimeout || 3600000, // 1 hour\n      hasBeginCallback: options.begin instanceof Function,\n      hasProgressCallback: options.progress instanceof Function,\n      hasResumableCallback: options.resumable instanceof Function,\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.downloadFile(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n        .catch(e => {\n          return Promise.reject(e);\n        })\n    };\n  },\n\n  uploadFiles(options: UploadFileOptions): { jobId: number, promise: Promise<UploadResult> } {\n    if (!RNFSManager.uploadFiles) {\n      return {\n        jobId: -1,\n        promise: Promise.reject(new Error('`uploadFiles` is unsupported on this platform'))\n      };\n    }\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (typeof options !== 'object') throw new Error('uploadFiles: Invalid value for argument `options`');\n    if (typeof options.toUrl !== 'string') throw new Error('uploadFiles: Invalid value for property `toUrl`');\n    if (!Array.isArray(options.files)) throw new Error('uploadFiles: Invalid value for property `files`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('uploadFiles: Invalid value for property `headers`');\n    if (options.fields && typeof options.fields !== 'object') throw new Error('uploadFiles: Invalid value for property `fields`');\n    if (options.method && typeof options.method !== 'string') throw new Error('uploadFiles: Invalid value for property `method`');\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.begin));\n    } else if (options.beginCallback) {\n      // Deprecated\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.beginCallback));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progress));\n    } else if (options.progressCallback) {\n      // Deprecated\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progressCallback));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      toUrl: options.toUrl,\n      files: options.files,\n      binaryStreamOnly: options.binaryStreamOnly || false,\n      headers: options.headers || {},\n      fields: options.fields || {},\n      method: options.method || 'POST',\n      hasBeginCallback: options.begin instanceof Function || options.beginCallback instanceof Function,\n      hasProgressCallback: options.progress instanceof Function || options.progressCallback instanceof Function,\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.uploadFiles(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n    };\n  },\n\n  touch(filepath: string, mtime?: Date, ctime?: Date): Promise<void> {\n    if (ctime && !(ctime instanceof Date)) throw new Error('touch: Invalid value for argument `ctime`');\n    if (mtime && !(mtime instanceof Date)) throw new Error('touch: Invalid value for argument `mtime`');\n    var ctimeTime = 0;\n    if (isIOS) {\n      ctimeTime = ctime && ctime.getTime();\n    }\n    return RNFSManager.touch(\n      normalizeFilePath(filepath),\n      mtime && mtime.getTime(),\n      ctimeTime\n    );\n  },\n\n  scanFile(path: string): Promise<ReadDirItem[]> {\n    return RNFSManager.scanFile(path);\n  },\n\n  MainBundlePath: RNFSManager.RNFSMainBundlePath,\n  CachesDirectoryPath: RNFSManager.RNFSCachesDirectoryPath,\n  ExternalCachesDirectoryPath: RNFSManager.RNFSExternalCachesDirectoryPath,\n  DocumentDirectoryPath: RNFSManager.RNFSDocumentDirectoryPath,\n  DownloadDirectoryPath: RNFSManager.RNFSDownloadDirectoryPath,\n  ExternalDirectoryPath: RNFSManager.RNFSExternalDirectoryPath,\n  ExternalStorageDirectoryPath: RNFSManager.RNFSExternalStorageDirectoryPath,\n  TemporaryDirectoryPath: RNFSManager.RNFSTemporaryDirectoryPath,\n  LibraryDirectoryPath: RNFSManager.RNFSLibraryDirectoryPath,\n  PicturesDirectoryPath: RNFSManager.RNFSPicturesDirectoryPath,\n  FileProtectionKeys: RNFSManager.RNFSFileProtectionKeys\n};\n\nmodule.exports = RNFS;\n","/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code, and use\n\t// it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar InvalidCharacterError = function(message) {\n\t\tthis.message = message;\n\t};\n\tInvalidCharacterError.prototype = new Error;\n\tInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n\tvar error = function(message) {\n\t\t// Note: the error messages used throughout this file match those used by\n\t\t// the native `atob`/`btoa` implementation in Chromium.\n\t\tthrow new InvalidCharacterError(message);\n\t};\n\n\tvar TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t// http://whatwg.org/html/common-microsyntaxes.html#space-character\n\tvar REGEX_SPACE_CHARACTERS = /[\\t\\n\\f\\r ]/g;\n\n\t// `decode` is designed to be fully compatible with `atob` as described in the\n\t// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob\n\t// The optimized base64-decoding algorithm used is based on @atk’s excellent\n\t// implementation. https://gist.github.com/atk/1020396\n\tvar decode = function(input) {\n\t\tinput = String(input)\n\t\t\t.replace(REGEX_SPACE_CHARACTERS, '');\n\t\tvar length = input.length;\n\t\tif (length % 4 == 0) {\n\t\t\tinput = input.replace(/==?$/, '');\n\t\t\tlength = input.length;\n\t\t}\n\t\tif (\n\t\t\tlength % 4 == 1 ||\n\t\t\t// http://whatwg.org/C#alphanumeric-ascii-characters\n\t\t\t/[^+a-zA-Z0-9/]/.test(input)\n\t\t) {\n\t\t\terror(\n\t\t\t\t'Invalid character: the string to be decoded is not correctly encoded.'\n\t\t\t);\n\t\t}\n\t\tvar bitCounter = 0;\n\t\tvar bitStorage;\n\t\tvar buffer;\n\t\tvar output = '';\n\t\tvar position = -1;\n\t\twhile (++position < length) {\n\t\t\tbuffer = TABLE.indexOf(input.charAt(position));\n\t\t\tbitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;\n\t\t\t// Unless this is the first of a group of 4 characters…\n\t\t\tif (bitCounter++ % 4) {\n\t\t\t\t// …convert the first 8 bits to a single ASCII character.\n\t\t\t\toutput += String.fromCharCode(\n\t\t\t\t\t0xFF & bitStorage >> (-2 * bitCounter & 6)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t};\n\n\t// `encode` is designed to be fully compatible with `btoa` as described in the\n\t// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa\n\tvar encode = function(input) {\n\t\tinput = String(input);\n\t\tif (/[^\\0-\\xFF]/.test(input)) {\n\t\t\t// Note: no need to special-case astral symbols here, as surrogates are\n\t\t\t// matched, and the input is supposed to only contain ASCII anyway.\n\t\t\terror(\n\t\t\t\t'The string to be encoded contains characters outside of the ' +\n\t\t\t\t'Latin1 range.'\n\t\t\t);\n\t\t}\n\t\tvar padding = input.length % 3;\n\t\tvar output = '';\n\t\tvar position = -1;\n\t\tvar a;\n\t\tvar b;\n\t\tvar c;\n\t\tvar d;\n\t\tvar buffer;\n\t\t// Make sure any padding is handled outside of the loop.\n\t\tvar length = input.length - padding;\n\n\t\twhile (++position < length) {\n\t\t\t// Read three bytes, i.e. 24 bits.\n\t\t\ta = input.charCodeAt(position) << 16;\n\t\t\tb = input.charCodeAt(++position) << 8;\n\t\t\tc = input.charCodeAt(++position);\n\t\t\tbuffer = a + b + c;\n\t\t\t// Turn the 24 bits into four chunks of 6 bits each, and append the\n\t\t\t// matching character for each of them to the output.\n\t\t\toutput += (\n\t\t\t\tTABLE.charAt(buffer >> 18 & 0x3F) +\n\t\t\t\tTABLE.charAt(buffer >> 12 & 0x3F) +\n\t\t\t\tTABLE.charAt(buffer >> 6 & 0x3F) +\n\t\t\t\tTABLE.charAt(buffer & 0x3F)\n\t\t\t);\n\t\t}\n\n\t\tif (padding == 2) {\n\t\t\ta = input.charCodeAt(position) << 8;\n\t\t\tb = input.charCodeAt(++position);\n\t\t\tbuffer = a + b;\n\t\t\toutput += (\n\t\t\t\tTABLE.charAt(buffer >> 10) +\n\t\t\t\tTABLE.charAt((buffer >> 4) & 0x3F) +\n\t\t\t\tTABLE.charAt((buffer << 2) & 0x3F) +\n\t\t\t\t'='\n\t\t\t);\n\t\t} else if (padding == 1) {\n\t\t\tbuffer = input.charCodeAt(position);\n\t\t\toutput += (\n\t\t\t\tTABLE.charAt(buffer >> 2) +\n\t\t\t\tTABLE.charAt((buffer << 4) & 0x3F) +\n\t\t\t\t'=='\n\t\t\t);\n\t\t}\n\n\t\treturn output;\n\t};\n\n\tvar base64 = {\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'version': '0.1.0'\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn base64;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = base64;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in base64) {\n\t\t\t\tbase64.hasOwnProperty(key) && (freeExports[key] = base64[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.base64 = base64;\n\t}\n\n}(this));\n","/*! https://mths.be/utf8js v3.0.0 by @mathias */\n;(function(root) {\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\troot.version = '3.0.0';\n\troot.encode = utf8encode;\n\troot.decode = utf8decode;\n\n}(typeof exports === 'undefined' ? this.utf8 = {} : exports));\n"],"names":["RNFSManager","require","RNFS_NativeEventEmitter","NativeEventEmitter","base64","utf8","isIOS","OS","RNFSFileTypeRegular","RNFSFileTypeDirectory","jobId","getJobId","normalizeFilePath","path","startsWith","slice","readFileGeneric","filepath","encodingOrOptions","command","options","encoding","then","b64","contents","decode","Error","String","readDirGeneric","dirpath","files","map","file","ctime","Date","mtime","name","size","isFile","type","isDirectory","RNFS","mkdir","arguments","length","undefined","moveFile","destPath","copyFile","pathForBundle","bundleNamed","pathForGroup","groupName","getFSInfo","getAllExternalFilesDirs","unlink","exists","stopDownload","resumeDownload","isResumable","stopUpload","completeHandlerIOS","readDir","readDirAssets","existsAssets","existsRes","filename","readdir","setReadable","readable","ownerOnly","result","stat","mode","originalFilepath","readFile","read","position","readFileAssets","readFileRes","hash","algorithm","copyFileAssets","copyFileRes","copyAssetsFileIOS","imageUri","width","height","scale","compression","resizeMode","copyAssetsVideoIOS","writeFile","Object","assign","encode","appendFile","write","downloadFile","fromUrl","toFile","headers","background","progressDivider","progressInterval","readTimeout","connectionTimeout","backgroundTimeout","subscriptions","begin","push","addListener","res","progress","resumable","bridgeOptions","hasBeginCallback","Function","hasProgressCallback","hasResumableCallback","promise","forEach","sub","remove","catch","e","Promise","reject","uploadFiles","toUrl","Array","isArray","fields","method","beginCallback","progressCallback","binaryStreamOnly","touch","ctimeTime","getTime","scanFile","MainBundlePath","RNFSMainBundlePath","CachesDirectoryPath","RNFSCachesDirectoryPath","ExternalCachesDirectoryPath","RNFSExternalCachesDirectoryPath","DocumentDirectoryPath","RNFSDocumentDirectoryPath","DownloadDirectoryPath","RNFSDownloadDirectoryPath","ExternalDirectoryPath","RNFSExternalDirectoryPath","ExternalStorageDirectoryPath","RNFSExternalStorageDirectoryPath","TemporaryDirectoryPath","RNFSTemporaryDirectoryPath","LibraryDirectoryPath","RNFSLibraryDirectoryPath","PicturesDirectoryPath","RNFSPicturesDirectoryPath","FileProtectionKeys","RNFSFileProtectionKeys","module","exports","root","freeExports","freeGlobal","g","global","window","InvalidCharacterError","message","this","prototype","error","TABLE","REGEX_SPACE_CHARACTERS","input","test","a","b","c","buffer","padding","output","charCodeAt","charAt","replace","bitStorage","bitCounter","indexOf","fromCharCode","byteArray","byteCount","byteIndex","stringFromCharCode","ucs2decode","string","value","extra","counter","checkScalarValue","codePoint","toString","toUpperCase","createByte","shift","encodeCodePoint","symbol","readContinuationByte","continuationByte","decodeSymbol","byte1","version","codePoints","index","byteString","tmp","array","ucs2encode"],"sourceRoot":""}