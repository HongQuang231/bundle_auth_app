{"version":3,"file":"node_modules_react-redux_dist_react-redux_legacy-esm_js-_17430.chunk.bundle","mappings":"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","sources":["webpack:///../src/index.ts","webpack:///../src/utils/react.ts","webpack:///../src/components/Context.ts","webpack:///../src/utils/useSyncExternalStore.ts","webpack:///../src/hooks/useReduxContext.ts","webpack:///../src/hooks/useSelector.ts","webpack:///../src/utils/react-is.ts","webpack:///../src/connect/selectorFactory.ts","webpack:///../src/connect/wrapMapToProps.ts","webpack:///../src/connect/invalidArgFactory.ts","webpack:///../src/connect/mergeProps.ts","webpack:///../src/utils/batch.ts","webpack:///../src/utils/Subscription.ts","webpack:///../src/utils/useIsomorphicLayoutEffect.ts","webpack:///../src/utils/shallowEqual.ts","webpack:///../src/utils/hoistStatics.ts","webpack:///../src/components/connect.tsx","webpack:///../src/connect/mapStateToProps.ts","webpack:///../src/connect/mapDispatchToProps.ts","webpack:///../src/utils/bindActionCreators.ts","webpack:///../src/components/Provider.tsx","webpack:///../src/hooks/useStore.ts","webpack:///../src/hooks/useDispatch.ts","webpack:///../src/exports.ts","webpack:///./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.min.js","webpack:///./node_modules/use-sync-external-store/with-selector.js","webpack:///./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack:///./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js","webpack:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js","webpack:///./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack:///./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack:///./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack:///./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack:///./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack:///./node_modules/@babel/runtime/helpers/toPrimitive.js","webpack:///./node_modules/@babel/runtime/helpers/toPropertyKey.js","webpack:///./node_modules/@babel/runtime/helpers/typeof.js","webpack:///./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"],"sourcesContent":["// The primary entry point assumes we are working with React 18, and thus have\r\n// useSyncExternalStore available. We can import that directly from React itself.\r\n// The useSyncExternalStoreWithSelector has to be imported, but we can use the\r\n// non-shim version. This shaves off the byte size of the shim.\r\n\r\nimport * as React from 'react'\r\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector.js'\r\n\r\nimport { initializeUseSelector } from './hooks/useSelector'\r\nimport { initializeConnect } from './components/connect'\r\n\r\ninitializeUseSelector(useSyncExternalStoreWithSelector)\r\ninitializeConnect(React.useSyncExternalStore)\r\n\r\nexport * from './exports'\r\n","import * as ReactOriginal from 'react'\r\nimport type * as ReactNamespace from 'react'\r\n\r\nexport const React: typeof ReactNamespace =\r\n  // prettier-ignore\r\n  // @ts-ignore\r\n  'default' in ReactOriginal ? ReactOriginal['default'] : ReactOriginal as any\r\n","import type { Context } from 'react'\nimport { React } from '../utils/react'\nimport type { Action, Store, UnknownAction } from 'redux'\nimport type { Subscription } from '../utils/Subscription'\nimport type { ProviderProps } from './Provider'\n\nexport interface ReactReduxContextValue<\n  SS = any,\n  A extends Action<string> = UnknownAction,\n> extends Pick<ProviderProps, 'stabilityCheck' | 'identityFunctionCheck'> {\n  store: Store<SS, A>\n  subscription: Subscription\n  getServerState?: () => SS\n}\n\nconst ContextKey = Symbol.for(`react-redux-context`)\nconst gT: {\n  [ContextKey]?: Map<\n    typeof React.createContext,\n    Context<ReactReduxContextValue | null>\n  >\n} = (\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {}\n) as any\n\nfunction getContext(): Context<ReactReduxContextValue | null> {\n  if (!React.createContext) return {} as any\n\n  const contextMap = (gT[ContextKey] ??= new Map<\n    typeof React.createContext,\n    Context<ReactReduxContextValue | null>\n  >())\n  let realContext = contextMap.get(React.createContext)\n  if (!realContext) {\n    realContext = React.createContext<ReactReduxContextValue | null>(\n      null as any,\n    )\n    if (process.env.NODE_ENV !== 'production') {\n      realContext.displayName = 'ReactRedux'\n    }\n    contextMap.set(React.createContext, realContext)\n  }\n  return realContext\n}\n\nexport const ReactReduxContext = /*#__PURE__*/ getContext()\n\nexport type ReactReduxContextInstance = typeof ReactReduxContext\n\nexport default ReactReduxContext\n","import type { useSyncExternalStore } from 'use-sync-external-store'\r\nimport type { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector'\r\n\r\nexport const notInitialized = () => {\r\n  throw new Error('uSES not initialized!')\r\n}\r\n\r\nexport type uSES = typeof useSyncExternalStore\r\nexport type uSESWS = typeof useSyncExternalStoreWithSelector\r\n","import { React } from '../utils/react'\nimport { ReactReduxContext } from '../components/Context'\nimport type { ReactReduxContextValue } from '../components/Context'\n\n/**\n * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useReduxContext` hook bound to the specified context.\n */\nexport function createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext(): ReactReduxContextValue {\n    const contextValue = React.useContext(context)\n\n    if (process.env.NODE_ENV !== 'production' && !contextValue) {\n      throw new Error(\n        'could not find react-redux context value; please ensure the component is wrapped in a <Provider>',\n      )\n    }\n\n    return contextValue!\n  }\n}\n\n/**\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @returns {any} the value of the `ReactReduxContext`\n *\n * @example\n *\n * import React from 'react'\n * import { useReduxContext } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const { store } = useReduxContext()\n *   return <div>{store.getState()}</div>\n * }\n */\nexport const useReduxContext = /*#__PURE__*/ createReduxContextHook()\n","//import * as React from 'react'\nimport { React } from '../utils/react'\n\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport type { EqualityFn, NoInfer } from '../types'\nimport type { uSESWS } from '../utils/useSyncExternalStore'\nimport { notInitialized } from '../utils/useSyncExternalStore'\nimport {\n  createReduxContextHook,\n  useReduxContext as useDefaultReduxContext,\n} from './useReduxContext'\n\n/**\n * The frequency of development mode checks.\n *\n * @since 8.1.0\n * @internal\n */\nexport type DevModeCheckFrequency = 'never' | 'once' | 'always'\n\n/**\n * Represents the configuration for development mode checks.\n *\n * @since 9.0.0\n * @internal\n */\nexport interface DevModeChecks {\n  /**\n   * Overrides the global stability check for the selector.\n   * - `once` - Run only the first time the selector is called.\n   * - `always` - Run every time the selector is called.\n   * - `never` - Never run the stability check.\n   *\n   * @default 'once'\n   *\n   * @since 8.1.0\n   */\n  stabilityCheck: DevModeCheckFrequency\n\n  /**\n   * Overrides the global identity function check for the selector.\n   * - `once` - Run only the first time the selector is called.\n   * - `always` - Run every time the selector is called.\n   * - `never` - Never run the identity function check.\n   *\n   * **Note**: Previously referred to as `noopCheck`.\n   *\n   * @default 'once'\n   *\n   * @since 9.0.0\n   */\n  identityFunctionCheck: DevModeCheckFrequency\n}\n\nexport interface UseSelectorOptions<Selected = unknown> {\n  equalityFn?: EqualityFn<Selected>\n\n  /**\n   * `useSelector` performs additional checks in development mode to help\n   * identify and warn about potential issues in selector behavior. This\n   * option allows you to customize the behavior of these checks per selector.\n   *\n   * @since 9.0.0\n   */\n  devModeChecks?: Partial<DevModeChecks>\n}\n\n/**\n * Represents a custom hook that allows you to extract data from the\n * Redux store state, using a selector function. The selector function\n * takes the current state as an argument and returns a part of the state\n * or some derived data. The hook also supports an optional equality\n * function or options object to customize its behavior.\n *\n * @template StateType - The specific type of state this hook operates on.\n *\n * @public\n */\nexport interface UseSelector<StateType = unknown> {\n  /**\n   * A function that takes a selector function as its first argument.\n   * The selector function is responsible for selecting a part of\n   * the Redux store's state or computing derived data.\n   *\n   * @param selector - A function that receives the current state and returns a part of the state or some derived data.\n   * @param equalityFnOrOptions - An optional equality function or options object for customizing the behavior of the selector.\n   * @returns The selected part of the state or derived data.\n   *\n   * @template TState - The specific type of state this hook operates on.\n   * @template Selected - The type of the value that the selector function will return.\n   */\n  <TState extends StateType = StateType, Selected = unknown>(\n    selector: (state: TState) => Selected,\n    equalityFnOrOptions?: EqualityFn<Selected> | UseSelectorOptions<Selected>,\n  ): Selected\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useSelector useSelector}\n   * where the `state` type is predefined.\n   *\n   * This allows you to set the `state` type once, eliminating the need to\n   * specify it with every {@linkcode useSelector useSelector} call.\n   *\n   * @returns A pre-typed `useSelector` with the state type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppSelector = useSelector.withTypes<RootState>()\n   * ```\n   *\n   * @template OverrideStateType - The specific type of state this hook operates on.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideStateType extends StateType,\n  >() => UseSelector<OverrideStateType>\n}\n\nlet useSyncExternalStoreWithSelector = notInitialized as uSESWS\nexport const initializeUseSelector = (fn: uSESWS) => {\n  useSyncExternalStoreWithSelector = fn\n}\n\nconst refEquality: EqualityFn<any> = (a, b) => a === b\n\n/**\n * Hook factory, which creates a `useSelector` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useSelector` hook bound to the specified context.\n */\nexport function createSelectorHook(\n  context: React.Context<ReactReduxContextValue<\n    any,\n    any\n  > | null> = ReactReduxContext,\n): UseSelector {\n  const useReduxContext =\n    context === ReactReduxContext\n      ? useDefaultReduxContext\n      : createReduxContextHook(context)\n\n  const useSelector = <TState, Selected extends unknown>(\n    selector: (state: TState) => Selected,\n    equalityFnOrOptions:\n      | EqualityFn<NoInfer<Selected>>\n      | UseSelectorOptions<NoInfer<Selected>> = {},\n  ): Selected => {\n    const { equalityFn = refEquality, devModeChecks = {} } =\n      typeof equalityFnOrOptions === 'function'\n        ? { equalityFn: equalityFnOrOptions }\n        : equalityFnOrOptions\n    if (process.env.NODE_ENV !== 'production') {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`)\n      }\n      if (typeof selector !== 'function') {\n        throw new Error(`You must pass a function as a selector to useSelector`)\n      }\n      if (typeof equalityFn !== 'function') {\n        throw new Error(\n          `You must pass a function as an equality function to useSelector`,\n        )\n      }\n    }\n\n    const {\n      store,\n      subscription,\n      getServerState,\n      stabilityCheck,\n      identityFunctionCheck,\n    } = useReduxContext()\n\n    const firstRun = React.useRef(true)\n\n    const wrappedSelector = React.useCallback<typeof selector>(\n      {\n        [selector.name](state: TState) {\n          const selected = selector(state)\n          if (process.env.NODE_ENV !== 'production') {\n            const {\n              identityFunctionCheck: finalIdentityFunctionCheck,\n              stabilityCheck: finalStabilityCheck,\n            } = {\n              stabilityCheck,\n              identityFunctionCheck,\n              ...devModeChecks,\n            }\n            if (\n              finalStabilityCheck === 'always' ||\n              (finalStabilityCheck === 'once' && firstRun.current)\n            ) {\n              const toCompare = selector(state)\n              if (!equalityFn(selected, toCompare)) {\n                let stack: string | undefined = undefined\n                try {\n                  throw new Error()\n                } catch (e) {\n                  // eslint-disable-next-line no-extra-semi\n                  ;({ stack } = e as Error)\n                }\n                console.warn(\n                  'Selector ' +\n                    (selector.name || 'unknown') +\n                    ' returned a different result when called with the same parameters. This can lead to unnecessary rerenders.' +\n                    '\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization',\n                  {\n                    state,\n                    selected,\n                    selected2: toCompare,\n                    stack,\n                  },\n                )\n              }\n            }\n            if (\n              finalIdentityFunctionCheck === 'always' ||\n              (finalIdentityFunctionCheck === 'once' && firstRun.current)\n            ) {\n              // @ts-ignore\n              if (selected === state) {\n                let stack: string | undefined = undefined\n                try {\n                  throw new Error()\n                } catch (e) {\n                  // eslint-disable-next-line no-extra-semi\n                  ;({ stack } = e as Error)\n                }\n                console.warn(\n                  'Selector ' +\n                    (selector.name || 'unknown') +\n                    ' returned the root state when called. This can lead to unnecessary rerenders.' +\n                    '\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.',\n                  { stack },\n                )\n              }\n            }\n            if (firstRun.current) firstRun.current = false\n          }\n          return selected\n        },\n      }[selector.name],\n      [selector, stabilityCheck, devModeChecks.stabilityCheck],\n    )\n\n    const selectedState = useSyncExternalStoreWithSelector(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      wrappedSelector,\n      equalityFn,\n    )\n\n    React.useDebugValue(selectedState)\n\n    return selectedState\n  }\n\n  Object.assign(useSelector, {\n    withTypes: () => useSelector,\n  })\n\n  return useSelector as UseSelector\n}\n\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\nexport const useSelector = /*#__PURE__*/ createSelectorHook()\n","import type { ElementType, MemoExoticComponent, ReactElement } from 'react'\r\n\r\n// Directly ported from:\r\n// https://unpkg.com/browse/react-is@18.3.0-canary-ee68446ff-20231115/cjs/react-is.production.js\r\n// It's very possible this could change in the future, but given that\r\n// we only use these in `connect`, this is a low priority.\r\n\r\nconst REACT_ELEMENT_TYPE = Symbol.for('react.element')\r\nconst REACT_PORTAL_TYPE = Symbol.for('react.portal')\r\nconst REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')\r\nconst REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')\r\nconst REACT_PROFILER_TYPE = Symbol.for('react.profiler')\r\nconst REACT_PROVIDER_TYPE = Symbol.for('react.provider')\r\nconst REACT_CONTEXT_TYPE = Symbol.for('react.context')\r\nconst REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context')\r\nconst REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')\r\nconst REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')\r\nconst REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')\r\nconst REACT_MEMO_TYPE = Symbol.for('react.memo')\r\nconst REACT_LAZY_TYPE = Symbol.for('react.lazy')\r\nconst REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')\r\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference')\r\n\r\nexport const ForwardRef = REACT_FORWARD_REF_TYPE\r\nexport const Memo = REACT_MEMO_TYPE\r\n\r\nexport function isValidElementType(type: any): type is ElementType {\r\n  if (typeof type === 'string' || typeof type === 'function') {\r\n    return true\r\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n\r\n  if (\r\n    type === REACT_FRAGMENT_TYPE ||\r\n    type === REACT_PROFILER_TYPE ||\r\n    type === REACT_STRICT_MODE_TYPE ||\r\n    type === REACT_SUSPENSE_TYPE ||\r\n    type === REACT_SUSPENSE_LIST_TYPE ||\r\n    type === REACT_OFFSCREEN_TYPE\r\n  ) {\r\n    return true\r\n  }\r\n\r\n  if (typeof type === 'object' && type !== null) {\r\n    if (\r\n      type.$$typeof === REACT_LAZY_TYPE ||\r\n      type.$$typeof === REACT_MEMO_TYPE ||\r\n      type.$$typeof === REACT_PROVIDER_TYPE ||\r\n      type.$$typeof === REACT_CONTEXT_TYPE ||\r\n      type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\r\n      // types supported by any Flight configuration anywhere since\r\n      // we don't know which Flight build this will end up being used\r\n      // with.\r\n      type.$$typeof === REACT_CLIENT_REFERENCE ||\r\n      type.getModuleId !== undefined\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nfunction typeOf(object: any): symbol | undefined {\r\n  if (typeof object === 'object' && object !== null) {\r\n    const $$typeof = object.$$typeof\r\n\r\n    switch ($$typeof) {\r\n      case REACT_ELEMENT_TYPE: {\r\n        const type = object.type\r\n\r\n        switch (type) {\r\n          case REACT_FRAGMENT_TYPE:\r\n          case REACT_PROFILER_TYPE:\r\n          case REACT_STRICT_MODE_TYPE:\r\n          case REACT_SUSPENSE_TYPE:\r\n          case REACT_SUSPENSE_LIST_TYPE:\r\n            return type\r\n\r\n          default: {\r\n            const $$typeofType = type && type.$$typeof\r\n\r\n            switch ($$typeofType) {\r\n              case REACT_SERVER_CONTEXT_TYPE:\r\n              case REACT_CONTEXT_TYPE:\r\n              case REACT_FORWARD_REF_TYPE:\r\n              case REACT_LAZY_TYPE:\r\n              case REACT_MEMO_TYPE:\r\n              case REACT_PROVIDER_TYPE:\r\n                return $$typeofType\r\n\r\n              default:\r\n                return $$typeof\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      case REACT_PORTAL_TYPE: {\r\n        return $$typeof\r\n      }\r\n    }\r\n  }\r\n\r\n  return undefined\r\n}\r\n\r\nexport function isContextConsumer(object: any): object is ReactElement {\r\n  return typeOf(object) === REACT_CONTEXT_TYPE\r\n}\r\n\r\nexport function isMemo(object: any): object is MemoExoticComponent<any> {\r\n  return typeOf(object) === REACT_MEMO_TYPE\r\n}\r\n","import type { Dispatch, Action } from 'redux'\nimport type { ComponentType } from 'react'\nimport verifySubselectors from './verifySubselectors'\nimport type { EqualityFn, ExtendedEqualityFn } from '../types'\n\nexport type SelectorFactory<S, TProps, TOwnProps, TFactoryOptions> = (\n  dispatch: Dispatch<Action<string>>,\n  factoryOptions: TFactoryOptions,\n) => Selector<S, TProps, TOwnProps>\n\nexport type Selector<S, TProps, TOwnProps = null> = TOwnProps extends\n  | null\n  | undefined\n  ? (state: S) => TProps\n  : (state: S, ownProps: TOwnProps) => TProps\n\nexport type MapStateToProps<TStateProps, TOwnProps, State> = (\n  state: State,\n  ownProps: TOwnProps,\n) => TStateProps\n\nexport type MapStateToPropsFactory<TStateProps, TOwnProps, State> = (\n  initialState: State,\n  ownProps: TOwnProps,\n) => MapStateToProps<TStateProps, TOwnProps, State>\n\nexport type MapStateToPropsParam<TStateProps, TOwnProps, State> =\n  | MapStateToPropsFactory<TStateProps, TOwnProps, State>\n  | MapStateToProps<TStateProps, TOwnProps, State>\n  | null\n  | undefined\n\nexport type MapDispatchToPropsFunction<TDispatchProps, TOwnProps> = (\n  dispatch: Dispatch<Action<string>>,\n  ownProps: TOwnProps,\n) => TDispatchProps\n\nexport type MapDispatchToProps<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n  | TDispatchProps\n\nexport type MapDispatchToPropsFactory<TDispatchProps, TOwnProps> = (\n  dispatch: Dispatch<Action<string>>,\n  ownProps: TOwnProps,\n) => MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n\nexport type MapDispatchToPropsParam<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\n  | MapDispatchToProps<TDispatchProps, TOwnProps>\n\nexport type MapDispatchToPropsNonObject<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n\nexport type MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> = (\n  stateProps: TStateProps,\n  dispatchProps: TDispatchProps,\n  ownProps: TOwnProps,\n) => TMergedProps\n\ninterface PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\n  readonly areStatesEqual: ExtendedEqualityFn<State, TOwnProps>\n  readonly areStatePropsEqual: EqualityFn<TStateProps>\n  readonly areOwnPropsEqual: EqualityFn<TOwnProps>\n}\n\nexport function pureFinalPropsSelectorFactory<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State,\n>(\n  mapStateToProps: WrappedMapStateToProps<TStateProps, TOwnProps, State>,\n  mapDispatchToProps: WrappedMapDispatchToProps<TDispatchProps, TOwnProps>,\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n  dispatch: Dispatch<Action<string>>,\n  {\n    areStatesEqual,\n    areOwnPropsEqual,\n    areStatePropsEqual,\n  }: PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State>,\n) {\n  let hasRunAtLeastOnce = false\n  let state: State\n  let ownProps: TOwnProps\n  let stateProps: TStateProps\n  let dispatchProps: TDispatchProps\n  let mergedProps: TMergedProps\n\n  function handleFirstCall(firstState: State, firstOwnProps: TOwnProps) {\n    state = firstState\n    ownProps = firstOwnProps\n    stateProps = mapStateToProps(state, ownProps)\n    dispatchProps = mapDispatchToProps(dispatch, ownProps)\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    hasRunAtLeastOnce = true\n    return mergedProps\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps)\n      stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps)\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)\n    stateProps = nextStateProps\n\n    if (statePropsChanged)\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n\n    return mergedProps\n  }\n\n  function handleSubsequentCalls(nextState: State, nextOwnProps: TOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)\n    const stateChanged = !areStatesEqual(\n      nextState,\n      state,\n      nextOwnProps,\n      ownProps,\n    )\n    state = nextState\n    ownProps = nextOwnProps\n\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState()\n    if (propsChanged) return handleNewProps()\n    if (stateChanged) return handleNewState()\n    return mergedProps\n  }\n\n  return function pureFinalPropsSelector(\n    nextState: State,\n    nextOwnProps: TOwnProps,\n  ) {\n    return hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  }\n}\n\ninterface WrappedMapStateToProps<TStateProps, TOwnProps, State> {\n  (state: State, ownProps: TOwnProps): TStateProps\n  readonly dependsOnOwnProps: boolean\n}\n\ninterface WrappedMapDispatchToProps<TDispatchProps, TOwnProps> {\n  (dispatch: Dispatch<Action<string>>, ownProps: TOwnProps): TDispatchProps\n  readonly dependsOnOwnProps: boolean\n}\n\nexport interface InitOptions<TStateProps, TOwnProps, TMergedProps, State>\n  extends PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\n  readonly shouldHandleStateChanges: boolean\n  readonly displayName: string\n  readonly wrappedComponentName: string\n  readonly WrappedComponent: ComponentType<TOwnProps>\n  readonly areMergedPropsEqual: EqualityFn<TMergedProps>\n}\n\nexport interface SelectorFactoryOptions<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State,\n> extends InitOptions<TStateProps, TOwnProps, TMergedProps, State> {\n  readonly initMapStateToProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>,\n  ) => WrappedMapStateToProps<TStateProps, TOwnProps, State>\n  readonly initMapDispatchToProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>,\n  ) => WrappedMapDispatchToProps<TDispatchProps, TOwnProps>\n  readonly initMergeProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>,\n  ) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>\n}\n\n// TODO: Add more comments\n\n// The selector returned by selectorFactory will memoize its results,\n// allowing connect's shouldComponentUpdate to return false if final\n// props have not changed.\n\nexport default function finalPropsSelectorFactory<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State,\n>(\n  dispatch: Dispatch<Action<string>>,\n  {\n    initMapStateToProps,\n    initMapDispatchToProps,\n    initMergeProps,\n    ...options\n  }: SelectorFactoryOptions<\n    TStateProps,\n    TOwnProps,\n    TDispatchProps,\n    TMergedProps,\n    State\n  >,\n) {\n  const mapStateToProps = initMapStateToProps(dispatch, options)\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)\n  const mergeProps = initMergeProps(dispatch, options)\n\n  if (process.env.NODE_ENV !== 'production') {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps)\n  }\n\n  return pureFinalPropsSelectorFactory<\n    TStateProps,\n    TOwnProps,\n    TDispatchProps,\n    TMergedProps,\n    State\n  >(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options)\n}\n","import type { ActionCreatorsMapObject, Dispatch, ActionCreator } from 'redux'\n\nimport type { FixTypeLater } from '../types'\nimport verifyPlainObject from '../utils/verifyPlainObject'\n\ntype AnyState = { [key: string]: any }\ntype StateOrDispatch<S extends AnyState = AnyState> = S | Dispatch\n\ntype AnyProps = { [key: string]: any }\n\nexport type MapToProps<P extends AnyProps = AnyProps> = {\n  // eslint-disable-next-line no-unused-vars\n  (stateOrDispatch: StateOrDispatch, ownProps?: P): FixTypeLater\n  dependsOnOwnProps?: boolean\n}\n\nexport function wrapMapToPropsConstant(\n  // * Note:\n  //  It seems that the dispatch argument\n  //  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\n  //  and a state object in some others (ex: whenMapStateToPropsIsMissing)\n  // eslint-disable-next-line no-unused-vars\n  getConstant: (dispatch: Dispatch) =>\n    | {\n        dispatch?: Dispatch\n        dependsOnOwnProps?: boolean\n      }\n    | ActionCreatorsMapObject\n    | ActionCreator<any>,\n) {\n  return function initConstantSelector(dispatch: Dispatch) {\n    const constant = getConstant(dispatch)\n\n    function constantSelector() {\n      return constant\n    }\n    constantSelector.dependsOnOwnProps = false\n    return constantSelector\n  }\n}\n\n// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\nexport function getDependsOnOwnProps(mapToProps: MapToProps) {\n  return mapToProps.dependsOnOwnProps\n    ? Boolean(mapToProps.dependsOnOwnProps)\n    : mapToProps.length !== 1\n}\n\n// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\nexport function wrapMapToPropsFunc<P extends AnyProps = AnyProps>(\n  mapToProps: MapToProps,\n  methodName: string,\n) {\n  return function initProxySelector(\n    dispatch: Dispatch,\n    { displayName }: { displayName: string },\n  ) {\n    const proxy = function mapToPropsProxy(\n      stateOrDispatch: StateOrDispatch,\n      ownProps?: P,\n    ): MapToProps {\n      return proxy.dependsOnOwnProps\n        ? proxy.mapToProps(stateOrDispatch, ownProps)\n        : proxy.mapToProps(stateOrDispatch, undefined)\n    }\n\n    // allow detectFactoryAndVerify to get ownProps\n    proxy.dependsOnOwnProps = true\n\n    proxy.mapToProps = function detectFactoryAndVerify(\n      stateOrDispatch: StateOrDispatch,\n      ownProps?: P,\n    ): MapToProps {\n      proxy.mapToProps = mapToProps\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)\n      let props = proxy(stateOrDispatch, ownProps)\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)\n        props = proxy(stateOrDispatch, ownProps)\n      }\n\n      if (process.env.NODE_ENV !== 'production')\n        verifyPlainObject(props, displayName, methodName)\n\n      return props\n    }\n\n    return proxy\n  }\n}\n","import type { Action, Dispatch } from 'redux'\n\nexport function createInvalidArgFactory(arg: unknown, name: string) {\n  return (\n    dispatch: Dispatch<Action<string>>,\n    options: { readonly wrappedComponentName: string },\n  ) => {\n    throw new Error(\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${\n        options.wrappedComponentName\n      }.`,\n    )\n  }\n}\n","import type { Action, Dispatch } from 'redux'\nimport verifyPlainObject from '../utils/verifyPlainObject'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MergeProps } from './selectorFactory'\nimport type { EqualityFn } from '../types'\n\nexport function defaultMergeProps<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps,\n>(\n  stateProps: TStateProps,\n  dispatchProps: TDispatchProps,\n  ownProps: TOwnProps,\n): TMergedProps {\n  // @ts-ignore\n  return { ...ownProps, ...stateProps, ...dispatchProps }\n}\n\nexport function wrapMergePropsFunc<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps,\n>(\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n): (\n  dispatch: Dispatch<Action<string>>,\n  options: {\n    readonly displayName: string\n    readonly areMergedPropsEqual: EqualityFn<TMergedProps>\n  },\n) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> {\n  return function initMergePropsProxy(\n    dispatch,\n    { displayName, areMergedPropsEqual },\n  ) {\n    let hasRunOnce = false\n    let mergedProps: TMergedProps\n\n    return function mergePropsProxy(\n      stateProps: TStateProps,\n      dispatchProps: TDispatchProps,\n      ownProps: TOwnProps,\n    ) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\n          mergedProps = nextMergedProps\n      } else {\n        hasRunOnce = true\n        mergedProps = nextMergedProps\n\n        if (process.env.NODE_ENV !== 'production')\n          verifyPlainObject(mergedProps, displayName, 'mergeProps')\n      }\n\n      return mergedProps\n    }\n  }\n}\n\nexport function mergePropsFactory<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps,\n>(\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n) {\n  return !mergeProps\n    ? () => defaultMergeProps\n    : typeof mergeProps === 'function'\n      ? wrapMergePropsFunc(mergeProps)\n      : createInvalidArgFactory(mergeProps, 'mergeProps')\n}\n","// Default to a dummy \"batch\" implementation that just runs the callback\r\nexport function defaultNoopBatch(callback: () => void) {\r\n  callback()\r\n}\r\n","import { defaultNoopBatch as batch } from './batch'\n\n// encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\ntype VoidFunc = () => void\n\ntype Listener = {\n  callback: VoidFunc\n  next: Listener | null\n  prev: Listener | null\n}\n\nfunction createListenerCollection() {\n  let first: Listener | null = null\n  let last: Listener | null = null\n\n  return {\n    clear() {\n      first = null\n      last = null\n    },\n\n    notify() {\n      batch(() => {\n        let listener = first\n        while (listener) {\n          listener.callback()\n          listener = listener.next\n        }\n      })\n    },\n\n    get() {\n      const listeners: Listener[] = []\n      let listener = first\n      while (listener) {\n        listeners.push(listener)\n        listener = listener.next\n      }\n      return listeners\n    },\n\n    subscribe(callback: () => void) {\n      let isSubscribed = true\n\n      const listener: Listener = (last = {\n        callback,\n        next: null,\n        prev: last,\n      })\n\n      if (listener.prev) {\n        listener.prev.next = listener\n      } else {\n        first = listener\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return\n        isSubscribed = false\n\n        if (listener.next) {\n          listener.next.prev = listener.prev\n        } else {\n          last = listener.prev\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next\n        } else {\n          first = listener.next\n        }\n      }\n    },\n  }\n}\n\ntype ListenerCollection = ReturnType<typeof createListenerCollection>\n\nexport interface Subscription {\n  addNestedSub: (listener: VoidFunc) => VoidFunc\n  notifyNestedSubs: VoidFunc\n  handleChangeWrapper: VoidFunc\n  isSubscribed: () => boolean\n  onStateChange?: VoidFunc | null\n  trySubscribe: VoidFunc\n  tryUnsubscribe: VoidFunc\n  getListeners: () => ListenerCollection\n}\n\nconst nullListeners = {\n  notify() {},\n  get: () => [],\n} as unknown as ListenerCollection\n\nexport function createSubscription(store: any, parentSub?: Subscription) {\n  let unsubscribe: VoidFunc | undefined\n  let listeners: ListenerCollection = nullListeners\n\n  // Reasons to keep the subscription active\n  let subscriptionsAmount = 0\n\n  // Is this specific subscription subscribed (or only nested ones?)\n  let selfSubscribed = false\n\n  function addNestedSub(listener: () => void) {\n    trySubscribe()\n\n    const cleanupListener = listeners.subscribe(listener)\n\n    // cleanup nested sub\n    let removed = false\n    return () => {\n      if (!removed) {\n        removed = true\n        cleanupListener()\n        tryUnsubscribe()\n      }\n    }\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify()\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange()\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++\n    if (!unsubscribe) {\n      unsubscribe = parentSub\n        ? parentSub.addNestedSub(handleChangeWrapper)\n        : store.subscribe(handleChangeWrapper)\n\n      listeners = createListenerCollection()\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe()\n      unsubscribe = undefined\n      listeners.clear()\n      listeners = nullListeners\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true\n      trySubscribe()\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false\n      tryUnsubscribe()\n    }\n  }\n\n  const subscription: Subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners,\n  }\n\n  return subscription\n}\n","import { React } from '../utils/react'\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\n// Matches logic in React's `shared/ExecutionEnvironment` file\nexport const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// Under React Native, we know that we always want to use useLayoutEffect\n\n/**\n * Checks if the code is running in a React Native environment.\n *\n * @see {@link https://github.com/facebook/react-native/issues/1331 Reference}\n */\nexport const isReactNative =\n  typeof navigator !== 'undefined' && navigator.product === 'ReactNative'\n\nexport const useIsomorphicLayoutEffect =\n  canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect\n","function is(x: unknown, y: unknown) {\r\n  if (x === y) {\r\n    return x !== 0 || y !== 0 || 1 / x === 1 / y\r\n  } else {\r\n    return x !== x && y !== y\r\n  }\r\n}\r\n\r\nexport default function shallowEqual(objA: any, objB: any) {\r\n  if (is(objA, objB)) return true\r\n\r\n  if (\r\n    typeof objA !== 'object' ||\r\n    objA === null ||\r\n    typeof objB !== 'object' ||\r\n    objB === null\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  const keysA = Object.keys(objA)\r\n  const keysB = Object.keys(objB)\r\n\r\n  if (keysA.length !== keysB.length) return false\r\n\r\n  for (let i = 0; i < keysA.length; i++) {\r\n    if (\r\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||\r\n      !is(objA[keysA[i]], objB[keysA[i]])\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n","// Copied directly from:\n// https://github.com/mridgway/hoist-non-react-statics/blob/main/src/index.js\n// https://unpkg.com/browse/@types/hoist-non-react-statics@3.3.1/index.d.ts\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nimport type * as React from 'react'\nimport { ForwardRef, Memo, isMemo } from '../utils/react-is'\n\nconst REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true,\n} as const\n\nconst KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true,\n} as const\n\nconst FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n} as const\n\nconst MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true,\n} as const\n\nconst TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS,\n} as const\n\nfunction getStatics(component: any) {\n  // React v16.11 and below\n  if (isMemo(component)) {\n    return MEMO_STATICS\n  }\n\n  // React v16.12 and above\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS\n}\n\nexport type NonReactStatics<\n  S extends React.ComponentType<any>,\n  C extends {\n    [key: string]: true\n  } = {},\n> = {\n  [key in Exclude<\n    keyof S,\n    S extends React.MemoExoticComponent<any>\n      ? keyof typeof MEMO_STATICS | keyof C\n      : S extends React.ForwardRefExoticComponent<any>\n        ? keyof typeof FORWARD_REF_STATICS | keyof C\n        : keyof typeof REACT_STATICS | keyof typeof KNOWN_STATICS | keyof C\n  >]: S[key]\n}\n\nconst defineProperty = Object.defineProperty\nconst getOwnPropertyNames = Object.getOwnPropertyNames\nconst getOwnPropertySymbols = Object.getOwnPropertySymbols\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor\nconst getPrototypeOf = Object.getPrototypeOf\nconst objectPrototype = Object.prototype\n\nexport default function hoistNonReactStatics<\n  T extends React.ComponentType<any>,\n  S extends React.ComponentType<any>,\n  C extends {\n    [key: string]: true\n  } = {},\n>(targetComponent: T, sourceComponent: S): T & NonReactStatics<S, C> {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent)\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent)\n      }\n    }\n\n    let keys: (string | symbol)[] = getOwnPropertyNames(sourceComponent)\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent))\n    }\n\n    const targetStatics = getStatics(targetComponent)\n    const sourceStatics = getStatics(sourceComponent)\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i]\n      if (\n        !KNOWN_STATICS[key as keyof typeof KNOWN_STATICS] &&\n        !(sourceStatics && sourceStatics[key as keyof typeof sourceStatics]) &&\n        !(targetStatics && targetStatics[key as keyof typeof targetStatics])\n      ) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key)\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor!)\n        } catch (e) {\n          // ignore\n        }\n      }\n    }\n  }\n\n  return targetComponent as any\n}\n","/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */\nimport type { ComponentType } from 'react'\nimport { React } from '../utils/react'\nimport { isValidElementType, isContextConsumer } from '../utils/react-is'\n\nimport type { Store } from 'redux'\n\nimport type {\n  ConnectedComponent,\n  InferableComponentEnhancer,\n  InferableComponentEnhancerWithProps,\n  ResolveThunks,\n  DispatchProp,\n  ConnectPropsMaybeWithoutContext,\n} from '../types'\n\nimport type {\n  MapStateToPropsParam,\n  MapDispatchToPropsParam,\n  MergeProps,\n  MapDispatchToPropsNonObject,\n  SelectorFactoryOptions,\n} from '../connect/selectorFactory'\nimport defaultSelectorFactory from '../connect/selectorFactory'\nimport { mapDispatchToPropsFactory } from '../connect/mapDispatchToProps'\nimport { mapStateToPropsFactory } from '../connect/mapStateToProps'\nimport { mergePropsFactory } from '../connect/mergeProps'\n\nimport type { Subscription } from '../utils/Subscription'\nimport { createSubscription } from '../utils/Subscription'\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\nimport shallowEqual from '../utils/shallowEqual'\nimport hoistStatics from '../utils/hoistStatics'\nimport warning from '../utils/warning'\n\nimport type {\n  ReactReduxContextValue,\n  ReactReduxContextInstance,\n} from './Context'\nimport { ReactReduxContext } from './Context'\n\nimport type { uSES } from '../utils/useSyncExternalStore'\nimport { notInitialized } from '../utils/useSyncExternalStore'\n\nlet useSyncExternalStore = notInitialized as uSES\nexport const initializeConnect = (fn: uSES) => {\n  useSyncExternalStore = fn\n}\n\n// Define some constant arrays just to avoid re-creating these\nconst EMPTY_ARRAY: [unknown, number] = [null, 0]\nconst NO_SUBSCRIPTION_ARRAY = [null, null]\n\n// Attempts to stringify whatever not-really-a-component value we were given\n// for logging in an error message\nconst stringifyComponent = (Comp: unknown) => {\n  try {\n    return JSON.stringify(Comp)\n  } catch (err) {\n    return String(Comp)\n  }\n}\n\ntype EffectFunc = (...args: any[]) => void | ReturnType<React.EffectCallback>\n\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\n// - we extract this to a separate function to avoid closing over values\n//   and causing memory leaks\nfunction useIsomorphicLayoutEffectWithArgs(\n  effectFunc: EffectFunc,\n  effectArgs: any[],\n  dependencies?: React.DependencyList,\n) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies)\n}\n\n// Effect callback, extracted: assign the latest props values to refs for later usage\nfunction captureWrapperProps(\n  lastWrapperProps: React.MutableRefObject<unknown>,\n  lastChildProps: React.MutableRefObject<unknown>,\n  renderIsScheduled: React.MutableRefObject<boolean>,\n  wrapperProps: unknown,\n  // actualChildProps: unknown,\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\n  notifyNestedSubs: () => void,\n) {\n  // We want to capture the wrapper props and child props we used for later comparisons\n  lastWrapperProps.current = wrapperProps\n  renderIsScheduled.current = false\n\n  // If the render was from a store update, clear out that reference and cascade the subscriber update\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null\n    notifyNestedSubs()\n  }\n}\n\n// Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\n// check for updates after dispatched actions, and trigger re-renders.\nfunction subscribeUpdates(\n  shouldHandleStateChanges: boolean,\n  store: Store,\n  subscription: Subscription,\n  childPropsSelector: (state: unknown, props: unknown) => unknown,\n  lastWrapperProps: React.MutableRefObject<unknown>,\n  lastChildProps: React.MutableRefObject<unknown>,\n  renderIsScheduled: React.MutableRefObject<boolean>,\n  isMounted: React.MutableRefObject<boolean>,\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\n  notifyNestedSubs: () => void,\n  // forceComponentUpdateDispatch: React.Dispatch<any>,\n  additionalSubscribeListener: () => void,\n) {\n  // If we're not subscribed to the store, nothing to do here\n  if (!shouldHandleStateChanges) return () => {}\n\n  // Capture values for checking if and when this component unmounts\n  let didUnsubscribe = false\n  let lastThrownError: Error | null = null\n\n  // We'll run this callback every time a store subscription update propagates to this component\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      // Don't run stale listeners.\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n      return\n    }\n\n    // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\n    const latestStoreState = store.getState()\n\n    let newChildProps, error\n    try {\n      // Actually run the selector with the most recent store state and wrapper props\n      // to determine what the child props should be\n      newChildProps = childPropsSelector(\n        latestStoreState,\n        lastWrapperProps.current,\n      )\n    } catch (e) {\n      error = e\n      lastThrownError = e as Error | null\n    }\n\n    if (!error) {\n      lastThrownError = null\n    }\n\n    // If the child props haven't changed, nothing to do here - cascade the subscription update\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs()\n      }\n    } else {\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n      // forcing another re-render, which we don't want.\n      lastChildProps.current = newChildProps\n      childPropsFromStoreUpdate.current = newChildProps\n      renderIsScheduled.current = true\n\n      // TODO This is hacky and not how `uSES` is meant to be used\n      // Trigger the React `useSyncExternalStore` subscriber\n      additionalSubscribeListener()\n    }\n  }\n\n  // Actually subscribe to the nearest connected ancestor (or store)\n  subscription.onStateChange = checkForUpdates\n  subscription.trySubscribe()\n\n  // Pull data from the store after first render in case the store has\n  // changed since we began.\n  checkForUpdates()\n\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true\n    subscription.tryUnsubscribe()\n    subscription.onStateChange = null\n\n    if (lastThrownError) {\n      // It's possible that we caught an error due to a bad mapState function, but the\n      // parent re-rendered without this component and we're about to unmount.\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\n      // if we ever do those wrong, this throw will surface the error in our tests.\n      // In that case, throw the error from here so it doesn't get lost.\n      throw lastThrownError\n    }\n  }\n\n  return unsubscribeWrapper\n}\n\n// Reducer initial state creation for our update reducer\nconst initStateUpdates = () => EMPTY_ARRAY\n\nexport interface ConnectProps {\n  /** A custom Context instance that the component can use to access the store from an alternate Provider using that same Context instance */\n  context?: ReactReduxContextInstance\n  /** A Redux store instance to be used for subscriptions instead of the store from a Provider */\n  store?: Store\n}\n\ninterface InternalConnectProps extends ConnectProps {\n  reactReduxForwardedRef?: React.ForwardedRef<unknown>\n}\n\nfunction strictEqual(a: unknown, b: unknown) {\n  return a === b\n}\n\n/**\n * Infers the type of props that a connector will inject into a component.\n */\nexport type ConnectedProps<TConnector> =\n  TConnector extends InferableComponentEnhancerWithProps<\n    infer TInjectedProps,\n    any\n  >\n    ? unknown extends TInjectedProps\n      ? TConnector extends InferableComponentEnhancer<infer TInjectedProps>\n        ? TInjectedProps\n        : never\n      : TInjectedProps\n    : never\n\nexport interface ConnectOptions<\n  State = unknown,\n  TStateProps = {},\n  TOwnProps = {},\n  TMergedProps = {},\n> {\n  forwardRef?: boolean\n  context?: typeof ReactReduxContext\n  areStatesEqual?: (\n    nextState: State,\n    prevState: State,\n    nextOwnProps: TOwnProps,\n    prevOwnProps: TOwnProps,\n  ) => boolean\n\n  areOwnPropsEqual?: (\n    nextOwnProps: TOwnProps,\n    prevOwnProps: TOwnProps,\n  ) => boolean\n\n  areStatePropsEqual?: (\n    nextStateProps: TStateProps,\n    prevStateProps: TStateProps,\n  ) => boolean\n  areMergedPropsEqual?: (\n    nextMergedProps: TMergedProps,\n    prevMergedProps: TMergedProps,\n  ) => boolean\n}\n\n/**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior / props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that's\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user's responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps\n * @param mapDispatchToProps\n * @param mergeProps\n * @param options\n */\nexport interface Connect<DefaultState = unknown> {\n  // tslint:disable:no-unnecessary-generics\n  (): InferableComponentEnhancer<DispatchProp>\n\n  /** mapState only */\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n  ): InferableComponentEnhancerWithProps<TStateProps & DispatchProp, TOwnProps>\n\n  /** mapDispatch only (as a function) */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\n\n  /** mapDispatch only (as an object) */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState and mapDispatch (as a function)*/\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & TDispatchProps,\n    TOwnProps\n  >\n\n  /** mapState and mapDispatch (nullish) */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n  ): InferableComponentEnhancerWithProps<TStateProps, TOwnProps>\n\n  /** mapState and mapDispatch (as an object) */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mergeProps only */\n  <no_state = {}, no_dispatch = {}, TOwnProps = {}, TMergedProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: null | undefined,\n    mergeProps: MergeProps<undefined, DispatchProp, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapState and mergeProps */\n  <\n    TStateProps = {},\n    no_dispatch = {},\n    TOwnProps = {},\n    TMergedProps = {},\n    State = DefaultState,\n  >(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n    mergeProps: MergeProps<TStateProps, DispatchProp, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapDispatch (as a object) and mergeProps */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: MergeProps<undefined, TDispatchProps, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapState and options */\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<DispatchProp & TStateProps, TOwnProps>\n\n  /** mapDispatch (as a function) and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<{}, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\n\n  /** mapDispatch (as an object) and options*/\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<{}, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState,  mapDispatch (as a function), and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & TDispatchProps,\n    TOwnProps\n  >\n\n  /** mapState,  mapDispatch (as an object), and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState, mapDispatch, mergeProps, and options */\n  <\n    TStateProps = {},\n    TDispatchProps = {},\n    TOwnProps = {},\n    TMergedProps = {},\n    State = DefaultState,\n  >(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: MergeProps<\n      TStateProps,\n      TDispatchProps,\n      TOwnProps,\n      TMergedProps\n    >,\n    options?: ConnectOptions<State, TStateProps, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n  // tslint:enable:no-unnecessary-generics\n}\n\nlet hasWarnedAboutDeprecatedPureOption = false\n\n/**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior / props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that's\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user's responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps A function that extracts values from state\n * @param mapDispatchToProps Setup for dispatching actions\n * @param mergeProps Optional callback to merge state and dispatch props together\n * @param options Options for configuring the connection\n *\n */\nfunction connect<\n  TStateProps = {},\n  TDispatchProps = {},\n  TOwnProps = {},\n  TMergedProps = {},\n  State = unknown,\n>(\n  mapStateToProps?: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n  mapDispatchToProps?: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n  {\n    // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n    // @ts-ignore\n    pure,\n    areStatesEqual = strictEqual,\n    areOwnPropsEqual = shallowEqual,\n    areStatePropsEqual = shallowEqual,\n    areMergedPropsEqual = shallowEqual,\n\n    // use React's forwardRef to expose a ref of the wrapped component\n    forwardRef = false,\n\n    // the context consumer to use\n    context = ReactReduxContext,\n  }: ConnectOptions<unknown, unknown, unknown, unknown> = {},\n): unknown {\n  if (process.env.NODE_ENV !== 'production') {\n    if (pure !== undefined && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true\n      warning(\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component',\n      )\n    }\n  }\n\n  const Context = context\n\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps)\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps)\n  const initMergeProps = mergePropsFactory(mergeProps)\n\n  const shouldHandleStateChanges = Boolean(mapStateToProps)\n\n  const wrapWithConnect = <TProps,>(\n    WrappedComponent: ComponentType<TProps>,\n  ) => {\n    type WrappedComponentProps = TProps &\n      ConnectPropsMaybeWithoutContext<TProps>\n\n    if (process.env.NODE_ENV !== 'production') {\n      const isValid = /*#__PURE__*/ isValidElementType(WrappedComponent)\n      if (!isValid)\n        throw new Error(\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\n            WrappedComponent,\n          )}`,\n        )\n    }\n\n    const wrappedComponentName =\n      WrappedComponent.displayName || WrappedComponent.name || 'Component'\n\n    const displayName = `Connect(${wrappedComponentName})`\n\n    const selectorFactoryOptions: SelectorFactoryOptions<\n      any,\n      any,\n      any,\n      any,\n      State\n    > = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual,\n    }\n\n    function ConnectFunction<TOwnProps>(\n      props: InternalConnectProps & TOwnProps,\n    ) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] =\n        React.useMemo(() => {\n          // Distinguish between actual \"data\" props that were passed to the wrapper component,\n          // and values needed to control behavior (forwarded refs, alternate context instances).\n          // To maintain the wrapperProps object reference, memoize this destructuring.\n          const { reactReduxForwardedRef, ...wrapperProps } = props\n          return [props.context, reactReduxForwardedRef, wrapperProps]\n        }, [props])\n\n      const ContextToUse: ReactReduxContextInstance = React.useMemo(() => {\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n        // Memoize the check that determines which context instance we should use.\n        let ResultContext = Context\n        if (propsContext?.Consumer) {\n          if (process.env.NODE_ENV !== 'production') {\n            const isValid = /*#__PURE__*/ isContextConsumer(\n              // @ts-ignore\n              <propsContext.Consumer />,\n            )\n            if (!isValid) {\n              throw new Error(\n                'You must pass a valid React context consumer as `props.context`',\n              )\n            }\n            ResultContext = propsContext\n          }\n        }\n        return ResultContext\n      }, [propsContext, Context])\n\n      // Retrieve the store and ancestor subscription via context, if available\n      const contextValue = React.useContext(ContextToUse)\n\n      // The store _must_ exist as either a prop or in context.\n      // We'll check to see if it _looks_ like a Redux store first.\n      // This allows us to pass through a `store` prop that is just a plain value.\n      const didStoreComeFromProps =\n        Boolean(props.store) &&\n        Boolean(props.store!.getState) &&\n        Boolean(props.store!.dispatch)\n      const didStoreComeFromContext =\n        Boolean(contextValue) && Boolean(contextValue!.store)\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !didStoreComeFromProps &&\n        !didStoreComeFromContext\n      ) {\n        throw new Error(\n          `Could not find \"store\" in the context of ` +\n            `\"${displayName}\". Either wrap the root component in a <Provider>, ` +\n            `or pass a custom React context provider to <Provider> and the corresponding ` +\n            `React context consumer to ${displayName} in connect options.`,\n        )\n      }\n\n      // Based on the previous check, one of these must be true\n      const store: Store = didStoreComeFromProps\n        ? props.store!\n        : contextValue!.store\n\n      const getServerState = didStoreComeFromContext\n        ? contextValue!.getServerState\n        : store.getState\n\n      const childPropsSelector = React.useMemo(() => {\n        // The child props selector needs the store reference as an input.\n        // Re-create this selector whenever the store changes.\n        return defaultSelectorFactory(store.dispatch, selectorFactoryOptions)\n      }, [store])\n\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY\n\n        // This Subscription's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n        const subscription = createSubscription(\n          store,\n          didStoreComeFromProps ? undefined : contextValue!.subscription,\n        )\n\n        // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `subscription` will then be null. This can\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\n        // that have been unsubscribed in the  middle of the notification loop.\n        const notifyNestedSubs =\n          subscription.notifyNestedSubs.bind(subscription)\n\n        return [subscription, notifyNestedSubs]\n      }, [store, didStoreComeFromProps, contextValue])\n\n      // Determine what {store, subscription} value should be put into nested context, if necessary,\n      // and memoize that value to avoid unnecessary context updates.\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          // This component is directly subscribed to a store from props.\n          // We don't want descendants reading from this store - pass down whatever\n          // the existing context value is from the nearest connected ancestor.\n          return contextValue!\n        }\n\n        // Otherwise, put this component's subscription instance into context, so that\n        // connected descendants won't update until after this component is done\n        return {\n          ...contextValue,\n          subscription,\n        } as ReactReduxContextValue\n      }, [didStoreComeFromProps, contextValue, subscription])\n\n      // Set up refs to coordinate values between the subscription effect and the render logic\n      const lastChildProps = React.useRef<unknown>(undefined)\n      const lastWrapperProps = React.useRef(wrapperProps)\n      const childPropsFromStoreUpdate = React.useRef<unknown>(undefined)\n      const renderIsScheduled = React.useRef(false)\n      const isMounted = React.useRef(false)\n\n      // TODO: Change this to `React.useRef<Error>(undefined)` after upgrading to React 19.\n      /**\n       * @todo Change this to `React.useRef<Error>(undefined)` after upgrading to React 19.\n       */\n      const latestSubscriptionCallbackError = React.useRef<Error | undefined>(\n        undefined,\n      )\n\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true\n        return () => {\n          isMounted.current = false\n        }\n      }, [])\n\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          // Tricky logic here:\n          // - This render may have been triggered by a Redux store update that produced new child props\n          // - However, we may have gotten new wrapper props after that\n          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n          // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n          if (\n            childPropsFromStoreUpdate.current &&\n            wrapperProps === lastWrapperProps.current\n          ) {\n            return childPropsFromStoreUpdate.current\n          }\n\n          // TODO We're reading the store directly in render() here. Bad idea?\n          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n          // to determine what the child props should be.\n          return childPropsSelector(store.getState(), wrapperProps)\n        }\n        return selector\n      }, [store, wrapperProps])\n\n      // We need this to execute synchronously every time we re-render. However, React warns\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n      // just useEffect instead to avoid the warning, since neither will run anyway.\n\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = (reactListener: () => void) => {\n          if (!subscription) {\n            return () => {}\n          }\n\n          return subscribeUpdates(\n            shouldHandleStateChanges,\n            store,\n            subscription,\n            // @ts-ignore\n            childPropsSelector,\n            lastWrapperProps,\n            lastChildProps,\n            renderIsScheduled,\n            isMounted,\n            childPropsFromStoreUpdate,\n            notifyNestedSubs,\n            reactListener,\n          )\n        }\n\n        return subscribe\n      }, [subscription])\n\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        wrapperProps,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs,\n      ])\n\n      let actualChildProps: Record<string, unknown>\n\n      try {\n        actualChildProps = useSyncExternalStore(\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n          subscribeForReact,\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n          actualChildPropsSelector,\n          getServerState\n            ? () => childPropsSelector(getServerState(), wrapperProps)\n            : actualChildPropsSelector,\n        )\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          // eslint-disable-next-line no-extra-semi\n          ;(err as Error).message +=\n            `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`\n        }\n\n        throw err\n      }\n\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = undefined\n        childPropsFromStoreUpdate.current = undefined\n        lastChildProps.current = actualChildProps\n      })\n\n      // Now that all that's done, we can finally try to actually render the child component.\n      // We memoize the elements for the rendered child component as an optimization.\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (\n          // @ts-ignore\n          <WrappedComponent\n            {...actualChildProps}\n            ref={reactReduxForwardedRef}\n          />\n        )\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps])\n\n      // If React sees the exact same element reference as last time, it bails out of re-rendering\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          // If this component is subscribed to store updates, we need to pass its own\n          // subscription instance down to our descendants. That means rendering the same\n          // Context instance, and putting a different value into the context.\n          return (\n            <ContextToUse.Provider value={overriddenContextValue}>\n              {renderedWrappedComponent}\n            </ContextToUse.Provider>\n          )\n        }\n\n        return renderedWrappedComponent\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])\n\n      return renderedChild\n    }\n\n    const _Connect = React.memo(ConnectFunction)\n\n    type ConnectedWrapperComponent = typeof _Connect & {\n      WrappedComponent: typeof WrappedComponent\n    }\n\n    // Add a hacky cast to get the right output type\n    const Connect = _Connect as unknown as ConnectedComponent<\n      typeof WrappedComponent,\n      WrappedComponentProps\n    >\n    Connect.WrappedComponent = WrappedComponent\n    Connect.displayName = ConnectFunction.displayName = displayName\n\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(\n        function forwardConnectRef(props, ref) {\n          // @ts-ignore\n          return <Connect {...props} reactReduxForwardedRef={ref} />\n        },\n      )\n\n      const forwarded = _forwarded as ConnectedWrapperComponent\n      forwarded.displayName = displayName\n      forwarded.WrappedComponent = WrappedComponent\n      return /*#__PURE__*/ hoistStatics(forwarded, WrappedComponent)\n    }\n\n    return /*#__PURE__*/ hoistStatics(Connect, WrappedComponent)\n  }\n\n  return wrapWithConnect\n}\n\nexport default connect as Connect\n","import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MapStateToPropsParam } from './selectorFactory'\n\nexport function mapStateToPropsFactory<TStateProps, TOwnProps, State>(\n  mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n) {\n  return !mapStateToProps\n    ? wrapMapToPropsConstant(() => ({}))\n    : typeof mapStateToProps === 'function'\n      ? // @ts-ignore\n        wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')\n      : createInvalidArgFactory(mapStateToProps, 'mapStateToProps')\n}\n","import type { Action, Dispatch } from 'redux'\nimport bindActionCreators from '../utils/bindActionCreators'\nimport { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MapDispatchToPropsParam } from './selectorFactory'\n\nexport function mapDispatchToPropsFactory<TDispatchProps, TOwnProps>(\n  mapDispatchToProps:\n    | MapDispatchToPropsParam<TDispatchProps, TOwnProps>\n    | undefined,\n) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object'\n    ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) =>\n        // @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch),\n      )\n    : !mapDispatchToProps\n      ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) => ({\n          dispatch,\n        }))\n      : typeof mapDispatchToProps === 'function'\n        ? // @ts-ignore\n          wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')\n        : createInvalidArgFactory(mapDispatchToProps, 'mapDispatchToProps')\n}\n","import type { ActionCreatorsMapObject, Dispatch } from 'redux'\n\nexport default function bindActionCreators(\n  actionCreators: ActionCreatorsMapObject,\n  dispatch: Dispatch,\n): ActionCreatorsMapObject {\n  const boundActionCreators: ActionCreatorsMapObject = {}\n\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args))\n    }\n  }\n  return boundActionCreators\n}\n","import type { Context, ReactNode } from 'react'\nimport { React } from '../utils/react'\nimport type { Action, Store, UnknownAction } from 'redux'\nimport type { DevModeCheckFrequency } from '../hooks/useSelector'\nimport { createSubscription } from '../utils/Subscription'\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\nimport type { ReactReduxContextValue } from './Context'\nimport { ReactReduxContext } from './Context'\n\nexport interface ProviderProps<\n  A extends Action<string> = UnknownAction,\n  S = unknown,\n> {\n  /**\n   * The single Redux store in your application.\n   */\n  store: Store<S, A>\n\n  /**\n   * An optional server state snapshot. Will be used during initial hydration render if available, to ensure that the UI output is consistent with the HTML generated on the server.\n   */\n  serverState?: S\n\n  /**\n   * Optional context to be used internally in react-redux. Use React.createContext() to create a context to be used.\n   * If this is used, you'll need to customize `connect` by supplying the same context provided to the Provider.\n   * Set the initial value to null, and the hooks will error\n   * if this is not overwritten by Provider.\n   */\n  context?: Context<ReactReduxContextValue<S, A> | null>\n\n  /**\n   * Determines the frequency of stability checks for all selectors.\n   * This setting overrides the global configuration for\n   * the `useSelector` stability check, allowing you to specify how often\n   * these checks should occur in development mode.\n   *\n   * @since 8.1.0\n   */\n  stabilityCheck?: DevModeCheckFrequency\n\n  /**\n   * Determines the frequency of identity function checks for all selectors.\n   * This setting overrides the global configuration for\n   * the `useSelector` identity function check, allowing you to specify how often\n   * these checks should occur in development mode.\n   *\n   * **Note**: Previously referred to as `noopCheck`.\n   *\n   * @since 9.0.0\n   */\n  identityFunctionCheck?: DevModeCheckFrequency\n\n  children: ReactNode\n}\n\nfunction Provider<A extends Action<string> = UnknownAction, S = unknown>({\n  store,\n  context,\n  children,\n  serverState,\n  stabilityCheck = 'once',\n  identityFunctionCheck = 'once',\n}: ProviderProps<A, S>) {\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store)\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : undefined,\n      stabilityCheck,\n      identityFunctionCheck,\n    }\n  }, [store, serverState, stabilityCheck, identityFunctionCheck])\n\n  const previousState = React.useMemo(() => store.getState(), [store])\n\n  useIsomorphicLayoutEffect(() => {\n    const { subscription } = contextValue\n    subscription.onStateChange = subscription.notifyNestedSubs\n    subscription.trySubscribe()\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs()\n    }\n    return () => {\n      subscription.tryUnsubscribe()\n      subscription.onStateChange = undefined\n    }\n  }, [contextValue, previousState])\n\n  const Context = context || ReactReduxContext\n\n  // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>\n}\n\nexport default Provider\n","import type { Context } from 'react'\nimport type { Action, Store } from 'redux'\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport {\n  createReduxContextHook,\n  useReduxContext as useDefaultReduxContext,\n} from './useReduxContext'\n\n/**\n * Represents a type that extracts the action type from a given Redux store.\n *\n * @template StoreType - The specific type of the Redux store.\n *\n * @since 9.1.0\n * @internal\n */\nexport type ExtractStoreActionType<StoreType extends Store> =\n  StoreType extends Store<any, infer ActionType> ? ActionType : never\n\n/**\n * Represents a custom hook that provides access to the Redux store.\n *\n * @template StoreType - The specific type of the Redux store that gets returned.\n *\n * @since 9.1.0\n * @public\n */\nexport interface UseStore<StoreType extends Store> {\n  /**\n   * Returns the Redux store instance.\n   *\n   * @returns The Redux store instance.\n   */\n  (): StoreType\n\n  /**\n   * Returns the Redux store instance with specific state and action types.\n   *\n   * @returns The Redux store with the specified state and action types.\n   *\n   * @template StateType - The specific type of the state used in the store.\n   * @template ActionType - The specific type of the actions used in the store.\n   */\n  <\n    StateType extends ReturnType<StoreType['getState']> = ReturnType<\n      StoreType['getState']\n    >,\n    ActionType extends Action = ExtractStoreActionType<Store>,\n  >(): Store<StateType, ActionType>\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useStore useStore}\n   * where the type of the Redux `store` is predefined.\n   *\n   * This allows you to set the `store` type once, eliminating the need to\n   * specify it with every {@linkcode useStore useStore} call.\n   *\n   * @returns A pre-typed `useStore` with the store type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppStore = useStore.withTypes<AppStore>()\n   * ```\n   *\n   * @template OverrideStoreType - The specific type of the Redux store that gets returned.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideStoreType extends StoreType,\n  >() => UseStore<OverrideStoreType>\n}\n\n/**\n * Hook factory, which creates a `useStore` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useStore` hook bound to the specified context.\n */\nexport function createStoreHook<\n  StateType = unknown,\n  ActionType extends Action = Action,\n>(\n  // @ts-ignore\n  context?: Context<ReactReduxContextValue<\n    StateType,\n    ActionType\n  > | null> = ReactReduxContext,\n) {\n  const useReduxContext =\n    context === ReactReduxContext\n      ? useDefaultReduxContext\n      : // @ts-ignore\n        createReduxContextHook(context)\n  const useStore = () => {\n    const { store } = useReduxContext()\n    return store\n  }\n\n  Object.assign(useStore, {\n    withTypes: () => useStore,\n  })\n\n  return useStore as UseStore<Store<StateType, ActionType>>\n}\n\n/**\n * A hook to access the redux store.\n *\n * @returns {any} the redux store\n *\n * @example\n *\n * import React from 'react'\n * import { useStore } from 'react-redux'\n *\n * export const ExampleComponent = () => {\n *   const store = useStore()\n *   return <div>{store.getState()}</div>\n * }\n */\nexport const useStore = /*#__PURE__*/ createStoreHook()\n","import type { Context } from 'react'\nimport type { Action, Dispatch, UnknownAction } from 'redux'\n\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport { createStoreHook, useStore as useDefaultStore } from './useStore'\n\n/**\n * Represents a custom hook that provides a dispatch function\n * from the Redux store.\n *\n * @template DispatchType - The specific type of the dispatch function.\n *\n * @since 9.1.0\n * @public\n */\nexport interface UseDispatch<\n  DispatchType extends Dispatch<UnknownAction> = Dispatch<UnknownAction>,\n> {\n  /**\n   * Returns the dispatch function from the Redux store.\n   *\n   * @returns The dispatch function from the Redux store.\n   *\n   * @template AppDispatch - The specific type of the dispatch function.\n   */\n  <AppDispatch extends DispatchType = DispatchType>(): AppDispatch\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useDispatch useDispatch}\n   * where the type of the `dispatch` function is predefined.\n   *\n   * This allows you to set the `dispatch` type once, eliminating the need to\n   * specify it with every {@linkcode useDispatch useDispatch} call.\n   *\n   * @returns A pre-typed `useDispatch` with the dispatch type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppDispatch = useDispatch.withTypes<AppDispatch>()\n   * ```\n   *\n   * @template OverrideDispatchType - The specific type of the dispatch function.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideDispatchType extends DispatchType,\n  >() => UseDispatch<OverrideDispatchType>\n}\n\n/**\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useDispatch` hook bound to the specified context.\n */\nexport function createDispatchHook<\n  StateType = unknown,\n  ActionType extends Action = UnknownAction,\n>(\n  // @ts-ignore\n  context?: Context<ReactReduxContextValue<\n    StateType,\n    ActionType\n  > | null> = ReactReduxContext,\n) {\n  const useStore =\n    context === ReactReduxContext ? useDefaultStore : createStoreHook(context)\n\n  const useDispatch = () => {\n    const store = useStore()\n    return store.dispatch\n  }\n\n  Object.assign(useDispatch, {\n    withTypes: () => useDispatch,\n  })\n\n  return useDispatch as UseDispatch<Dispatch<ActionType>>\n}\n\n/**\n * A hook to access the redux `dispatch` function.\n *\n * @returns {any|function} redux store's `dispatch` function\n *\n * @example\n *\n * import React, { useCallback } from 'react'\n * import { useDispatch } from 'react-redux'\n *\n * export const CounterComponent = ({ value }) => {\n *   const dispatch = useDispatch()\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\n *   return (\n *     <div>\n *       <span>{value}</span>\n *       <button onClick={increaseCounter}>Increase counter</button>\n *     </div>\n *   )\n * }\n */\nexport const useDispatch = /*#__PURE__*/ createDispatchHook()\n","import connect from './components/connect'\nexport type {\n  Connect,\n  ConnectProps,\n  ConnectedProps,\n} from './components/connect'\n\nimport shallowEqual from './utils/shallowEqual'\n\nimport Provider from './components/Provider'\nimport { defaultNoopBatch } from './utils/batch'\n\nexport { ReactReduxContext } from './components/Context'\nexport type { ReactReduxContextValue } from './components/Context'\n\nexport type { ProviderProps } from './components/Provider'\n\nexport type {\n  MapDispatchToProps,\n  MapDispatchToPropsFactory,\n  MapDispatchToPropsFunction,\n  MapDispatchToPropsNonObject,\n  MapDispatchToPropsParam,\n  MapStateToProps,\n  MapStateToPropsFactory,\n  MapStateToPropsParam,\n  MergeProps,\n  Selector,\n  SelectorFactory,\n} from './connect/selectorFactory'\n\nexport { createDispatchHook, useDispatch } from './hooks/useDispatch'\nexport type { UseDispatch } from './hooks/useDispatch'\n\nexport { createSelectorHook, useSelector } from './hooks/useSelector'\nexport type { UseSelector } from './hooks/useSelector'\n\nexport { createStoreHook, useStore } from './hooks/useStore'\nexport type { UseStore } from './hooks/useStore'\n\nexport type { Subscription } from './utils/Subscription'\n\nexport * from './types'\n\n/**\n * @deprecated As of React 18, batching is enabled by default for ReactDOM and React Native.\n * This is now a no-op that immediately runs the callback.\n */\nconst batch = defaultNoopBatch\n\nexport { Provider, batch, connect, shallowEqual }\n","/**\n * @license React\n * use-sync-external-store-with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var g=require(\"react\");function n(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var p=\"function\"===typeof Object.is?Object.is:n,q=g.useSyncExternalStore,r=g.useRef,t=g.useEffect,u=g.useMemo,v=g.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,h){var c=r(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=u(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==h&&f.hasValue){var b=f.value;if(h(b,a))return k=b}return k=a}b=k;if(p(d,a))return b;var e=l(a);if(void 0!==h&&h(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,h]);var d=q(a,c[0],c[1]);\nt(function(){f.hasValue=!0;f.value=d},[d]);v(d);return d};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/use-sync-external-store-with-selector.production.min.js');\n} else {\n  module.exports = require('./cjs/use-sync-external-store-with-selector.development.js');\n}\n","function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return arrayLikeToArray(r);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableRest = require(\"./nonIterableRest.js\");\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithoutHoles = require(\"./arrayWithoutHoles.js\");\nvar iterableToArray = require(\"./iterableToArray.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableSpread = require(\"./nonIterableSpread.js\");\nfunction _toConsumableArray(r) {\n  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["React2","e","r","__esModule","default","t","_getRequireWildcardCache","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_interopRequireWildcard","require","ReactOriginal","_withSelector","WeakMap","React","ContextKey","Symbol","for","gT","globalThis","ReactReduxContext","exports","_a","createContext","contextMap","Map","realContext","getContext","notInitialized","Error","createReduxContextHook","context","arguments","length","undefined","useContext","useReduxContext","useSyncExternalStoreWithSelector","refEquality","b","createSelectorHook","useReduxContext2","useSelector2","selector","equalityFnOrOptions","_ref","equalityFn","_ref$equalityFn","_ref$devModeChecks","devModeChecks","_useReduxContext","store","subscription","getServerState","stabilityCheck","wrappedSelector","identityFunctionCheck","useRef","useCallback","_defineProperty2","name","state","selectedState","addNestedSub","getState","useDebugValue","assign","withTypes","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_SERVER_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","ForwardRef","Memo","typeOf","object","$$typeof","type","$$typeofType","pureFinalPropsSelectorFactory","mapStateToProps","mapDispatchToProps","mergeProps","dispatch","_ref2","ownProps","stateProps","dispatchProps","mergedProps","areStatesEqual","areOwnPropsEqual","areStatePropsEqual","hasRunAtLeastOnce","handleSubsequentCalls","nextState","nextOwnProps","nextStateProps","statePropsChanged","propsChanged","stateChanged","dependsOnOwnProps","wrapMapToPropsConstant","getConstant","constant","constantSelector","getDependsOnOwnProps","mapToProps","Boolean","wrapMapToPropsFunc","methodName","_ref3","displayName","proxy","stateOrDispatch","props","createInvalidArgFactory","arg","options","wrappedComponentName","defaultMergeProps","__spreadValues","defaultNoopBatch","callback","nullListeners","notify","createSubscription","parentSub","unsubscribe","listeners","subscriptionsAmount","selfSubscribed","handleChangeWrapper","onStateChange","trySubscribe","first","last","subscribe","clear","listener","next","push","isSubscribed","prev","tryUnsubscribe","cleanupListener","removed","notifyNestedSubs","getListeners","canUseDOM","window","document","createElement","isReactNative","navigator","product","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","is","x","y","shallowEqual","objA","objB","keysA","keys","keysB","prototype","REACT_STATICS","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","KNOWN_STATICS","caller","callee","arity","MEMO_STATICS","compare","TYPE_STATICS","render","getStatics","component","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","objectPrototype","hoistNonReactStatics","targetComponent","sourceComponent","inheritedComponent","concat","targetStatics","sourceStatics","key","descriptor","useSyncExternalStore","NO_SUBSCRIPTION_ARRAY","captureWrapperProps","lastWrapperProps","lastChildProps","renderIsScheduled","wrapperProps","childPropsFromStoreUpdate","current","strictEqual","_ref5","_ref5$areStatesEqual","pure","_ref5$areOwnPropsEqua","_ref5$areStatePropsEq","_ref5$areMergedPropsE","areMergedPropsEqual","_ref5$forwardRef","forwardRef","_ref5$context","Context","initMapStateToProps","mapStateToPropsFactory","initMapDispatchToProps","actionCreators","boundActionCreators","_loop","actionCreator","apply","bindActionCreators","mapDispatchToPropsFactory","initMergeProps","_ref4","hasRunOnce","nextMergedProps","wrapMergePropsFunc","mergePropsFactory","shouldHandleStateChanges","WrappedComponent","selectorFactoryOptions","ConnectFunction","_React$useMemo","useMemo","reactReduxForwardedRef2","reactReduxForwardedRef","wrapperProps2","__objRest","_React$useMemo2","_slicedToArray2","propsContext","ContextToUse","ResultContext","Consumer","contextValue","didStoreComeFromProps","didStoreComeFromContext","childPropsSelector","_b","finalPropsSelectorFactory","_React$useMemo3","subscription2","notifyNestedSubs2","bind","_React$useMemo4","overriddenContextValue","__spreadProps","isMounted","latestSubscriptionCallbackError","effectFunc","effectArgs","dependencies","actualChildProps","actualChildPropsSelector","subscribeForReact","reactListener","additionalSubscribeListener","didUnsubscribe","lastThrownError","checkForUpdates","newChildProps","error","latestStoreState","subscribeUpdates","_toConsumableArray2","err","message","stack","renderedWrappedComponent","ref","Provider","value","Connect","memo","forwarded","_ref6","children","serverState","_ref6$stabilityCheck","_ref6$identityFunctio","previousState","createStoreHook","useStore2","useStore","createDispatchHook","useDispatch2","fn","useSyncExternalStoreWithSelector2","initializeConnect","g","p","q","v","l","h","c","f","hasValue","d","k","m","module","Array","isArray","arrayLikeToArray","toPropertyKey","enumerable","configurable","writable","iterator","from","o","done","TypeError","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arrayWithoutHoles","iterableToArray","nonIterableSpread","_typeof","toPrimitive","String","Number","constructor","toString","slice","test"],"sourceRoot":""}